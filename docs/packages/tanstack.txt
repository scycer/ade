---
library: tanstack/tanstack.com
created_by: docfork.com
source: https://github.com/tanstack/tanstack.com
commit: 097309
updated_at: 2025-06-10T15:36:26.722967
---

title: Installing React Query
description: Demonstrates how to install the `@tanstack/react-query` package using npm and yarn. These commands add the library as a project dependency, enabling access to its features for data fetching and state management within React applications.
source: #_snippet_0

language: bash
code:
```
npm i @tanstack/react-query
# or
yarn add @tanstack/react-query
```

---

title: Installing TanStack Form
description: Demonstrates how to install TanStack Form using `npm` for different frameworks such as React, Vue, Angular, Solid, and Lit. This command adds the necessary package to your project's dependencies.
source: #_snippet_0

language: shell
code:
```
$ npm i @tanstack/react-form
# or
$ npm i @tanstack/vue-form
# or
$ npm i @tanstack/angular-form
# or
$ npm i @tanstack/solid-form
# or
$ npm i @tanstack/lit-form
```

---

title: Running Chatbot Template
description: Demonstrates how to create a TanStack Router app with the `tanchat` template. This command scaffolds a new project with a pre-configured chatbot setup, integrating TanStack Start's data management capabilities and Netlify Functions for serverless integration.
source: #_snippet_0

language: bash
code:
```
npx create-tsrouter-app@latest <name> --template file-router --add-ons tanchat
```

---

title: Starting Development
description: Demonstrates the commands to install dependencies and start the application in development mode using `pnpm`. Running `pnpm dev` will start the app and rebuild assets on file changes, facilitating rapid development.
source: #_snippet_0

language: sh
code:
```
pnpm install
pnpm dev
```

---

title: Defining Search Parameter Schema In TanStack Router
description: Illustrates how to define a search parameter schema directly within a TanStack Router route definition. This schema serves as the single source of truth for type inference and validation, ensuring consistency across the application.
source: #_snippet_1

language: ts
code:
```
export const Route = createFileRoute('/dashboards/overview')({
  validateSearch: z.object({
    sort: z.enum(['asc', 'desc']),
    filter: z.string().optional(),
  }),
})
```

---

title: Defining a Query Function - Typescript
description: Demonstrates how to define a query function in Convex using the `query` import. The function takes arguments defined using `v.number()` and `v.string()`, accesses the database via `ctx.db.query()`, and returns documents. This function is designed for reading data from the database.
source: #_snippet_0

language: typescript
code:
```
import { query } from "./_generated/server";
import { v } from "convex/values";

export const myQueryFunction = query({
  // Validators for arguments.
  args: {
    first: v.number(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Read the database as many times as you need here.
    // See https://docs.convex.dev/database/reading-data.
    const documents = await ctx.db.query("tablename").collect();

    // Arguments passed from the client are properties of the args object.
    console.log(args.first, args.second);

    // Write arbitrary JavaScript here: filter, aggregate, build derived data,
    // remove non-public properties, or create new objects.
    return documents;
  },
});
```

---

title: Using a Query Function in React - Typescript
description: Illustrates how to use a Convex query function within a React component using the `useQuery` hook.  It passes arguments (`first` and `second`) to the `myQueryFunction` and stores the returned data in the `data` variable.  This allows the React component to reactively display data fetched from the Convex backend.
source: #_snippet_1

language: typescript
code:
```
const data = useQuery(api.functions.myQueryFunction, {
  first: 10,
  second: "hello",
});
```

---

title: Defining a Mutation Function - Typescript
description: Shows how to define a mutation function in Convex using the `mutation` import. The function takes arguments defined using `v.string()`, inserts data into the database via `ctx.db.insert()`, and optionally returns a value. This function is designed for modifying data in the database.
source: #_snippet_2

language: typescript
code:
```
import { mutation } from "./_generated/server";
import { v } from "convex/values";

export const myMutationFunction = mutation({
  // Validators for arguments.
  args: {
    first: v.string(),
    second: v.string(),
  },

  // Function implementation.
  handler: async (ctx, args) => {
    // Insert or modify documents in the database here.
    // Mutations can also read from the database like queries.
    // See https://docs.convex.dev/database/writing-data.
    const message = { body: args.first, author: args.second };
    const id = await ctx.db.insert("messages", message);

    // Optionally, return a value from your mutation.
    return await ctx.db.get(id);
  },
});
```

---

title: Using a Mutation Function in React - Typescript
description: Illustrates how to use a Convex mutation function within a React component using the `useMutation` hook. It demonstrates how to call the mutation with arguments (`first` and `second`) to update the Convex database. The code shows both fire-and-forget usage and usage with a `.then()` callback to handle the result.
source: #_snippet_3

language: typescript
code:
```
const mutation = useMutation(api.functions.myMutationFunction);
function handleButtonPress() {
  // fire and forget, the most common way to use mutations
  mutation({ first: "Hello!", second: "me" });
  // OR
  // use the result once the mutation has completed
  mutation({ first: "Hello!", second: "me" }).then((result) =>
    console.log(result),
  );
}
```

---

title: Defining A Parent Route With Search Parameter Validation
description: Defines a parent route in TanStack Router with a `validateSearch` schema using Zod. This schema enforces that the `sort` parameter must be either `asc` or `desc`, and defaults to `asc` if not provided.
source: #_snippet_4

language: ts
code:
```
// routes/dashboard.tsx
export const Route = createFileRoute('/dashboard')({
  validateSearch: z.object({
    sort: z.enum(['asc', 'desc']).default('asc'),
  }),
})
```

---

title: Demonstrating Type Safety With Search Parameter Inheritance
description: Demonstrates how TanStack Router prevents incompatible search parameter definitions between parent and child routes. Attempting to redefine a required parent search parameter with a different type in the child route results in a type error.
source: #_snippet_6

language: ts
code:
```
validateSearch: z.object({
  // ❌ Type error: boolean does not extend 'asc' | 'desc' from parent
  sort: z.boolean(),
  filter: z.string().optional(),
})
```

---

title: Configuring Server Preset - JSX
description: Demonstrates how to configure the server preset for Vercel in a TanStack Start project. By setting `server.preset` to `'vercel'` within the `defineConfig` function, the project is optimized for deployment on the Vercel platform, leveraging Nitro's adapter-less capabilities.
source: #_snippet_0

language: jsx
code:
```
import { defineConfig } from '@tanstack/react-start/config'

export default defineConfig({
  server: {
    preset: 'vercel',
  },
})
```

---

title: Using Link Component with Route Inference - TypeScript
description: Demonstrates the use of the `<Link>` component in TanStack Router and how providing the `from` prop improves type inference and editor performance.  It shows that specifying the origin route allows TanStack Router to narrow the types and avoid scanning the entire route tree, resulting in better type safety and a more responsive editor experience, especially in large applications.
source: #_snippet_0

language: tsx
code:
```
<Link from="/dashboard" search={{ page: 0 }} />
<Link from="/dashboard" to=".." search={{page: 0}} />
<Link from="/users" to="/dashboard" search={prev => ({...prev, page: 0 })} />
```

---

title: Specifying Route Context with Strict Mode - TypeScript
description: Illustrates how to use the `from` property in TanStack Router hooks like `useSearch`, `useParams`, `useRouteContext`, `useLoaderData`, and `useMatch` to improve editor performance and type safety. By providing the `from` property, the hooks can narrow the types to specific routes, avoiding the need to infer the entire route tree, which is especially beneficial in larger applications with complex route configurations.
source: #_snippet_1

language: tsx
code:
```
const search = useSearch({ from: '/dashboard' })
const params = useParams({ from: '/dashboard' })
const context = useRouteContext({ from: '/dashboard' })
const loaderData = useLoaderData({ from: '/dashboard' })
const match = useMatch({ from: '/dashboard' })
```

---

title: Using Typed Search Parameters In TanStack Router
description: Demonstrates using the validated and typed search parameters in a TanStack Router `Link` component.  The `search` prop is fully typed and validated against the route's schema, providing autocomplete and preventing invalid search parameter values.
source: #_snippet_2

language: tsx
code:
```
<Link
  to="/dashboards/overview"
  search={{ sort: 'asc' }} // fully typed, fully validated
/>
```

---

title: Extending Parent Search Parameters In A Child Route
description: Shows how a child route in TanStack Router can extend the search parameter schema defined in its parent route. The child route inherits the `sort` parameter from the parent and adds a new `filter` parameter.
source: #_snippet_5

language: ts
code:
```
// routes/dashboard/$dashboardId.tsx
export const Route = createFileRoute('/dashboard/$dashboardId')({
  validateSearch: z.object({
    filter: z.string().optional(),
    // ✅ `sort` is inherited automatically from the parent
  }),
})
```

---

title: Ensuring Type Safety with useForm
description: Illustrates how `useForm` provides extreme type safety by inferring types from the `defaultValues` option. It shows how TypeScript correctly identifies invalid field names and incorrect types, enhancing developer experience and preventing runtime errors.
source: #_snippet_1

language: tsx
code:
```
const form = useForm({
	defaultValues: {
        name: "",
        age: 0
    }
});

// TypeScript will correctly tell you that `firstName` is not a valid field
<form.Field name="firstName"/>

// TypeScript will correctly tell you that `name`'s type is a `string`, not a `number`
<form.Field name="name" children={field => <NumberInput value={field.state.value}/>}/>
```

---

title: Generating Route Mappings for File-Based Routing - TypeScript
description: Illustrates generating explicit route mappings (`FileRoutesByFullPath`, `FileRoutesByTo`, `FileRoutesById`) and related types directly when the route tree is generated in file-based routing. This approach avoids the need for the `ParseRoute` type, which significantly improves TypeScript's language service performance in large route trees.
source: #_snippet_5

language: tsx
code:
```
export interface FileRoutesByFullPath {
  '/': typeof IndexRoute
  '/posts': typeof PostsRouteWithChildren
  '/posts/$postId': typeof PostsPostIdRoute
  '/posts/': typeof PostsIndexRoute
  '/layout-a': typeof LayoutLayout2LayoutARoute
  '/layout-b': typeof LayoutLayout2LayoutBRoute
}

export interface FileRoutesByTo {
  '/': typeof IndexRoute
  '/posts/$postId': typeof PostsPostIdRoute
  '/posts': typeof PostsIndexRoute
  '/layout-a': typeof LayoutLayout2LayoutARoute
  '/layout-b': typeof LayoutLayout2LayoutBRoute
}

export interface FileRoutesById {
  __root__: typeof rootRoute
  '/': typeof IndexRoute
  '/_layout': typeof LayoutRouteWithChildren
  '/posts': typeof PostsRouteWithChildren
  '/_layout/_layout-2': typeof LayoutLayout2RouteWithChildren
  '/posts/$postId': typeof PostsPostIdRoute
  '/posts/': typeof PostsIndexRoute
  '/_layout/_layout-2/layout-a': typeof LayoutLayout2LayoutARoute
  '/_layout/_layout-2/layout-b': typeof LayoutLayout2LayoutBRoute
}

export interface FileRouteTypes {
  fileRoutesByFullPath: FileRoutesByFullPath
  fullPaths:
    | '/'
    | '/posts'
    | '/posts/$postId'
    | '/posts/'
    | '/layout-a'
    | '/layout-b'
  fileRoutesByTo: FileRoutesByTo
  to: '/' | '/posts/$postId' | '/posts' | '/layout-a' | '/layout-b'
  id:
    | '__root__'
    | '/'
    | '/_layout'
    | '/posts'
    | '/_layout/_layout-2'
    | '/posts/$postId'
    | '/posts/'
    | '/_layout/_layout-2/layout-a'
    | '/_layout/_layout-2/layout-b'
  fileRoutesById: FileRoutesById
}

export interface RootRouteChildren {
  IndexRoute: typeof IndexRoute
  LayoutRoute: typeof LayoutRouteWithChildren
  PostsRoute: typeof PostsRouteWithChildren
}

const rootRouteChildren: RootRouteChildren = {
  IndexRoute: IndexRoute,
  LayoutRoute: LayoutRouteWithChildren,
  PostsRoute: PostsRouteWithChildren,
}

export const routeTree = rootRoute
  ._addFileChildren(rootRouteChildren)
  ._addFileTypes<FileRouteTypes>()
```

---

title: Creating Project Directory
description: Illustrates the process of creating a new directory named `tanstack` and navigating into it. This directory will house the cloned repositories for `tanstack.com` and other TanStack projects, enabling local documentation editing and previewing.
source: #_snippet_1

language: sh
code:
```
mkdir tanstack
```

---

title: Cloning Repositories
description: Demonstrates how to clone the `tanstack.com` repository and a specific TanStack project repository (e.g., `TanStack/form`) into the `tanstack` directory.  This setup is essential for editing and previewing documentation changes locally.
source: #_snippet_2

language: sh
code:
```
cd tanstack
git clone git@github.com:TanStack/tanstack.com.git
git clone git@github.com:TanStack/form.git
```

---

title: Installing Dependencies and Running in Development Mode
description: Illustrates how to install dependencies and start the `tanstack.com` application in development mode after cloning the repository. The application will run on `https://localhost:3000` by default, allowing local previewing of documentation changes.
source: #_snippet_3

language: sh
code:
```
cd tanstack.com
pnpm i
# The app will run on https://localhost:3000 by default
pnpm dev
```

---

title: Validating Sort Parameter With Zod
description: Demonstrates validating a `sort` search parameter using Zod. It defines a schema for the `sort` parameter, parses the URL search parameters, and handles potential parsing errors by redirecting or showing an error.
source: #_snippet_0

language: ts
code:
```
const schema = z.object({
  sort: z.enum(['asc', 'desc']),
})

const raw = Object.fromEntries(new URLSearchParams(location.href))
const result = schema.safeParse(raw)

if (!result.success) {
  // fallback, redirect, or show error
}
```

---

title: Updating Search State Transactionally In TanStack Router
description: Illustrates how to update search parameters transactionally within TanStack Router using a reducer-style pattern.  This allows for safe and predictable state updates, ensuring components only re-render when relevant search parameters change.
source: #_snippet_3

language: ts
code:
```
navigate({
  search: (prev) => ({ ...prev, page: prev.page + 1 }),
})
```

---

title: Validating Field Errors with Typescript
description: Demonstrates how `<form.Field>` supports type-checking for errors, ensuring that the structure of `errorMap` aligns with the validation logic. This example shows how TypeScript can identify incorrect error object structures, helping to prevent unexpected behavior and improve code reliability.
source: #_snippet_2

language: tsx
code:
```
<form.Field
  name="age"
  validators={{
    onChange: ({ value }) => (value < 12 ? { tooYoung: true } : undefined),
  }}
  children={(field) => (
    <>
      <NumberInput value={field.state.value} />
      // TypeScript will correctly tell you that `errorMap.onChange` // is an object,
      not a string
      <p>{field.state.meta.errorMap.onChange}</p>
    </>
  )}
/>
```

---

title: Implementing Schema Validation with Zod
description: Illustrates how to integrate schema validation using Zod within TanStack Form. The `userSchema` defines the validation rules for the `age` field, and the `validators` prop in `useForm` applies this schema. This enables easy and standardized form validation.
source: #_snippet_3

language: tsx
code:
```
const userSchema = z.object({
  age: z.number().gte(13, 'You must be 13 to make an account'),
})

function App() {
  const form = useForm({
    defaultValues: {
      age: 0,
    },
    validators: {
      onChange: userSchema,
    },
  })
  return (
    <div>
      <form.Field
        name="age"
        children={(field) => {
          return <>{/* ... */}</>
        }}
      />
    </div>
  )
}
```

---

title: Validating Forms Server-Side (Next.js)
description: Illustrates server-side form validation using TanStack Form with Next.js. It showcases how to import `createServerValidate` and `getFormData` from `@tanstack/react-form/start` and how to integrate this with your schema for seamless backend validation.
source: #_snippet_5

language: typescript
code:
```
// app/routes/index.tsx, but can be extracted to any other path
import { createServerValidate, getFormData } from '@tanstack/react-form/start'
import { yourSchemaHere } from '~/constants/forms'

const serverValidate = createServerValidate({
  ...formOpts,
  onServerValidate: yourSchemaHere,
})

export const getFormDataFromServer = createServerFn({ method: 'GET' }).handler(
  async () => {
    return getFormData()
  }
)
```

---

title: Declaring Route Tree Children with an Interface - TypeScript
description: Illustrates declaring route tree children using a TypeScript interface instead of relying on full type inference, improving TypeScript's language service performance. This approach allows the language service to avoid crawling the entire route tree during type checking.
source: #_snippet_2

language: tsx
code:
```
export interface RootRouteChildren {
  IndexRoute: typeof IndexRoute
  LayoutRoute: typeof LayoutRouteWithChildren
  PostsRoute: typeof PostsRouteWithChildren
}

const rootRouteChildren: RootRouteChildren = {
  IndexRoute: IndexRoute,
  LayoutRoute: LayoutRouteWithChildren,
  PostsRoute: PostsRouteWithChildren,
}

export const routeTree = rootRoute._addFileChildren(rootRouteChildren)
```

---

title: Generating Trace Information - TypeScript
description: Illustrates how to generate a trace file from TypeScript using the `tsc` command. This trace file can be used to diagnose performance issues and understand the type-checking process of the TypeScript compiler.
source: #_snippet_0

language: shell
code:
```
tsc --generatetrace trace
```

---

title: Performing Async Validation with Debouncing
description: Demonstrates how to perform asynchronous validation in TanStack Form with built-in debouncing and `AbortSignal`-based cancellation. The `onBlurAsync` validator fetches the current age on the profile and returns an error if the input value is less than the fetched age, preventing rapid or unnecessary requests.
source: #_snippet_4

language: tsx
code:
```
<form.Field
  name="age"
  asyncDebounceMs={500}
  validators={{
    onBlurAsync: async ({ value, signal }) => {
      const currentAge = await fetchCurrentAgeOnProfile({ signal })
      return value < currentAge ? 'You can only increase the age' : undefined
    },
  }}
/>
```

---

title: Creating Route Trees by Adding Children - React
description: Demonstrates the initial approach to creating a route tree by chaining `.addChildren` calls, which relies on type inference.  This method can lead to performance bottlenecks in large applications due to the TypeScript language service needing to crawl the entire route tree.
source: #_snippet_1

language: tsx
code:
```
export const routeTree = rootRoute.addChildren({
  IndexRoute,
  LayoutRoute: LayoutRoute.addChildren({
    LayoutLayout2Route: LayoutLayout2Route.addChildren({
      LayoutLayout2LayoutARoute,
      LayoutLayout2LayoutBRoute,
    }),
  }),
  PostsRoute: PostsRoute.addChildren({ PostsPostIdRoute, PostsIndexRoute }),
})
```

---

title: Mapping Routes by Full Path - TypeScript
description: Demonstrates how the `RoutesByPath` mapped type creates a type mapping from full path to route, leveraging the `ParseRoute` type. This mapping is crucial for type-safe routing, enabling the router to infer route types based on the provided path.
source: #_snippet_4

language: tsx
code:
```
export type RoutesByPath<TRouteTree extends AnyRoute> = {
  [K in ParseRoute<TRouteTree> as K['fullPath']]: K
}
```

---

title: Parsing Route Definition Type - TypeScript
description: Illustrates a TypeScript type `ParseRoute` that walks down the route tree to create a union of all routes. This union is then used to create a type mapping from `id` -> `Route`, `from` -> `Route` and also `to` -> `Route`.
source: #_snippet_3

language: tsx
code:
```
export type ParseRoute<TRouteTree, TAcc = TRouteTree> = TRouteTree extends {
  types: { children: infer TChildren }
}
  ? unknown extends TChildren
    ? TAcc
    : TChildren extends ReadonlyArray<any>
    ? ParseRoute<TChildren[number], TAcc | TChildren[number]>
    : ParseRoute<TChildren[keyof TChildren], TAcc | TChildren[keyof TChildren]>
  : TAcc
```

