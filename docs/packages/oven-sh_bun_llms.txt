---
library: oven-sh/bun
created_by: docfork.com
source: https://github.com/oven-sh/bun
commit: 245abb9
updated_at: 08/01/2025 08:28:03 PM UTC
---

title: Ignoring Environment File
description: Shows how to add `.env.local` to `.gitignore`. This prevents the accidental commit of the bot's private key to version control.
source: docs/guides/ecosystem/discordjs.md#_snippet_2

language: txt
code:
```
node_modules
.env.local
```

---

title: Installing Dependencies with Bun
description: Demonstrates installing project dependencies using the `bun install` command. This command is used to fetch and install the necessary packages defined in the project's `package.json` file, allowing the application to run correctly.
source: src/cli/init/README2.default.md#_snippet_0

language: bash
code:
```
bun install
```

---

title: Installing Expo Dependencies
description: Demonstrates how to install the dependencies for an Expo project using `npm install`. This command fetches and installs all packages listed in the `package.json` file, enabling the project to run correctly.
source: test/integration/expo-app/README.md#_snippet_0

language: bash
code:
```
npm install
```

---

title: Installing Dependencies with npm
description: Demonstrates how to install project dependencies using `npm`. This command is essential for setting up the project environment by installing all the necessary packages defined in the `package.json` file.
source: test/js/third_party/pnpm/install_fixture/README.md#_snippet_0

language: bash
code:
```
$ npm install # or pnpm install or yarn install
```

---

title: Installing Dependencies with Bun
description: Demonstrates how to install project dependencies using the `bun install` command. This command is essential for setting up the project environment and ensuring all required packages are available.
source: src/cli/init/README.default.md#_snippet_0

language: bash
code:
```
bun install
```

---

title: Installing Bun
description: Demonstrates different methods for installing Bun on various operating systems. The installation can be done via a shell script, npm, Homebrew, or Docker, providing flexibility for different environments.
source: README.md#_snippet_2

language: sh
code:
```
# with install script (recommended)
curl -fsSL https://bun.com/install | bash
```

language: powershell
code:
```
# on windows
powershell -c "irm bun.com/install.ps1 | iex"
```

language: sh
code:
```
# with npm
npm install -g bun

# with Homebrew
brew tap oven-sh/bun
brew install bun

# with Docker
docker pull oven/bun
docker run --rm --init --ulimit memlock=-1:-1 oven/bun
```

---

title: Building llhttp Library
description: Demonstrates the steps to build the `llhttp` library. It uses `npm ci` to install dependencies and `make` to compile the library, preparing it for use.
source: src/bun.js/bindings/node/http/llhttp/README.md#_snippet_0

language: shell
code:
```
npm ci && make
```

---

title: Generating RSA Key
description: Demonstrates generating an RSA private key using `openssl`. This key is used for creating a certificate.
source: test/js/node/test/fixtures/0-dns/README.md#_snippet_0

language: console
code:
```
$ openssl genrsa -out 0-dns-key.pem 2048
Generating RSA private key, 2048 bit long modulus
...................+++
..............................................................................................+++
e is 65537 (0x10001)
```

---

title: Installing Dependencies
description: Illustrates installing the required dependencies, `asn1.js` and `asn1.js-rfc5280`, using `npm`. These libraries are necessary for creating the test certificate.
source: test/js/node/test/fixtures/0-dns/README.md#_snippet_2

language: console
code:
```
$ npm install
0-dns@1.0.0 /home/github/node/test/fixtures/0-dns
+-- asn1.js@4.9.1
| +-- bn.js@4.11.6
| +-- inherits@2.0.3
| `-- minimalistic-assert@1.0.0
`-- asn1.js-rfc5280@1.2.2
```

---

title: Running Tests - Shell
description: Explains how to execute tests using `bun bd test <...test file>`, emphasizing the importance of using the debug build to incorporate code changes.
source: test/AGENTS.md#_snippet_0

language: sh
code:
```
bun bd test <...test file>
```

---

title: Running Commands with Debug Build - Shell
description: Shows how to run a command with the debug build of Bun using `bun bd <...cmd>`. This is essential for testing local code changes.
source: test/AGENTS.md#_snippet_1

language: sh
code:
```
bun bd <...cmd>
```

---

title: Running Tests - Shell
description: Illustrates the command to execute tests using the Bun CLI, specifically using the debug build.  This command ensures that changes are incorporated into the test run.  It emphasizes the importance of using `bun bd test` instead of `bun test` to include the latest code.
source: test/CLAUDE.md#_snippet_0

language: sh
code:
```
bun bd test <...test file>
```

---

title: Debugging Commands - Shell
description: Demonstrates how to run a command with the debug build of Bun, ensuring that the latest changes are included. The `bun bd <...cmd>` command compiles the code automatically before execution, allowing for testing with the most up-to-date version.
source: test/CLAUDE.md#_snippet_1

language: sh
code:
```
bun bd <...cmd>
```

---

title: Installing TypeScript Definitions for Bun
description: Demonstrates how to install the TypeScript definitions for Bun's built-in APIs using `bun add -d @types/bun`. This allows referencing the `Bun` global in TypeScript files without editor errors, improving the developer experience.
source: docs/typescript.md#_snippet_0

language: sh
code:
```
$ bun add -d @types/bun # dev dependency
```

language: ts
code:
```
console.log(Bun.version);
```

---

title: Importing Test Utilities for Bundling
description: Imports `itBundled` and `testForFile` from `./expectBundled` to facilitate bundler testing. This allows defining test suites using `describe`, `test`, and `expect` specific to the current file path, streamlining the test setup.
source: test/bundler/expectBundled.md#_snippet_0

language: typescript
code:
```
import { itBundled, testForFile } from "./expectBundled";
var { describe, test, expect } = testForFile(import.meta.path);
```

---

title: Uninstalling Bun (macOS/Linux - Curl)
description: Illustrates how to remove Bun from macOS, Linux, and WSL using the `rm -rf` command to delete the `~/.bun` directory. This action removes all Bun-related files and configurations from the user's home directory.
source: docs/installation.md#_snippet_0

language: bash
code:
```
$ rm -rf ~/.bun # for macOS, Linux, and WSL
```

---

title: Uninstalling Bun (Windows - PowerShell)
description: Demonstrates how to uninstall Bun on Windows using the `uninstall.ps1` script located in the `~\.bun` directory. This PowerShell command executes the script, which removes Bun and its associated files from the system.
source: docs/installation.md#_snippet_1

language: powershell
code:
```
> powershell -c ~\.bun\uninstall.ps1
```

---

title: Uninstalling Bun (Scoop)
description: Shows how to uninstall Bun using the Scoop package manager on Windows.  The `scoop uninstall bun` command removes Bun from the system if it was installed via Scoop.
source: docs/installation.md#_snippet_2

language: powershell
code:
```
> scoop uninstall bun
```

---

title: Uninstalling Bun (npm)
description: Demonstrates how to globally uninstall Bun using the npm package manager.  The `npm uninstall -g bun` command removes Bun from the system if it was installed globally via npm.
source: docs/installation.md#_snippet_3

language: bash
code:
```
$ npm uninstall -g bun
```

---

title: Uninstalling Bun (Homebrew)
description: Illustrates how to uninstall Bun using the Homebrew package manager on macOS. The `brew uninstall bun` command removes Bun from the system if it was installed via Homebrew.
source: docs/installation.md#_snippet_4

language: bash
code:
```
$ brew uninstall bun
```

---

title: Initializing the LinkerContext
description: Demonstrates how the `LinkerContext` is initialized with bundle data to prepare the graph for linking. It covers setting up the parse graph reference, configuring code splitting and logging, loading entry points, and setting up runtime symbol references.
source: src/bundler/linker_context/README.md#_snippet_0

---

title: Initializing a Bun Project
description: Demonstrates how to initialize a new Bun project using the `bun init` command. The command scaffolds a basic project structure, including `package.json`, `index.ts`, `.gitignore`, and `tsconfig.json` files, setting up a foundation for further development.
source: docs/quickstart.md#_snippet_0

language: bash
code:
```
$ mkdir quickstart
$ cd quickstart
```

language: bash
code:
```
$ bun init
bun init helps you get started with a minimal project and tries to
guess sensible defaults. Press ^C anytime to quit.

package name (quickstart):
entry point (index.ts):

Done! A package.json file was saved in the current directory.
 + index.ts
 + .gitignore
 + tsconfig.json (for editor auto-complete)
 + README.md

To get started, run:
  bun run index.ts
```

---

title: Bailing Early with Bun Test
description: Demonstrates the use of the `--bail` flag with the `bun test` command to stop a test run after the first failure. This is useful in CI environments to quickly identify and address critical issues.
source: docs/guides/test/bail.md#_snippet_0

language: shell
code:
```
$ bun test --bail
```

---

title: Running Tests with Code Coverage
description: Demonstrates how to enable code coverage reporting in Bun using the `--coverage` flag. This provides insights into the percentage of functions and lines executed during testing, and identifies uncovered line numbers.
source: docs/guides/test/coverage.md#_snippet_0

language: shell
code:
```
$ bun test --coverage

test.test.ts:
âœ“ math > add [0.71ms]
âœ“ math > multiply [0.03ms]
âœ“ random [0.13ms]
-------------|---------|---------|-------------------
File         | % Funcs | % Lines | Uncovered Line #s
-------------|---------|---------|-------------------
All files    |   66.67 |   77.78 |
 math.ts     |   50.00 |   66.67 |
 random.ts   |   50.00 |   66.67 |
-------------|---------|---------|-------------------

 3 pass
 0 fail
 3 expect() calls
```

---

title: Installing Happy DOM
description: Demonstrates installing the `happy-dom` package as a development dependency using the `bun add` command. This allows mocking browser APIs for testing purposes.
source: docs/guides/test/happy-dom.md#_snippet_0

language: sh
code:
```
$ bun add -d @happy-dom/global-registrator
```

---

title: Setting a Minimum Coverage Threshold - Bun
description: Illustrates how to define a minimum code coverage threshold in `bunfig.toml`. Setting `coverageThreshold` to a value (e.g., 0.9) enforces that at least 90% of the codebase must be covered by tests. If the test suite fails to meet this threshold, `bun test` will exit with a non-zero code, indicating a test failure.
source: docs/guides/test/coverage-threshold.md#_snippet_1

language: toml
code:
```
[test]
# to require 90% line-level and function-level coverage
coverageThreshold = 0.9
```

language: sh
code:
```
$ bun test --coverage
<test output>
$ echo $?
1 # this is the exit code of the previous command
```

---

title: Configuring a Testing Environment with Lifecycle Hooks
description: Illustrates the use of `beforeAll` lifecycle hook to set a deterministic 'fake clock' using `setSystemTime` before running the tests. This ensures that all tests within the suite operate under the same simulated time, which prevents time-related tests from being affected by the actual system clock. It imports the required modules and sets the system time to a specific date.
source: docs/guides/test/mock-clock.md#_snippet_1

language: typescript
code:
```
import { test, expect, beforeAll, setSystemTime } from "bun:test";

beforeAll(() => {
  const date = new Date("1999-01-01T00:00:00.000Z");
  setSystemTime(date); // it's now January 1, 1999
});

// tests...
```

---

title: Installing Bun via Curl (macOS/Linux)
description: Demonstrates installing the latest version of Bun using `curl` on macOS and Linux systems. It also shows how to install a specific version by passing the version number to the install script.
source: docs/installation.md#_snippet_0

language: bash
code:
```
$ curl -fsSL https://bun.com/install | bash # for macOS, Linux, and WSL
# to install a specific version
$ curl -fsSL https://bun.com/install | bash -s "bun-v$BUN_LATEST_VERSION"
```

---

title: Installing Happy Dom
description: Demonstrates how to install `happy-dom` as a prerequisite for using Testing Library with Bun. This allows Bun's test runner to work with DOM elements.
source: docs/guides/test/testing-library.md#_snippet_0

language: sh
code:
```
bun add -D @happy-dom/global-registrator
```

---

title: Installing Testing Library and Jest Dom
description: Illustrates how to install the necessary Testing Library packages and `@testing-library/jest-dom` for setting up React testing with Bun.  `@testing-library/jest-dom` provides custom Jest matchers for asserting on DOM nodes.
source: docs/guides/test/testing-library.md#_snippet_1

language: sh
code:
```
bun add -D @testing-library/react @testing-library/dom @testing-library/jest-dom
```

---

title: Running Bun with Hot Reload
description: Demonstrates how to start a Bun script with the `--hot` flag, enabling automatic reloading upon file changes. This is useful for speeding up development workflows by automatically restarting the script whenever a change is detected.
source: docs/guides/http/hot.md#_snippet_0

language: sh
code:
```
$ bun --hot run index.ts
```

---

title: Installing Bun (Shell)
description: Demonstrates how to install Bun using the shell script provided by bun.sh. This script automatically detects the operating system and downloads the appropriate Bun binary.
source: README.md#_snippet_0

language: shell
code:
```
curl -fsSL https://bun.sh/install | bash
```

---

title: Installing Svelte Testing Dependencies
description: Demonstrates how to install the necessary dependencies for testing Svelte components with Bun, including `@testing-library/svelte`, `svelte`, and `@happy-dom/global-registrator`. These packages provide utilities for rendering components and simulating user interactions.
source: docs/guides/test/svelte-test.md#_snippet_0

language: bash
code:
```
$ bun add @testing-library/svelte svelte@4 @happy-dom/global-registrator
```

---

title: Running a File with the Inspect Flag
description: Illustrates how to run a TypeScript file with the `--inspect` flag in Bun, which starts a WebSocket server for debugging. This allows connecting to debugging tools for interactive debugging of the Bun process.
source: docs/guides/runtime/web-debugger.md#_snippet_1

language: shell
code:
```
$ bun --inspect server.ts
------------------ Bun Inspector ------------------
Listening at:
  ws://localhost:6499/0tqxs9exrgrm

Inspect in browser:
  https://debug.bun.sh/#localhost:6499/0tqxs9exrgrm
------------------ Bun Inspector ------------------
```

---

title: Installing Typescript Definitions for Bun
description: Demonstrates how to install TypeScript definitions for Bun's built-in APIs using `bun add`. This allows you to use TypeScript with Bun and get type checking and autocompletion for Bun's APIs.
source: docs/guides/runtime/typescript.md#_snippet_0

language: shell
code:
```
$ bun add -d @types/bun # dev dependency
```

---

title: Installing Bun in GitHub Actions
description: Demonstrates how to install Bun in a GitHub Actions workflow using the `oven-sh/setup-bun` action. This action simplifies the process of setting up the Bun runtime environment, allowing you to execute `bun` commands within your CI/CD pipeline.
source: docs/guides/runtime/cicd.md#_snippet_0

language: yaml-diff
code:
```
name: my-workflow
jobs:
  my-job:
    name: my-job
    runs-on: ubuntu-latest
    steps:
      # ...
      - uses: actions/checkout@v4
+     - uses: oven-sh/setup-bun@v2

      # run any `bun` or `bunx` command
+     - run: bun install
+     - run: bun index.ts
+     - run: bun run build
```

---

title: Defining Constants Using Define Flag
description: Demonstrates how to use the `--define` flag in Bun to declare statically-analyzable constants and globals, replacing usages of an identifier or property with a constant value during runtime or build.
source: docs/guides/runtime/define-constant.md#_snippet_0

language: sh
code:
```
$ bun --define process.env.NODE_ENV="'production'" src/index.ts # Runtime
$ bun build --define process.env.NODE_ENV="'production'" src/index.ts # Build
```

---

title: Installing Bun in GitHub Actions
description: Demonstrates how to use the `oven-sh/setup-bun` GitHub Action to install Bun in a GitHub Actions workflow. This action simplifies the process of setting up the Bun runtime environment, allowing you to execute `bun` commands within your workflow.
source: docs/guides/install/cicd.md#_snippet_0

language: yaml-diff
code:
```
name: my-workflow
jobs:
  my-job:
    name: my-job
    runs-on: ubuntu-latest
    steps:
      # ...
      - uses: actions/checkout@v4
+     - uses: oven-sh/setup-bun@v2

      # run any `bun` or `bunx` command
+     - run: bun install
```

---

title: Adding a Development Dependency - Shell
description: Demonstrates how to add a package as a development dependency using `bun add --development`. The shorthand `bun add zod -d` achieves the same result by adding the `zod` package to the `devDependencies` in `package.json`.
source: docs/guides/install/add-dev.md#_snippet_0

language: shell
code:
```
$ bun add zod --dev
$ bun add zod -d # shorthand
```

---

title: Initializing a Nuxt App with nuxi
description: Demonstrates how to initialize a Nuxt application using the `nuxi init` command with Bun. This process sets up a basic Nuxt project, installs dependencies using the Bun package manager, and generates necessary types, streamlining the initial setup for Nuxt development.
source: docs/guides/ecosystem/nuxt.md#_snippet_0

language: sh
code:
```
$ bunx nuxi init my-nuxt-app
âœ” Which package manager would you like to use?
bun
â— Installing dependencies...
bun install v$BUN_LATEST_VERSION (16b4bf34)
 + @nuxt/devtools@0.8.2
 + nuxt@3.7.0
 785 packages installed [2.67s]
âœ” Installation completed.
âœ” Types generated in .nuxt
âœ¨ Nuxt project has been created with the v3 template. Next steps:
 â€º cd my-nuxt-app
 â€º Start development server with bun run dev
```

---

title: Initializing a SolidStart App
description: Demonstrates how to initialize a SolidStart application using the `bun create solid` command. This command sets up a new SolidStart project with a specified template, SSR option, and TypeScript support, streamlining the initial project setup.
source: docs/guides/ecosystem/solidstart.md#_snippet_0

language: sh
code:
```
$ bun create solid my-app
create-solid version 0.2.31

Welcome to the SolidStart setup wizard!

There are definitely bugs and some feature might not work yet.
If you encounter an issue, have a look at
https://github.com/solidjs/solid-start/issues and open a new one,
if it is not already tracked.

âœ” Which template do you want to use? â€º todomvc
âœ” Server Side Rendering? ... yes
âœ” Use TypeScript? ... yes
cloned solidjs/solid-start#main to /path/to/my-app/.solid-start
âœ” Copied project files
```

---

title: Initializing a New React Application - Bash
description: Demonstrates how to create a new React application using `bun init --react`. The command scaffolds a project with a simple React app and an API server, setting up a full-stack development environment.
source: docs/guides/ecosystem/react.md#_snippet_0

language: bash
code:
```
# Create a new React app
$ bun init --react

# Run the app in development mode
$ bun dev

# Build as a static site for production
$ bun run build

# Run the server in production
$ bun start
```

---

title: Installing React and React-Dom
description: Demonstrates how to install the `react` and `react-dom` packages using a package manager. This is the first step to using React for server-side rendering.
source: docs/guides/ecosystem/ssr-react.md#_snippet_0

language: sh
code:
```
# Any package manager can be used
$ bun add react react-dom
```

---

title: Creating New Elysia App
description: Demonstrates how to create a new Elysia application using the `bun create` command. This command initializes a new project with the necessary files and dependencies.
source: docs/guides/ecosystem/elysia.md#_snippet_0

language: bash
code:
```
$ bun create elysia myapp
$ cd myapp
$ bun run dev
```

---

title: Initializing a Nextjs App with Bun
description: Demonstrates how to scaffold a new Next.js project using `bun create next-app`. This command initializes a Next.js application and automatically installs the necessary dependencies.
source: docs/guides/ecosystem/nextjs.md#_snippet_0

language: sh
code:
```
$ bun create next-app
âœ” What is your project named? ... my-app
âœ” Would you like to use TypeScript with this project? ... No / Yes
âœ” Would you like to use ESLint with this project? ... No / Yes
âœ” Would you like to use `src/` directory with this project? ... No / Yes
âœ” Would you like to use experimental `app/` directory with this project? ... No / Yes
âœ” What import alias would you like configured? ... @/*
Creating a new Next.js app in /path/to/my-app.
```

---

title: Initializing a Remix App
description: Demonstrates how to initialize a Remix application using the `bun create remix` command. This sets up a new project directory, copies the template, initializes a Git repository, and installs dependencies using Bun. This provides a quick start for developing web applications with Remix.
source: docs/guides/ecosystem/remix.md#_snippet_0

language: sh
code:
```
$ bun create remix

 remix   v1.19.3 [U+1F4BF] Let's build a better website...

   dir   Where should we create your new project?
         ./my-app

      â—¼  Using basic template See https://remix.run/docs/en/main/guides/templates#templates for more
      âœ”  Template copied

   git   Initialize a new git repository?
         Yes

  deps   Install dependencies with bun?
         Yes

      âœ”  Dependencies installed

      âœ”  Git initialized

  done   That's it!

         Enter your project directory using cd ./my-app
         Check out README.md for development and deploy instructions.
```

---

title: Installing StricJS and Dependencies
description: Demonstrates installing the `@stricjs/router` and `@stricjs/utils` packages using `bun add`. This command adds the StricJS router and utility library as dependencies to your project, enabling you to build web applications with StricJS.
source: docs/guides/ecosystem/stric.md#_snippet_0

language: bash
code:
```
$ mkdir myapp
$ cd myapp
$ bun init
$ bun add @stricjs/router @stricjs/utils
```

---

title: Installing Sentry Bun SDK
description: Demonstrates how to add the `@sentry/bun` package to a Bun project using the `bun add` command. This command installs the Sentry SDK, enabling error tracking and performance monitoring for the application.
source: docs/guides/ecosystem/sentry.md#_snippet_0

language: sh
code:
```
$ bun add @sentry/bun
```

---

title: Installing Express
description: Installs the `express` package as a project dependency using the `bun add` command. This makes the Express framework available for building web applications.
source: docs/guides/ecosystem/express.md#_snippet_0

language: shell
code:
```
$ bun add express
```

---

title: Initializing an Astro App with Bun
description: Demonstrates initializing a new Astro project using `bun create astro`. The `create-astro` package automatically detects `bunx` and installs dependencies using `bun`. This simplifies the setup process for Astro projects when using the Bun runtime.
source: docs/guides/ecosystem/astro.md#_snippet_0

language: sh
code:
```
$ bun create astro
â•­â”€â”€â”€â”€â”€â•®  Houston:
â”‚ â—  â—¡ â—   We're glad to have you on board.
â•°â”€â”€â”€â”€â”€â•¯

 astro   v3.1.4 Launch sequence initiated.

   dir   Where should we create your new project?
         ./fumbling-field

  tmpl   How would you like to start your new project?
         Use blog template
      âœ”  Template copied

  deps   Install dependencies?
         Yes
      âœ”  Dependencies installed

    ts   Do you plan to write TypeScript?
         Yes

   use   How strict should TypeScript be?
         Strict
      âœ”  TypeScript customized

   git   Initialize a new git repository?
         Yes
      âœ”  Git initialized

  next   Liftoff confirmed. Explore your project!

         Enter your project directory using cd ./fumbling-field
         Run `bun run dev` to start the dev server. CTRL+C to stop.
         Add frameworks like react or tailwind using astro add.

         Stuck? Join us at https://astro.build/chat

â•­â”€â”€â”€â”€â”€â•®  Houston:
â”‚ â—  â—¡ â—   Good luck out there, astronaut! [U+1F680]
â•°â”€â”€â”€â”€â”€â•¯
```

---

title: Creating a SvelteKit Project with SvelteKit CLI
description: Demonstrates how to scaffold a new SvelteKit project using the `bunx sv create my-app` command. It shows the interactive prompts for selecting a template, enabling TypeScript, and choosing a package manager. This is the first step in building a SvelteKit application.
source: docs/guides/ecosystem/sveltekit.md#_snippet_0

language: sh
code:
```
$ bunx sv create my-app
â”Œ  Welcome to the Svelte CLI! (v0.5.7)
â”‚
â—‡  Which template would you like?
â”‚  SvelteKit demo
â”‚
â—‡  Add type checking with Typescript?
â”‚  Yes, using Typescript syntax
â”‚
â—†  Project created
â”‚
â—‡  What would you like to add to your project?
â”‚  none
â”‚
â—‡  Which package manager do you want to install dependencies with?
â”‚  bun
â”‚
â—‡  Successfully installed dependencies
â”‚
â—‡  Project next steps â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚                                                                          â”‚
â”‚  1: cd my-app                                                            â”‚
â”‚  2: git init && git add -A && git commit -m "Initial commit" (optional)  â”‚
â”‚  3: bun run dev -- --open                                                â”‚
â”‚                                                                          â”‚
â”‚  To close the dev server, hit Ctrl-C                                     â”‚
â”‚                                                                          â”‚
â”‚  Stuck? Visit us at https://svelte.dev/chat                              â”‚
â”‚                                                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â”‚
â””  You're all set!
```

---

title: Initializing a Prisma Project with Bun
description: Demonstrates how to initialize a new Prisma project using Bun. This involves creating a directory, navigating into it, and using `bun init` to set up a new Bun project. This prepares the environment for installing Prisma dependencies.
source: docs/guides/ecosystem/prisma.md#_snippet_0

language: bash
code:
```
$ mkdir prisma-app
$ cd prisma-app
$ bun init
```

---

title: Initializing a Hono Project with Bun
description: Illustrates how to initialize a new Hono project using `bun create hono`. The commands shown create a new Hono project named `myapp` using the `bun` template, navigate into the project directory, and install the dependencies.
source: docs/guides/ecosystem/hono.md#_snippet_1

language: sh
code:
```
$ bun create hono myapp
âœ” Which template do you want to use? â€º bun
cloned honojs/starter#main to /path/to/myapp
âœ” Copied project files
$ cd myapp
$ bun install
```

---

title: Installing Discord.js
description: Installs the `discord.js` package using `bun add`, which is required to build Discord bots with Bun.
source: docs/guides/ecosystem/discordjs.md#_snippet_0

language: sh
code:
```
$ bun add discord.js
```

---

title: Installing Project Dependencies Using Bun
description: Illustrates how to navigate into the newly created project directory and install the necessary dependencies using `bun install`. This ensures all project requirements are met before running the application.
source: docs/guides/ecosystem/vite.md#_snippet_1

language: bash
code:
```
cd my-app
bun install
```

---

title: Migrating From Npm Install to Bun Install
description: These commands demonstrate how to migrate from `npm install` to `bun install` for installing, adding, and removing dependencies. `bun install` is designed as a faster, Node.js-compatible alternative to `npm install`.
source: docs/guides/install/from-npm-install-to-bun-install.md#_snippet_0

language: bash
code:
```
# It only takes one command to migrate
$ bun i

# To add dependencies:
$ bun i @types/bun

# To add devDependencies:
$ bun i -d @types/bun

# To remove a dependency:
$ bun rm @types/bun
```

---

title: Adding Neon Serverless Driver - Shell
description: Demonstrates how to create a project directory, initialize the directory using `bun init`, and add the `@neondatabase/serverless` package as a project dependency.
source: docs/guides/ecosystem/neon-serverless-postgres.md#_snippet_0

language: shell
code:
```
$ mkdir bun-neon-postgres
$ cd bun-neon-postgres
$ bun init -y
$ bun add @neondatabase/serverless
```

---

title: Initializing a New Qwik App with Bun
description: Demonstrates initializing a new Qwik app using `bun create-qwik`. The `create-qwik` package automatically detects `bunx` and installs dependencies using `bun`. This simplifies the setup process for Qwik projects when using Bun as the package manager.
source: docs/guides/ecosystem/qwik.md#_snippet_0

language: sh
code:
```
$ bun create qwik

      ............
    .::: :--------:.
   .::::  .:-------:.
  .:::::.   .:-------.
  ::::::.     .:------.
 ::::::.        :-----:
 ::::::.       .:-----.
  :::::::.     .-----.
   ::::::::..   ---:.
    .:::::::::. :-:.
     ..::::::::::::
             ...::::


â”Œ  Let's create a  Qwik App  âœ¨ (v1.2.10)
â”‚
â—‡  Where would you like to create your new project? (Use '.' or './' for current directory)
â”‚  ./my-app
â”‚
â—  Creating new project in  /path/to/my-app  ... [U+1F407]
â”‚
â—‡  Select a starter
â”‚  Basic App
â”‚
â—‡  Would you like to install bun dependencies?
â”‚  Yes
â”‚
â—‡  Initialize a new git repository?
â”‚  No
â”‚
â—‡  Finishing the install. Wanna hear a joke?
â”‚  Yes
â”‚
â—‹  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚                                                          â”‚
â”‚  How do you know if thereâ€™s an elephant under your bed?  â”‚
â”‚  Your head hits the ceiling!                             â”‚
â”‚                                                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â”‚
â—‡  App Created [U+1F430]
â”‚
â—‡  Installed bun dependencies [U+1F4CB]
â”‚
â—‹  Result â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
â”‚                                                      â”‚
â”‚  Success!  Project created in my-app directory       â”‚
â”‚                                                      â”‚
â”‚  Integrations? Add Netlify, Cloudflare, Tailwind...  â”‚
â”‚  bun qwik add                                        â”‚
â”‚                                                      â”‚
â”‚  Relevant docs:
â”‚  https://qwik.builder.io/docs/getting-started/
â”‚                                                      â”‚
â”‚  Questions? Start the conversation at:
â”‚  https://qwik.builder.io/chat
â”‚  https://twitter.com/QwikDev
â”‚                                                      â”‚
â”‚  Presentations, Podcasts and Videos:
â”‚  https://qwik.builder.io/media/
â”‚                                                      â”‚
â”‚  Next steps:
â”‚  cd my-app
â”‚  bun start
â”‚                                                      â”‚
â”‚                                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯
â”‚
â””  Happy coding! [U+1F389]

```

---

title: Defining Dockerfile for Bun App
description: Defines a `Dockerfile` that sets up a container for a Bun application. It specifies the base image, working directory, installs dependencies using `bun install`, copies project files, runs tests, and defines the entry point for the application.
source: docs/guides/ecosystem/docker.md#_snippet_0

language: docker
code:
```
# use the official Bun image
# see all versions at https://hub.docker.com/r/oven/bun/tags
FROM oven/bun:1 AS base
WORKDIR /usr/src/app

# install dependencies into temp directory
# this will cache them and speed up future builds
FROM base AS install
RUN mkdir -p /temp/dev
COPY package.json bun.lock /temp/dev/
RUN cd /temp/dev && bun install --frozen-lockfile

# install with --production (exclude devDependencies)
RUN mkdir -p /temp/prod
COPY package.json bun.lock /temp/prod/
RUN cd /temp/prod && bun install --frozen-lockfile --production

# copy node_modules from temp directory
# then copy all (non-ignored) project files into the image
FROM base AS prerelease
COPY --from=install /temp/dev/node_modules node_modules
COPY . .

# [optional] tests & build
ENV NODE_ENV=production
RUN bun test
RUN bun run build

# copy production dependencies and source code into final image
FROM base AS release
COPY --from=install /temp/prod/node_modules node_modules
COPY --from=prerelease /usr/src/app/index.ts .
COPY --from=prerelease /usr/src/app/package.json .

# run the app
USER bun
EXPOSE 3000/tcp
ENTRYPOINT [ "bun", "run", "index.ts" ]
```

---

title: Installing Drizzle ORM with Bun
description: Demonstrates how to initialize a new Bun project and add the `drizzle-orm` and `drizzle-kit` packages using the `bun add` command. This sets up the environment for using Drizzle as an ORM in a Bun project.
source: docs/guides/ecosystem/drizzle.md#_snippet_0

language: sh
code:
```
$ bun init -y
$ bun add drizzle-orm
$ bun add -D drizzle-kit
```

---

title: Unlinking a Local Package Using Bun
description: Demonstrates how to unregister a local package using the `bun unlink` command. This command is used in the root directory of the package to remove the symbolic link, effectively unregistering it from the global scope. This prevents conflicts and ensures that the package is no longer accessible as a global dependency.
source: docs/cli/unlink.md#_snippet_0

language: bash
code:
```
$ cd /path/to/cool-pkg
$ bun unlink
bun unlink v1.x (7416672e)
```

---

title: Creating Systemd Service File
description: Demonstrates how to create a service file for managing a Bun application as a daemon using `systemd`. Creating a `.service` file in the `/lib/systemd/system/` directory is the first step to manage your app.
source: docs/guides/ecosystem/systemd.md#_snippet_0

language: sh
code:
```
$ cd /lib/systemd/system
$ touch my-app.service
```

---

title: Initializing a React Project with Tailwind CSS
description: Demonstrates the use of the `--react=tailwind` flag with `bun init` to scaffold a React project pre-configured with Tailwind CSS. This sets up the project with Bun's bundler and development server, simplifying the integration of Tailwind CSS into a React application.
source: docs/cli/init.md#_snippet_1

language: bash
code:
```
$ bun init --react=tailwind
```

---

title: Initializing a React Project with Shadcn/UI
description: Illustrates how to use the `--react=shadcn` flag with `bun init` to create a React project configured with shadcn/ui and Tailwind CSS. This command bootstraps a project with a modern UI stack, leveraging Bun's bundler and dev server for an optimized development experience.
source: docs/cli/init.md#_snippet_2

language: bash
code:
```
$ bun init --react=shadcn
```

---

title: Upgrading Bun Using Curl
description: Demonstrates how to upgrade Bun using the `curl` command. This method downloads and executes the installation script, ensuring the latest version of Bun is installed or updated.
source: docs/cli/bun-upgrade.md#_snippet_0

language: bash
code:
```
$ curl https://bun.com/install | bash
```

---

title: Installing EdgeDB - Shell
description: Demonstrates how to install EdgeDB using shell scripts. The first snippet uses `curl` for Linux/macOS, while the second uses `iwr` (Invoke-WebRequest) for Windows. These commands download and execute the EdgeDB installation script.
source: docs/guides/ecosystem/edgedb.md#_snippet_0

language: sh
code:
```
$ curl --proto '=https' --tlsv1.2 -sSf https://sh.edgedb.com | sh
```

language: sh
code:
```
$ iwr https://ps1.edgedb.com -useb | iex
```

---

title: Registering a Local Package with Bun Link
description: Demonstrates how to register a local package using `bun link`. This allows the package to be linked into other projects, enabling local development and testing without publishing to a registry.
source: docs/cli/link.md#_snippet_0

language: bash
code:
```
$ cd /path/to/cool-pkg
$ cat package.json
{
  "name": "cool-pkg",
  "version": "1.0.0"
}
$ bun link
bun link v1.x (7416672e)
Success! Registered "cool-pkg"

To use cool-pkg in a project, run:
  bun link cool-pkg

Or add it in dependencies in your package.json file:
  "cool-pkg": "link:cool-pkg"
```

---

title: Installing Drizzle and Neon Serverless
description: Demonstrates installing the `drizzle-orm` and `@neondatabase/serverless` packages, which are necessary for connecting to a Neon Postgres database using Drizzle ORM.
source: docs/guides/ecosystem/neon-drizzle.md#_snippet_0

language: sh
code:
```
$ mkdir bun-drizzle-neon
$ cd bun-drizzle-neon
$ bun init -y
$ bun add drizzle-orm @neondatabase/serverless
$ bun add -D drizzle-kit
```

---

title: Defining Preinstall and Postinstall Tasks
description: Illustrates how to define `preinstall` and `postinstall` tasks within the `package.json` file, which will be executed before and after installing dependencies, respectively. This feature allows for custom setup and cleanup operations during the `bun create` process.
source: docs/cli/bun-create.md#_snippet_0

language: json
code:
```
{
  "postinstall": "...",
  "preinstall": "..."
}
```

---

title: Using JUnit Reporter
description: Demonstrates how to generate a JUnit XML report using the `--reporter=junit` flag and specify the output file with `--reporter-outfile`. This allows integration with CI/CD systems like GitLab and Jenkins.
source: docs/test/reporters.md#_snippet_0

language: sh
code:
```
$ bun test --reporter=junit --reporter-outfile=./junit.xml
```

---

title: Installing Happy DOM
description: Demonstrates how to install the `@happy-dom/global-registrator` package as a dev dependency using `bun add`. This package is essential for simulating a browser environment when writing headless tests for frontend code.
source: docs/test/dom.md#_snippet_0

language: bash
code:
```
$ bun add -d @happy-dom/global-registrator
```

---

title: Registering Happy DOM Globals with Bun Preload
description: Illustrates how to register `happy-dom` globals before running tests using Bun's preload functionality.  The `GlobalRegistrator.register()` call makes browser APIs like `document` available in the global scope, and the `bunfig.toml` file configures Bun to preload the `happydom.ts` file.
source: docs/test/dom.md#_snippet_1

language: ts
code:
```
import { GlobalRegistrator } from "@happy-dom/global-registrator";

GlobalRegistrator.register();
```

language: toml
code:
```
[test]
preload = "./happydom.ts"
```

---

title: Preloading Plugins Using Bunfig Toml
description: Illustrates how to preload a plugin using the `preload` option in `bunfig.toml`.  This ensures the plugin is loaded before any other code runs, which is crucial for intercepting imports and customizing loading behavior. The example shows preloading both local files and npm packages.
source: docs/runtime/plugins.md#_snippet_1

language: toml
code:
```
preload = ["./myPlugin.ts"]
```

language: toml
code:
```
preload = ["bun-plugin-foo"]
```

language: toml
code:
```
[test]
preload = ["./myPlugin.ts"]
```

---

title: Initializing Nextjs-Style FileSystemRouter
description: Demonstrates how to initialize a `FileSystemRouter` with the `nextjs` style, specifying the directory, origin, and asset prefix. This configures the router to resolve routes against the provided directory, simulating a Next.js environment.
source: docs/api/file-system-router.md#_snippet_0

language: ts
code:
```
const router = new Bun.FileSystemRouter({
  style: "nextjs",
  dir: "./pages",
  origin: "https://mydomain.com",
  assetPrefix: "_next/static/"
});
router.match("/");

// =>
{
  filePath: "/path/to/pages/index.tsx",
  kind: "exact",
  name: "/",
  pathname: "/",
  src: "https://mydomain.com/_next/static/pages/index.tsx"
}
```

---

title: Initializing The Transpiler - TypeScript
description: Illustrates how to create a new instance of `Bun.Transpiler`. The `loader` option specifies the language to be transpiled, accepting values like `js`, `jsx`, `ts`, or `tsx`.
source: docs/api/transpiler.md#_snippet_0

language: typescript
code:
```
const transpiler = new Bun.Transpiler({
  loader: "tsx", // "js | "jsx" | "ts" | "tsx"
});
```

---

title: Starting a TCP Server with Bun Listen
description: Demonstrates how to start a TCP server using `Bun.listen` with specified hostname, port, and socket event handlers. This approach allows for defining handlers once per server, optimizing performance by reducing garbage collector pressure and memory usage compared to assigning callbacks to each socket.
source: docs/api/tcp.md#_snippet_0

language: typescript
code:
```
Bun.listen({
  hostname: "localhost",
  port: 8080,
  socket: {
    data(socket, data) {}, // message received from client
    open(socket) {}, // socket opened
    close(socket, error) {}, // socket closed
    drain(socket) {}, // socket ready for more data
    error(socket, error) {}, // error handler
  },
});
```

---

title: Opening a SQLite3 Database
description: Illustrates how to open or create a SQLite3 database file using the `Database` constructor. This provides a persistent storage option. The example shows creating a database file named `mydb.sqlite`.
source: docs/api/sqlite.md#_snippet_1

language: ts
code:
```
import { Database } from "bun:sqlite";

const db = new Database("mydb.sqlite");
```

---

title: Initializing a New Elysia Project
description: Illustrates how to quickly scaffold a new Elysia project using the `bun create` command. This involves running `bun create elysia ./myapp` to generate a new Elysia project, navigating to the project directory using `cd myapp`, and starting the development server with `bun run dev`.
source: docs/ecosystem/elysia.md#_snippet_1

language: bash
code:
```
$ bun create elysia ./myapp
$ cd myapp
$ bun run dev
```

---

title: Defining Version Catalogs in Root Package-JSON
description: Demonstrates how to define version catalogs within the `workspaces` object of the root `package.json` file in a Bun monorepo. The `catalog` field defines default dependency versions, while `catalogs` allows grouping dependencies under named catalogs, enabling consistent version management across workspace packages.
source: docs/install/catalogs.md#_snippet_0

language: json
code:
```
{
  "name": "my-monorepo",
  "workspaces": {
    "packages": ["packages/*"],
    "catalog": {
      "react": "^19.0.0",
      "react-dom": "^19.0.0"
    },
    "catalogs": {
      "testing": {
        "jest": "30.0.0",
        "testing-library": "14.0.0"
      }
    }
  }
}
```

---

title: Creating Native Plugin with Napi-rs Cli
description: Demonstrates how to create a native plugin using the `@napi-rs/cli` tool. This allows developers to scaffold a new NAPI project quickly for building native plugins.
source: docs/bundler/plugins.md#_snippet_0

language: bash
code:
```
bun add -g @napi-rs/cli
napi new
```

---

title: Installing Dependencies with Bun
description: Demonstrates the basic usage of `bun install` to install all dependencies defined in a project's `package.json` file.  This command installs `dependencies`, `devDependencies`, and `optionalDependencies`, runs lifecycle scripts, and writes a `bun.lock` lockfile.
source: docs/install/index.md#_snippet_0

language: bash
code:
```
$ bun install
```

---

title: Building Locally with ASAN
description: Illustrates different `cmake` configurations for building Bun with ASAN (Address Sanitizer). The first example creates a debug build, the second creates a release build, and the third creates a release build with assertions enabled, all with ASAN enabled for memory error detection.
source: docs/project/asan.md#_snippet_0

language: bash
code:
```
# Debug build with ASAN
cmake -B build -DCMAKE_BUILD_TYPE=Debug -DENABLE_ASAN=ON

# Release build with ASAN
cmake -B build -DCMAKE_BUILD_TYPE=Release -DENABLE_ASAN=ON

# Release build with ASAN and assertions
cmake -B build -DCMAKE_BUILD_TYPE=Release -DENABLE_ASAN=ON -DENABLE_ASSERTIONS=ON
```

---

title: Installing Typescript Definitions for Bun
description: Illustrates how to install the `@types/bun` npm package, which provides TypeScript definitions for Bun's JavaScript runtime APIs. This allows VS Code and TypeScript to automatically load the necessary types, making the `Bun` global and `bun:*` modules available.
source: packages/bun-types/README.md#_snippet_0

language: bash
code:
```
# yarn/npm/pnpm work too
# @types/bun is an ordinary npm package
bun add -D @types/bun
```

---

title: Building a Standalone Executable with Bun
description: Demonstrates how to use the `bun build` command with the `--compile` flag to create a standalone executable from a TypeScript file. The executable bundles all dependencies and the Bun runtime, allowing for direct execution without external dependencies.
source: docs/bundler/executables.md#_snippet_0

language: bash
code:
```
$ bun build ./cli.ts --compile --outfile mycli
```

language: typescript
code:
```
console.log("Hello world!");
```

---

title: Building Native Addon
description: Shows how to build the `mdxjs-rs` native addon using `cargo`. This addon is required for the `Bun.build()` process to convert MDX to JSX.
source: packages/bun-build-mdx-rs/README.md#_snippet_0

language: sh
code:
```
cargo build --release
```

---

title: Running All Dependencies - Bash
description: Executes the `all-dependencies.sh` script to handle dependencies. This script likely performs tasks such as downloading, building, and caching project dependencies, optimizing build times by reusing cached dependencies across builds.
source: docs/project/internals/build-process-for-ci.md#_snippet_0

language: sh
code:
```
BUN_DEPS_OUT_DIR="/optional/out/dir" bash ./scripts/all-dependencies.sh
```

---

title: Embedding Git Commit Hash in Output
description: Shows the integration of a `getGitCommitHash` macro that retrieves the current Git commit hash during the build process. The `getGitCommitHash()` function is replaced with the actual commit hash in the bundled output.
source: docs/bundler/macros.md#_snippet_6

language: typescript
code:
```
import { getGitCommitHash } from './getGitCommitHash.ts' with { type: 'macro' };

console.log(`The current Git commit hash is ${getGitCommitHash()}`);
```

language: bash
code:
```
console.log(`The current Git commit hash is 3ee3259104f`);
```

---

title: Setting Up Bun Lambda Layer
description: Demonstrates how to set up the Bun Lambda layer by cloning the repository, installing dependencies, and running the `publish-layer` script. This script builds and deploys the layer to your AWS account, preparing it for use in Lambda functions.
source: packages/bun-lambda/README.md#_snippet_0

language: sh
code:
```
git clone --filter=blob:none --sparse https://github.com/oven-sh/bun.git
git -C bun sparse-checkout set packages/bun-lambda
cd bun/packages/bun-lambda
bun install
bun run publish-layer
```

---

title: Installing Bun
description: Demonstrates how to install the `bun` runtime globally using `npm`. This allows you to execute `bun` commands from any terminal.
source: packages/bun-release/npm/bun/README.md#_snippet_0

language: sh
code:
```
npm install -g bun
```

---

title: Installing Bun Plugin Svelte
description: Shows how to install `bun-plugin-svelte` as a development dependency using the `bun add` command. This allows Svelte components to be used within a Bun project.
source: packages/bun-plugin-svelte/README.md#_snippet_0

language: shell
code:
```
$ bun add -D bun-plugin-svelte
```

---

title: Running Hot Reload Stress Test - Bash
description: Executes the `run-stress-test.sh` script. This script generates interconnected modules, runs the stress test, and reports performance statistics for hot reloading.
source: bench/stress/hot-reload-files/README.md#_snippet_0

language: bash
code:
```
./run-stress-test.sh
```

---

title: Running Bundler Benchmark
description: Demonstrates how to execute the `run-bench.sh` script after assigning it execute permissions. This script benchmarks the performance of various JavaScript bundlers.
source: bench/bundle/README.md#_snippet_0

language: sh
code:
```
$ chmod +x run-bench.sh
$ ./run-bench.sh
```

---

title: Installing Bun - PowerShell
description: Illustrates how to install Bun using the provided PowerShell command. This command downloads and executes the installation script from bun.com, which is a prerequisite for the build process.
source: docs/project/building-windows.md#_snippet_1

language: ps1
code:
```
> irm bun.com/install.ps1 | iex
```

---

title: Installing the Yaml Plugin
description: Demonstrates how to install the `bun-plugin-yaml` package as a development dependency using the `bun add` command. This allows your project to handle `.yml` and `.yaml` files.
source: packages/bun-plugin-yaml/README.md#_snippet_0

language: sh
code:
```
bun add bun-plugin-yaml -d
```

---

title: Installing Dependencies
description: Demonstrates the command to install project dependencies using `bun install`. This ensures that all necessary packages are available before running tests or other project tasks.
source: bench/expect-to-equal/README.md#_snippet_0

language: bash
code:
```
bun install
```

---

title: Benchmarking Install with Lockfile - Shell
description: Demonstrates how to benchmark package manager installation speed using `hyperfine` in online mode with a lockfile. It removes the `node_modules` directory, warms up the cache, and runs `bun install`, `pnpm install`, `yarn`, and `npm install` to compare their performance.
source: bench/install/README.md#_snippet_0

language: sh
code:
```
$ hyperfine --prepare 'rm -rf node_modules' --warmup 1 --runs 3 'bun install' 'pnpm install' 'yarn' 'npm install'
```

---

title: Benchmarking Install in Offline Mode - Shell
description: Illustrates benchmarking package manager installation speed using `hyperfine` in offline mode with a lockfile. It removes the `node_modules` directory and runs `bun install`, `pnpm install --prefer-offline`, `yarn --offline`, and `npm install --prefer-offline` to compare install times without network calls.
source: bench/install/README.md#_snippet_1

language: sh
code:
```
$ hyperfine --prepare 'rm -rf node_modules' --runs 1 'bun install' 'pnpm install --prefer-offline' 'yarn --offline' 'npm install --prefer-offline'
```

---

title: Benchmarking Install without Lockfile - Shell
description: Shows how to benchmark package manager installation speed using `hyperfine` in offline mode without a lockfile.  It removes the `node_modules` directory and lockfiles before running `bun install`, `pnpm install --prefer-offline`, `yarn --offline`, and `npm install --prefer-offline` to compare the performance.
source: bench/install/README.md#_snippet_2

language: sh
code:
```
$ hyperfine --prepare 'rm -rf node_modules' --warmup 1 'rm bun.lock && bun install' 'rm pnpm-lock.yaml && pnpm install --prefer-offline' 'rm yarn.lock && yarn --offline' 'rm package-lock.json && npm install --prefer-offline'
```

---

title: Installing Dependencies
description: Demonstrates how to install the necessary dependencies for the project using `bun install`. This command ensures that all required packages are installed before running the benchmark.
source: bench/express/README.md#_snippet_0

language: bash
code:
```
bun install
```

---

title: Initializing a Napi-rs Project
description: Demonstrates how to create a new [napi-rs](https://github.com/napi-rs/napi-rs) project and add the `bun-native-plugin` crate, providing the basic setup for developing Bun native plugins.
source: packages/bun-native-plugin-rs/README.md#_snippet_0

language: bash
code:
```
bun add -g @napi-rs/cli
napi new
```

language: bash
code:
```
cargo add bun-native-plugin
```

---

title: Installing Bun Inspector Protocol
description: Demonstrates how to install the `bun-inspector-protocol` package using `bun`, `npm`, `yarn`, or `pnpm`. It shows the command to add the package to your project's dependencies.
source: packages/bun-inspector-protocol/README.md#_snippet_0

language: bash
code:
```
bun add bun-inspector-protocol
# npm install bun-inspector-protocol
# yarn add bun-inspector-protocol
# pnpm add bun-inspector-protocol
```

---

title: Scaffolding a React App with Vite and Bun
description: Demonstrates how to scaffold a new React application using Vite, leveraging Bun for package management. This command initializes a project with a basic React setup and TypeScript using SWC for faster compilation.
source: docs/guides/ecosystem/vite.md#_snippet_0

language: bash
code:
```
$ bun create vite my-app
âœ” Select a framework: â€º React
âœ” Select a variant: â€º TypeScript + SWC
Scaffolding project in /path/to/my-app...
```

---

title: Setting Custom SQLite Path - TypeScript
description: Illustrates how to configure `bun:sqlite` to use a custom SQLite build. It calls `Database.setCustomSQLite()` with the path to the SQLite `.dylib` before creating any `Database` instances, ensuring the new build is used. This is important when you need a specific version or build of SQLite.
source: docs/api/sqlite.md#_snippet_0

language: typescript
code:
```
import { Database } from "bun:sqlite";

Database.setCustomSQLite("/path/to/libsqlite.dylib");

const db = new Database();
db.loadExtension("myext");
```

---

title: Preparing for Patching with Bun
description: Demonstrates how to prepare a package for patching using the `bun patch` command. This command ensures that the package folder in `node_modules/` contains a fresh copy of the package without symlinks or hardlinks to Bun's cache, preventing unintended modifications to the global cache.
source: docs/install/patch.md#_snippet_0

language: bash
code:
```
# you can supply the package name
$ bun patch react

# ...and a precise version in case multiple versions are installed
$ bun patch react@17.0.2

# or the path to the package
$ bun patch node_modules/react
```

---

title: Running the Development Server - Bash
description: Demonstrates how to start the Next.js development server using `npm`, `yarn`, `pnpm`, or `bun`. This command initiates the local development environment, allowing you to preview and test your Next.js application at `http://localhost:3000`.
source: test/integration/next-pages/README.md#_snippet_0

language: bash
code:
```
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

---

title: Defining Stream Tagging - Zig
description: Defines the `Tag` enum in Zig, which is used to identify the type of a `ReadableStream` in Bun. This tagging system enables various optimizations by allowing the runtime to dispatch to the most efficient implementation based on the stream's origin.
source: src/bun.js/STREAMS.md#_snippet_0

language: zig
code:
```
// src/bun.js/webcore/ReadableStream.zig
pub const Tag = enum(i32) {
    JavaScript = 0, // A generic, user-defined stream. This is the "slow path".
    Blob = 1,       // An in-memory blob. Fast path available.
    File = 2,       // Backed by a native file reader. Fast path available.
    Bytes = 4,      // Backed by a native network byte stream. Fast path available.
    Direct = 3,     // Internal native-to-native stream.
    Invalid = -1,
};
```

---

title: Extracting Public Key from RSA
description: Illustrates how to extract the public key in DER format from an existing RSA private key using `openssl`.  This step prepares the public key for inclusion in a certificate.
source: test/js/node/test/fixtures/0-dns/README.md#_snippet_1

language: console
code:
```
$ openssl rsa -in 0-dns-key.pem -RSAPublicKey_out -outform der -out 0-dns-rsapub.der
writing RSA key
```

---

title: Running Tests in Watch Mode - Bun
description: Demonstrates how to run tests in watch mode using the `--watch` flag with the `bun test` command. This will automatically restart the Bun process whenever a file change is detected, enabling fast feedback during development.
source: docs/guides/test/watch-mode.md#_snippet_0

language: sh
code:
```
$ bun test --watch
```

---

title: Setting a Per-Test Timeout with Bun Test
description: Demonstrates how to set a timeout for each test using the `--timeout` flag in the Bun test runner. This flag specifies the timeout in milliseconds, and any test exceeding this timeout will be marked as failed. The default timeout is 5000 milliseconds (5 seconds).
source: docs/guides/test/timeout.md#_snippet_0

language: shell
code:
```
$ bun test --timeout 3000 # 3 seconds
```

---

title: Skipping SEA Tests if Not Supported
description: Explains how to use `skipIfSingleExecutableIsNotSupported()` to skip tests when single executable applications (SEA) are not supported in the current configuration. This ensures that SEA-related tests are only run in environments where SEA functionality is available.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_5

language: javascript
code:
```
### `skipIfSingleExecutableIsNotSupported()`

Skip the rest of the tests if single executable applications are not supported
in the current configuration.
```

---

title: Marking a Test as Todo - Typescript
description: Demonstrates how to mark a test as `todo` using the Bun test runner. This indicates that the test is unimplemented and will be skipped during normal test runs.
source: docs/guides/test/todo-tests.md#_snippet_0

language: typescript
code:
```
import { test, expect } from "bun:test";

// write this later
test.todo("unimplemented feature");
```

---

title: Showing Todo Tests in Output - Shell
description: Illustrates the output of `bun test` when a test is marked as `todo`. The output indicates the number of todo tests encountered.
source: docs/guides/test/todo-tests.md#_snippet_1

language: shell
code:
```
$ bun test

test.test.ts:
âœ“ add [0.03ms]
âœ“ multiply [0.02ms]
âœŽ unimplemented feature

 2 pass
 1 todo
 0 fail
 2 expect() calls
Ran 3 tests across 1 files. [74.00ms]
```

---

title: Registering Happy DOM Globally - TypeScript
description: Demonstrates how to register Happy DOM's mocked browser APIs to the global scope using the `GlobalRegistrator`. This is achieved by importing `GlobalRegistrator` from `@happy-dom/global-registrator` and calling its `register()` method, making the APIs available for testing.
source: docs/guides/test/happy-dom.md#_snippet_1

language: ts
code:
```
import { GlobalRegistrator } from "@happy-dom/global-registrator";

GlobalRegistrator.register();
```

---

title: Preloading Happy DOM - TOML
description: Illustrates how to configure Bun to preload the Happy DOM registration file (`./happydom.ts`) before running tests.  This is done by modifying the `bunfig.toml` file to include a `test.preload` entry, ensuring that the mocked browser APIs are available during testing.
source: docs/guides/test/happy-dom.md#_snippet_2

language: toml
code:
```
[test]
preload = "./happydom.ts"
```

---

title: Running Code Coverage with Bun
description: Demonstrates how to execute the Bun test runner with the `--coverage` flag to generate code coverage reports. The output shows coverage statistics for each file, including the percentage of functions and lines covered, along with uncovered line numbers. This is useful for identifying areas of the codebase that lack sufficient test coverage.
source: docs/guides/test/coverage-threshold.md#_snippet_0

language: sh
code:
```
$ bun test --coverage

test.test.ts:
âœ“ math > add [0.71ms]
âœ“ math > multiply [0.03ms]
âœ“ random [0.13ms]
-------------|---------|---------|-------------------
File         | % Funcs | % Lines | Uncovered Line #s
-------------|---------|---------|-------------------
All files    |   66.67 |   77.78 |
 math.ts     |   50.00 |   66.67 |
 random.ts   |   50.00 |   66.67 |
-------------|---------|---------|-------------------

 3 pass
 0 fail
 3 expect() calls
```

---

title: Running Tests with Bun Test Runner
description: Demonstrates how to execute tests using the `bun test` command, which automatically discovers and runs tests in files matching specific naming patterns. This command provides a quick way to validate code functionality and ensures that tests are executed consistently within the Bun environment.
source: docs/guides/test/run-tests.md#_snippet_0

language: txt
code:
```
*.test.{js|jsx|ts|tsx}
*_test.{js|jsx|ts|tsx}
*.spec.{js|jsx|ts|tsx}
*_spec.{js|jsx|ts|tsx}
```

---

title: Installing Bun Using NPM
description: Illustrates installing Bun globally using `npm`. This approach offers a familiar installation method for JavaScript developers already using `npm`.
source: docs/installation.md#_snippet_1

language: bash
code:
```
$ npm install -g bun # the last `npm` command you'll ever need
```

---

title: Installing Bun with Homebrew (macOS/Linux)
description: Demonstrates installing Bun using Homebrew on macOS and Linux.  Homebrew is a popular package manager, making this a convenient option for users already using it.
source: docs/installation.md#_snippet_2

language: bash
code:
```
$ brew install oven-sh/bun/bun # for macOS and Linux
```

---

title: Installing Bun with Docker
description: Illustrates pulling and running the Bun Docker image. This method is useful for isolating Bun in a containerized environment.
source: docs/installation.md#_snippet_3

language: bash
code:
```
$ docker pull oven/bun
$ docker run --rm --init --ulimit memlock=-1:-1 oven/bun
```

---

title: Installing Bun via Powershell (Windows)
description: Demonstrates installing Bun using PowerShell on Windows. It provides a direct installation method using a script from the Bun website.
source: docs/installation.md#_snippet_4

language: powershell
code:
```
> powershell -c "irm bun.sh/install.ps1|iex"
```

---

title: Installing Bun using Scoop (Windows)
description: Illustrates how to install Bun on Windows using the Scoop package manager. This is a convenient option for those already using Scoop.
source: docs/installation.md#_snippet_5

language: powershell
code:
```
> scoop install bun
```

---

title: Setting Up Happy DOM Preload Script
description: Defines a preload script for Happy DOM that registers the environment.  This script utilizes the `GlobalRegistrator` from the `@happy-dom/global-registrator` package to set up the DOM environment before running tests.
source: docs/guides/test/testing-library.md#_snippet_2

language: typescript
code:
```
import { GlobalRegistrator } from '@happy-dom/global-registrator';

GlobalRegistrator.register();
```

---

title: Extending Bun Expect with Testing Library Matchers
description: Illustrates how to extend Bun's `expect` function with Testing Library's matchers and set up cleanup after each test. It imports necessary modules from `bun:test`, `@testing-library/react`, and `@testing-library/jest-dom` to enhance the testing environment.
source: docs/guides/test/testing-library.md#_snippet_3

language: typescript
code:
```
import { afterEach, expect } from 'bun:test';
import { cleanup } from '@testing-library/react';
import * as matchers from '@testing-library/jest-dom/matchers';

expect.extend(matchers);

// Optional: cleans up `render` after each test
afterEach(() => {
  cleanup();
});
```

---

title: Serving HTTP with Hot Reloading
description: Illustrates how Bun's hot reloading feature works with `Bun.serve()` to update HTTP server fetch handlers on source file changes without restarting the Bun process. This provides near-instantaneous updates to the server's behavior during development.
source: docs/guides/http/hot.md#_snippet_1

language: typescript
code:
```
Bun.serve({
  port: 3000,
  fetch(req) {
    return new Response("Hello world");
  },
});
```

---

title: Spawning a Child Process with IPC - TypeScript
description: Demonstrates how to spawn a child process using `Bun.spawn()` and establish an inter-process communication (IPC) channel between the parent and child processes. The `ipc` option in `Bun.spawn()` configures a callback function that handles messages received from the child process.
source: docs/guides/process/ipc.md#_snippet_0

language: typescript
code:
```
const child = Bun.spawn(["bun", "child.ts"], {
  ipc(message) {
    /**
     * The message received from the sub process
     **/
  },
});
```

---

title: Serving HTTP Requests with Reuseport - TS
description: Demonstrates using `Bun.serve()` with the `reusePort` option to allow multiple Bun server processes to listen on the same port. This automatically load balances incoming requests across the different Bun instances. Useful for maximizing throughput and utilizing multiple CPU cores.
source: docs/guides/http/cluster.md#_snippet_0

language: typescript
code:
```
import { serve } from "bun";

const id = Math.random().toString(36).slice(2);

serve({
  port: process.env.PORT || 8080,
  development: false,

  // Share the same port across multiple processes
  // This is the important part!
  reusePort: true,

  async fetch(request) {
    return new Response("Hello from Bun #" + id + "!\n");
  }
});
```

---

title: Running Svelte Tests with Bun
description: Demonstrates how to execute the tests using the `bun test` command. This command runs all test files in the project, including the Svelte component tests.
source: docs/guides/test/svelte-test.md#_snippet_5

language: bash
code:
```
$ bun test
```

---

title: Serving a Webpage with Debugging Enabled
description: Demonstrates how to create a basic web server using Bun and enable debugging with the `--inspect` flag. The server listens for HTTP requests and returns a 'Hello, world!' response. Debugging is enabled to inspect the running process.
source: docs/guides/runtime/web-debugger.md#_snippet_0

language: typescript
code:
```
Bun.serve({
  fetch(req){
    console.log(req.url);
    return new Response("Hello, world!");
  }
})
```

---

title: Setting Time Zone Using Environment Variable
description: Illustrates setting the `TZ` environment variable to `America/New_York` to programmatically set the default time zone for the Bun process. This affects how `Date` instances are interpreted.
source: docs/guides/runtime/timezone.md#_snippet_0

language: typescript
code:
```
process.env.TZ = "America/New_York";
```

---

title: Setting Time Zone From Command Line
description: Demonstrates how to set the `TZ` environment variable when running a Bun command from the command line. This method allows setting the time zone without modifying the code.
source: docs/guides/runtime/timezone.md#_snippet_1

language: shell
code:
```
$ TZ=America/New_York bun run dev
```

---

title: Compiling JavaScript to an Executable - Bun
description: Compiles a TypeScript entry point into a standalone executable using the `bun build` command. The `--compile` flag is essential for creating a single-file executable.
source: docs/guides/runtime/codesign-macos-executable.md#_snippet_0

language: sh
code:
```
$ bun build --compile ./path/to/entry.ts --outfile myapp
```

---

title: Adding Tarball Dependency with Bun
description: Demonstrates how to add a tarball dependency to a Bun project using the `bun add` command. This downloads, extracts, and installs the tarball to the project's `node_modules` directory and updates the `package.json` file.
source: docs/guides/install/add-tarball.md#_snippet_0

language: sh
code:
```
$ bun add zod@https://registry.npmjs.org/zod/-/zod-3.21.4.tgz
```

---

title: Setting Per-Socket Contextual Data - TypeScript
description: Demonstrates how to set per-socket contextual data using `Bun.serve()` when upgrading a WebSocket connection. The `server.upgrade()` call includes a `data` parameter that is accessible as the `data` property on the WebSocket instance within the `message` handler. This allows associating identifying information, such as a `socketId`, with each connected client.
source: docs/guides/websocket/context.md#_snippet_0

language: typescript
code:
```
Bun.serve<{ socketId: number }>({
  fetch(req, server) {
    const success = server.upgrade(req, {
      data: {
        socketId: Math.random(),
      },
    });
    if (success) return undefined;

    // handle HTTP request normally
    // ...
  },
  websocket: {
    // define websocket handlers
    async message(ws, message) {
      // the contextual data is available as the `data` property
      // on the WebSocket instance
      console.log(`Received ${message} from ${ws.data.socketId}}`);
    },
  },
});
```

---

title: Adding an Optional Dependency with Bun
description: Demonstrates how to add an npm package as an optional dependency using the `--optional` flag with the `bun add` command. This ensures that the package is added to the `optionalDependencies` section in the `package.json` file, allowing the project to function even if the dependency installation fails.
source: docs/guides/install/add-optional.md#_snippet_0

language: shell
code:
```
$ bun add zod --optional
```

---

title: Adding a GitHub Repository as Dependency
description: Demonstrates how to add a GitHub repository as a dependency using the `bun add` command. This command directly integrates the specified repository into your project's dependencies.
source: docs/guides/install/add-git.md#_snippet_0

language: shell
code:
```
$ bun add github:lodash/lodash
```

---

title: Installing Package with an Alias - Shell
description: Demonstrates how to install an npm package under a custom name using the Bun package manager. The command `bun add my-custom-name@npm:zod` installs the `zod` package, aliasing it as `my-custom-name`.
source: docs/guides/install/npm-alias.md#_snippet_0

language: shell
code:
```
$ bun add my-custom-name@npm:zod
```

---

title: Configuring Workspaces (package.json)
description: Defines the structure of a monorepo's root `package.json` file. It specifies that the repository is private and declares the `packages/*` directory as containing individual workspaces. Declaring `private: true` avoids accidental publishing to `npm`.
source: docs/guides/install/workspaces.md#_snippet_0

language: json
code:
```
{
  "name": "my-monorepo",
  "private": true,
  "workspaces": [
    "packages/*"
  ]
}
```

---

title: Installing Dependencies for SolidStart
description: Illustrates how to install the dependencies for a SolidStart project using `bun install`.  This command fetches and installs all the necessary packages specified in the project's `package.json` file, preparing the project for development.
source: docs/guides/ecosystem/solidstart.md#_snippet_1

language: sh
code:
```
$ cd my-app
$ bun install
```

---

title: Installing Prisma CLI and Client -Bash
description: Illustrates how to add the Prisma CLI (`prisma`) and Prisma Client (`@prisma/client`) as dependencies to a Bun project.  Using `bun add -d prisma` installs the Prisma CLI as a development dependency, while `bun add @prisma/client` installs the Prisma Client as a regular dependency. These are essential for interacting with Prisma.
source: docs/guides/ecosystem/prisma.md#_snippet_1

language: bash
code:
```
$ bun add -d prisma
$ bun add @prisma/client
```

---

title: Importing Prisma Client -Typescript
description: Demonstrates how to import the generated Prisma client from the `@prisma/client` package in a TypeScript file.  This import statement makes the Prisma client available for use in the application, providing access to the auto-generated methods for interacting with the database.
source: docs/guides/ecosystem/prisma.md#_snippet_6

language: ts
code:
```
import {PrismaClient} from "@prisma/client";
```

---

title: Adding Discord Bot Token to Environment File
description: Demonstrates how to store a Discord bot's private key in a `.env.local` file. This allows Bun to read the token from `process.env` for authentication.
source: docs/guides/ecosystem/discordjs.md#_snippet_1

language: txt
code:
```
DISCORD_TOKEN=YOUR_DISCORD_BOT_TOKEN_HERE
```

---

title: Configuring Systemd Service File (Ini)
description: Illustrates the typical structure of a systemd service file for running an application. This configuration file specifies the user, working directory, execution command, and restart policy, enabling `systemd` to manage the application as a service. The `YOUR_USER` variable should be replaced with the appropriate user.
source: docs/guides/ecosystem/systemd.md#_snippet_1

language: ini
code:
```
[Unit]
# describe the app
Description=My App
# start the app after the network is available
After=network.target

[Service]
# usually you'll use 'simple'
# one of https://www.freedesktop.org/software/systemd/man/systemd.service.html#Type=
Type=simple
# which user to use when starting the app
User=YOUR_USER
# path to your application's root directory
WorkingDirectory=/home/YOUR_USER/path/to/my-app
# the command to start the app
# requires absolute paths
ExecStart=/home/YOUR_USER/.bun/bin/bun run index.ts
# restart policy
# one of {no|on-success|on-failure|on-abnormal|on-watchdog|on-abort|always}
Restart=always

[Install]
# start the app automatically
WantedBy=multi-user.target
```

---

title: Initializing a Basic Bun Project
description: Demonstrates the use of `bun init` to scaffold a basic Bun project with default settings. It creates a `package.json`, `tsconfig.json`, an entry point file (e.g., `index.ts`), and a `README.md` file. Using `bun init` provides a quick start for new projects with sensible defaults.
source: docs/cli/init.md#_snippet_0

language: bash
code:
```
$ bun init
```

---

title: Installing Dependencies Using Filters
description: Demonstrates how to use the `--filter` flag with `bun install` to install dependencies for specific packages in a monorepo. The examples show excluding a package, including packages based on path, and excluding the root package while including others.
source: docs/cli/filter.md#_snippet_0

language: bash
code:
```
# Install dependencies for all workspaces except `pkg-c`
$ bun install --filter '!pkg-c'

# Install dependencies for packages in `./packages` (`pkg-a`, `pkg-b`, `pkg-c`)
$ bun install --filter './packages/*'

# Save as above, but exclude the root package.json
$ bun install --filter '!./' --filter './packages/*'
```

---

title: Initializing a Bun Project - Shell
description: Illustrates the steps to create a new Bun project. The `mkdir` command creates a new directory, `cd` navigates into it, and `bun init -y` initializes a Bun project with default settings.
source: docs/guides/ecosystem/edgedb.md#_snippet_1

language: sh
code:
```
$ mkdir my-edgedb-app
$ cd my-edgedb-app
$ bun init -y
```

---

title: Initializing an EdgeDB Project - Shell
description: Demonstrates how to initialize an EdgeDB project within a Bun application. The `edgedb project init` command creates an `edgedb.toml` file in the project root, configuring the project to use a specific EdgeDB instance and version.
source: docs/guides/ecosystem/edgedb.md#_snippet_2

language: sh
code:
```
$ edgedb project init
No `edgedb.toml` found in `/Users/colinmcd94/Documents/bun/fun/examples/my-edgedb-app` or above
Do you want to initialize a new project? [Y/n]
> Y
Specify the name of EdgeDB instance to use with this project [default: my_edgedb_app]:
> my_edgedb_app
Checking EdgeDB versions...
Specify the version of EdgeDB to use with this project [default: x.y]:
> x.y
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Project directory   â”‚ /Users/colinmcd94/Documents/bun/fun/examples/my-edgedb-app             â”‚
â”‚ Project config      â”‚ /Users/colinmcd94/Documents/bun/fun/examples/my-edgedb-app/edgedb.toml â”‚
â”‚ Schema dir (empty)  â”‚ /Users/colinmcd94/Documents/bun/fun/examples/my-edgedb-app/dbschema    â”‚
â”‚ Installation method â”‚ portable package                                                       â”‚
â”‚ Version             â”‚ x.y+6d5921b                                                            â”‚
â”‚ Instance name       â”‚ my_edgedb_app                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Version x.y+6d5921b is already downloaded
Initializing EdgeDB instance...
Applying migrations...
Everything is up to date. Revision initial
Project initialized.
To connect to my_edgedb_app, run `edgedb`
```

---

title: Installing EdgeDB Client and Codegen - Shell
description: Shows how to install the EdgeDB JavaScript client library and the `@edgedb/generate` code generation tool using `bun add`.  The `touch seed.ts` command creates an empty file for the seeding script.
source: docs/guides/ecosystem/edgedb.md#_snippet_6

language: sh
code:
```
$ bun add edgedb
$ bun add -D @edgedb/generate
$ touch seed.ts
```

---

title: Configuring Neon Connection String
description: Illustrates how to create a `.env.local` file and set the `DATABASE_URL` environment variable with the Neon Postgres connection string. This is essential for the application to connect to the Neon database.
source: docs/guides/ecosystem/neon-drizzle.md#_snippet_1

language: sh
code:
```
DATABASE_URL=postgresql://username:password@ep-adj-noun-guid.us-east-1.aws.neon.tech/neondb?sslmode=require
```

---

title: Viewing Package Information with Examples Using Bun Info
description: Illustrates several common uses of the `bun info` command. These examples show how to view basic package information, a specific version, available versions, package dependencies, and a package homepage.
source: docs/cli/info.md#_snippet_5

language: bash
code:
```
# View basic package information
$ bun info is-number

# View a specific version
$ bun info is-number@7.0.0

# View all available versions
$ bun info is-number versions

# View package dependencies
$ bun info express dependencies

# View package homepage
$ bun info lodash homepage

# Get JSON output
$ bun info react --json
```

---

title: Updating Snapshots in Bun
description: Illustrates how to update the snapshot files when the expected output changes. The `bun test --update-snapshots` command regenerates the snapshot files in the `__snapshots__` directory, allowing you to update your snapshots when the output of your tests changes.
source: docs/test/snapshots.md#_snippet_1

language: bash
code:
```
$ bun test --update-snapshots
```

---

title: Watching Tests for Changes - Bun
description: Demonstrates how to use the `--watch` flag with `bun test` to automatically re-run tests when files change. This improves development efficiency by providing immediate feedback on code changes.
source: docs/test/hot.md#_snippet_0

language: sh
code:
```
$ bun test --watch
```

---

title: Installing Packages Globally Using Bun
description: Illustrates how to install a package globally using the `--global` flag with the `bun add` command. Global packages are typically command-line tools available in any project.
source: docs/cli/add.md#_snippet_6

language: bash
code:
```
$ bun add --global cowsay # or `bun add -g cowsay`
$ cowsay "Bun!"
 ______
< Bun! >
 ------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
```

---

title: Auto-Installing Package From Import
description: Demonstrates how Bun automatically installs packages from the `npm` registry when they are imported without a `node_modules` directory present. This allows for simplified dependency management, as packages are installed on-the-fly during script execution and cached for future use.
source: docs/runtime/autoimport.md#_snippet_0

language: ts
code:
```
import { foo } from "foo"; // install `latest` version

foo();
```

---

title: Installing Bun in a GitHub Actions Workflow
description: Shows how to install `bun` in a GitHub Actions workflow using the `oven-sh/setup-bun@v2` action. This allows you to use `bun test` within your CI/CD pipeline.
source: docs/cli/test.md#_snippet_4

language: yaml
code:
```
jobs:
  build:
    name: build-app
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Install bun
        uses: oven-sh/setup-bun@v2
      - name: Install dependencies # (assuming your project has dependencies)
        run: bun install # You can use npm/yarn/pnpm instead if you prefer
      - name: Run tests
        run: bun test
```

---

title: Setting System Time in Tests - TypeScript
description: Demonstrates how to mock the system time within `bun:test` using `setSystemTime`. This allows tests to assert time-dependent logic by manipulating the values returned by `Date.now()` and `new Date()`. The mocked time is set using a `beforeAll` hook to ensure consistent results across tests.
source: docs/test/time.md#_snippet_0

language: typescript
code:
```
import { setSystemTime, beforeAll, test, expect } from "bun:test";

beforeAll(() => {
  setSystemTime(new Date("2020-01-01T00:00:00.000Z"));
});

test("it is 2020", () => {
  expect(new Date().getFullYear()).toBe(2020);
});
```

---

title: Enabling Coverage Reporting - CLI
description: Demonstrates how to enable code coverage reporting using the `bun test` command with the `--coverage` flag. It prints a coverage report to the console, showing the percentage of functions and lines covered by tests, as well as the uncovered line numbers for each file.
source: docs/test/coverage.md#_snippet_0

language: js
code:
```
$ bun test --coverage
```

---

title: Setting Up Bun in GitHub Actions - YAML
description: Illustrates how to install Bun in a GitHub Actions pipeline using the official `oven-sh/setup-bun` action. This allows you to automate the installation of Bun in your CI/CD workflows.
source: docs/cli/install.md#_snippet_16

language: yaml
code:
```
name: bun-types
jobs:
  build:
    name: build-app
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
      - name: Install bun
        uses: oven-sh/setup-bun@v2
      - name: Install dependencies
        run: bun install
      - name: Build app
        run: bun run build
```

---

title: Checking Out WebKit Commit
description: Demonstrates how to checkout a specific commit in Bun's WebKit fork using `git checkout`. This step is crucial for identifying changes between upgrades, aiding in security, performance, and compatibility.
source: docs/contributing/upgrading-webkit.md#_snippet_0

language: bash
code:
```
$ cd src/bun.js/WebKit # In the WebKit directory! not bun
$ git checkout $COMMIT
```

---

title: Merging Upstream Main Branch
description: Illustrates the process of merging the `upstream main` branch into the local WebKit fork. This involves using `git merge` and potentially resolving conflicts. The `git fetch --unshallow` command is used to fetch the entire history if histories are unrelated.
source: docs/contributing/upgrading-webkit.md#_snippet_1

language: bash
code:
```
$ git merge upstream main
# If you get an error saying histories are unrelated, run this and try again:
$ git fetch --unshallow
```

---

title: Building JSC After Merge
description: Demonstrates the commands required to build JavaScriptCore (JSC) after merging changes from the upstream WebKit repository. It shows how to clean the `WebKitBuild` directory, navigate to Bun's directory, and then compile using `make jsc-build-mac-compile`.
source: docs/contributing/upgrading-webkit.md#_snippet_2

language: bash
code:
```
# You might have to run this multiple times.
$ rm -rf WebKitBuild

# Go to Bun's directory! Not WebKit.
cd ../../../../
make jsc-build-mac-compile
```

---

title: Verifying JSC Build
description: Illustrates how to verify that the JSC build was successful by running the `jsc --help` command. It checks for errors related to symbols or crashes, indicating a problem with the build process. A successful build prints the help options.
source: docs/contributing/upgrading-webkit.md#_snippet_3

language: bash
code:
```
src/bun.js/WebKit/WebKitBuild/Release/bin/jsc --help
```

---

title: Updating Bindings and Regenerating Headers
description: Demonstrates how to clean existing bindings and regenerate C++<>Zig headers using `make clean-bindings headers builtins`. This ensures that Bun's bindings are synchronized with the updated WebKit code.
source: docs/contributing/upgrading-webkit.md#_snippet_4

language: bash
code:
```
make clean-bindings headers builtins
```

---

title: Updating Bun's Bindings
description: Illustrates how to update Bun's bindings using `make bindings -j10`, specifying the number of parallel jobs. This recompiles the bindings based on the updated headers. The step can take a long time.
source: docs/contributing/upgrading-webkit.md#_snippet_5

language: bash
code:
```
# It will take awhile if you don't pass -j here
make bindings -j10
```

---

title: Running in Watch Mode
description: Demonstrates how to run a file in `--watch` mode using the Bun CLI. This command instructs Bun to monitor imported files and restart the process upon detecting any changes, preserving the original CLI arguments and environment variables.
source: docs/runtime/hot.md#_snippet_0

language: bash
code:
```
$ bun --watch index.tsx
```

---

title: Testing in Watch Mode
description: Illustrates how to execute tests in `--watch` mode with Bun. This command configures Bun to observe test files and automatically re-run the tests whenever changes are detected, providing continuous feedback during development.
source: docs/runtime/hot.md#_snippet_1

language: bash
code:
```
$ bun --watch test
```

---

title: Running in Hot Mode
description: Demonstrates how to enable hot reloading using the `bun --hot` command. This command differs from `--watch` by updating the internal module cache with new code upon detection of changes, rather than restarting the entire process.
source: docs/runtime/hot.md#_snippet_3

language: bash
code:
```
$ bun --hot server.ts
```

---

title: Writing Blob to File with Optimization
description: Demonstrates writing a `Blob` to a file using `Bun.write`, which utilizes optimized system calls like `copy_file_range` on Linux and `clonefile` on macOS for faster file copying. This approach leverages Bun's ability to efficiently handle file system operations.
source: docs/api/file.md#_snippet_0

language: javascript
code:
```
const blob = Bun.file("input.txt");
await Bun.write("output.txt", blob);
```

---

title: Registering Yaml Plugin With Bunfig Toml
description: Shows how to register the `.yaml` loader plugin by adding it to the `preload` array in `bunfig.toml`.  This ensures that the plugin is loaded before any `.yaml` files are imported.
source: docs/runtime/plugins.md#_snippet_3

language: toml
code:
```
preload = ["./yamlPlugin.ts"]
```

---

title: Building Client-Side Code with Bun
description: Illustrates how to use the `bun build` command to bundle client-side code. This process evaluates the `Bun.color` macro at bundle time, replacing the macro call with its computed result. The example shows building `client-side.ts` to generate `client-side.js`.
source: docs/api/color.md#_snippet_1

language: shell
code:
```
bun build ./client-side.ts
```

---

title: Showing Client-Side JavaScript Output
description: Demonstrates the JavaScript output after running `bun build`. The `console.log` statement contains the color formatted string, resulting from the bundle-time evaluation of the `Bun.color` macro. The original `color` function call has been replaced with the literal string `"red"`.
source: docs/api/color.md#_snippet_2

language: javascript
code:
```
// client-side.ts
console.log("red");
```

---

title: Binding a UDP Socket with Bun
description: Demonstrates how to create a new UDP socket using `Bun.udpSocket()` and optionally bind it to a specific port.  The first example creates a socket and lets the OS assign a port, while the second binds to port 41234.
source: docs/api/udp.md#_snippet_0

language: typescript
code:
```
const socket = await Bun.udpSocket({});
console.log(socket.port); // assigned by the operating system
```

language: typescript
code:
```
const socket = await Bun.udpSocket({
  port: 41234,
});
console.log(socket.port); // 41234
```

---

title: Using Runtime Preconnection with PostgreSQL
description: Illustrates how to enable PostgreSQL preconnection at startup using the `--sql-preconnect` flag, improving performance by establishing database connections before application code runs. Shows usage with environment variables and other runtime flags. This avoids connection latency for the first query.
source: docs/api/sql.md#_snippet_0

language: bash
code:
```
# Enable PostgreSQL preconnection
bun --sql-preconnect index.js

# Works with DATABASE_URL environment variable
DATABASE_URL=postgres://user:pass@localhost:5432/db bun --sql-preconnect index.js

# Can be combined with other runtime flags
bun --sql-preconnect --hot index.js
```

---

title: Compiling and Running C Code with `bun:ffi`
description: Demonstrates how to compile and run C code from JavaScript using `bun:ffi` and the `cc` function. It imports the `cc` function from `bun:ffi` and a C source file, compiles the C code using `cc`, and calls the compiled C function from JavaScript.
source: docs/api/cc.md#_snippet_0

language: typescript
code:
```
import { cc } from "bun:ffi";
import source from "./hello.c" with { type: "file" };

const {
  symbols: { hello },
} = cc({
  source,
  symbols: {
    hello: {
      args: [],
      returns: "int",
    },
  },
});

console.log("What is the answer to the universe?", hello());
```

language: c
code:
```
int hello() {
  return 42;
}
```

---

title: Opening an In-Memory Database
description: Demonstrates how to create an in-memory SQLite database using different `Database` constructor arguments.  This approach is useful for testing or temporary data storage. The snippet highlights the equivalence of using `:memory:`, an empty string, or no argument.
source: docs/api/sqlite.md#_snippet_2

language: ts
code:
```
import { Database } from "bun:sqlite";

// all of these do the same thing
const db = new Database(":memory:");
const db = new Database();
const db = new Database("");
```

---

title: Auditing for Vulnerabilities Using Bun
description: Demonstrates how to use `bun audit` to check installed packages for known security vulnerabilities. This command sends a list of installed packages and their versions to NPM, then prints a report of any vulnerabilities found. It skips packages installed from registries other than the default registry.
source: docs/install/audit.md#_snippet_0

language: bash
code:
```
$ bun audit
```

---

title: Setting Up Redis Clients - Bun
description: Illustrates how to create and use Redis clients in Bun, including using the default client that reads connection information from environment variables such as `REDIS_URL`, and creating a custom client with a specified connection string. This provides flexibility in configuring Redis connections based on environment or specific application needs.
source: docs/api/redis.md#_snippet_1

language: ts
code:
```
import { redis, RedisClient } from "bun";

// Using the default client (reads connection info from environment)
// process.env.REDIS_URL is used by default
await redis.set("hello", "world");
const result = await redis.get("hello");

// Creating a custom client
const client = new RedisClient("redis://username:password@localhost:6379");
await client.set("counter", "0");
await client.incr("counter");
```

---

title: Starting a Hono Project with Bun
description: Illustrates how to create a new Hono project using `bun create`, navigate into the newly created directory, and start the development server with `bun run start`. This is a typical sequence for bootstrapping a Hono application.
source: docs/ecosystem/hono.md#_snippet_1

language: bash
code:
```
$ bun create hono ./myapp
$ cd myapp
$ bun run start
```

---

title: Adding Bun-Native-Plugin Crate in Rust
description: Illustrates how to add the `bun-native-plugin` crate as a dependency to a Rust project. This crate provides necessary tools and macros for creating native Bun plugins in Rust.
source: docs/bundler/plugins.md#_snippet_1

language: bash
code:
```
cargo add bun-native-plugin
```

---

title: Enabling TLS
description: Demonstrates how to enable TLS (Transport Layer Security) in `Bun.serve` by providing the `key` and `cert` options in the `tls` object.  It is mandatory to provide both the TLS key and certificate contents. The example shows how to specify the path to the key and certificate files using `Bun.file`.
source: docs/api/http.md#_snippet_12

language: typescript
code:
```
Bun.serve({
    fetch(req) {
      return new Response("Hello!!!");
    },

    tls: {
      key: Bun.file("./key.pem"),
      cert: Bun.file("./cert.pem"),
    }
  });
```

---

title: Embedding Meta Tags Using Macro - TS
description: Demonstrates how `extractMetaTags` function with `{type: 'macro'}` fetches data at bundle-time and embeds the result directly into the output. This eliminates the need for runtime fetching and also allows for dead code elimination since unreachable branches are removed during the macro transformation.
source: docs/bundler/macros.md#_snippet_0

language: ts
code:
```
import { extractMetaTags } from './meta.ts' with { type: 'macro' };

export const Head = () => {
  const headTags = extractMetaTags("https://example.com");

  if (headTags.title !== "Example Domain") {
    throw new Error(
```

language: ts
code:
```
import { jsx, jsxs } from "react/jsx-runtime";
export const Head = () => {
  jsxs("head", {
    children: [
      jsx("title", {
        children: "Example Domain",
      }),
      jsx("meta", {
        name: "viewport",
        content: "width=device-width, initial-scale=1",
      }),
    ],
  });
};

export { Head };
```

---

title: Serving Hello World Example
description: Demonstrates a minimal "Hello, world!" server implemented in Bun.  It defines a `fetch` handler that returns a `Response` with the string "Bun!".
source: docs/api/http.md#_snippet_16

language: typescript
code:
```
Bun.serve({
  fetch(req: Request) {
    return new Response("Bun!");
  },
  port: 3000,
});
```

---

title: Building with Bun to Execute Macros
description: Illustrates how `bun build` executes macro functions during the build process. The `random` function is executed at bundle-time, and its return value replaces the function call in the output bundle, demonstrating macro inlining.
source: docs/bundler/macros.md#_snippet_1

language: bash
code:
```
$ bun build ./cli.tsx
console.log(`Your random number is ${0.6805550949689833}`);
```

---

title: Getting Git Commit Hash at Bundle Time
description: Demonstrates using a macro to embed the latest Git commit hash into the bundle. The `getGitCommitHash` function executes a `git` command at bundle-time and returns the commit hash, which is then inlined into the output.
source: docs/bundler/macros.md#_snippet_5

language: typescript
code:
```
export function getGitCommitHash() {
  const {stdout} = Bun.spawnSync({
    cmd: ["git", "rev-parse", "HEAD"],
    stdout: "pipe",
  });

  return stdout.toString();
}
```

---

title: Configuring Bun Lambda Function
description: Describes the steps to configure a new Lambda function on AWS to use Bun. Key settings include setting the Runtime to custom with Amazon Linux 2, configuring the handler, setting the architecture, and attaching the Lambda Layer.
source: packages/bun-lambda/README.md#_snippet_4

---

title: Publishing Bun Lambda Layer
description: Demonstrates publishing the Bun Lambda layer to your AWS account using `bun run publish-layer`.  It includes options to set the layer name, AWS region, and visibility (public or private).
source: packages/bun-lambda/README.md#_snippet_6

language: sh
code:
```
bun run publish-layer -- \
  --arch aarch64 \
  --release latest \
  --output /path/to/layer.zip \
  --region us-east-1
```

---

title: Upgrading Bun
description: Illustrates how to upgrade to the latest version of `bun` using the `bun upgrade` command. This ensures you have the most recent features and bug fixes.
source: packages/bun-release/npm/bun/README.md#_snippet_1

language: sh
code:
```
bun upgrade
```

---

title: Listening on a Port
description: Demonstrates how to listen for new connections on a specified port using `App.listen`. The callback function provides a pointer to the listen socket, which can be checked to confirm successful listening.
source: packages/bun-uws/misc/READMORE.md#_snippet_0

language: c++
code:
```
App.listen(port, [](auto *listenSocket) {
    /* listenSocket is either nullptr or us_listen_socket */
})
```

---

title: Enabling Development Mode in Bun Serve
description: Explains how to enable development mode in `Bun.serve()` by setting `development: true`. It highlights the benefits of development mode, such as including source maps, disabling minification, and enabling hot module reloading.
source: docs/bundler/fullstack.md#_snippet_5

language: diff
code:
```
import homepage from "./index.html";
import dashboard from "./dashboard.html";

Bun.serve({
  routes: {
    "/": homepage,
    "/dashboard": dashboard,
  }

+ development: true,

  fetch(req) {
    // ... api requests
  },
});
```

---

title: Using Ahead of Time Bundling for Production
description: Illustrates how to use ahead-of-time bundling with `Bun.build` for production deployments. It shows the command to bundle the application and mentions how Bun's bundler generates a manifest object for HTML imports to optimize serving static assets.
source: docs/bundler/fullstack.md#_snippet_7

language: sh
code:
```
$ bun build --target=bun --production --outdir=dist ./src/index.ts
```

language: typescript
code:
```
import { serve } from "bun";
import index from "./index.html";

serve({
  routes: { "/": index },
});
```

---

title: Enabling Scripts - PowerShell
description: Demonstrates how to set the execution policy for the current user to unrestricted in PowerShell. This allows running unsigned scripts, which is necessary for the build process.
source: docs/project/building-windows.md#_snippet_0

language: ps1
code:
```
> Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Unrestricted
```

---

title: Installing Visual Studio - PowerShell
description: Demonstrates installing Visual Studio Community 2022 with the required workloads (Desktop Development with C++ and Git) using WinGet. This ensures that the necessary tools for compiling native code are available.
source: docs/project/building-windows.md#_snippet_2

language: ps1
code:
```
> winget install "Visual Studio Community 2022" --override "--add Microsoft.VisualStudio.Workload.NativeDesktop Microsoft.VisualStudio.Component.Git " -s msstore
```

---

title: Installing Dependencies with Scoop - PowerShell
description: Demonstrates using Scoop to install essential development tools. This includes `nodejs-lts`, `go`, `rust`, `nasm`, `ruby`, `perl`, `ccache`, and `llvm@19.1.7`.  Scoop simplifies the installation process for these dependencies.
source: docs/project/building-windows.md#_snippet_3

language: ps1
code:
```
> irm https://get.scoop.sh | iex
> scoop install nodejs-lts go rust nasm ruby perl ccache
# scoop seems to be buggy if you install llvm and the rest at the same time
> scoop install llvm@19.1.7
```

---

title: Setting Up and Running Tests
description: Shows the commands to setup the project and run the tests.
source: packages/bun-plugin-yaml/README.md#_snippet_5

language: bash
code:
```
$ bun install # project setup
$ bun test # run tests
```

---

title: Running Bun with Inspector Attached
description: Illustrates how to spawn a Bun process with the inspector attached using the `--inspect-wait` flag. It also demonstrates how to extract the WebSocket URL from the output using `grep`.
source: packages/bun-inspector-protocol/README.md#_snippet_1

language: bash
code:
```
bun --inspect-wait my-script.ts

```

language: bash
code:
```
bun --inspect-wait my-script.ts 2>&1 | grep -o '\sws://.*$'
```

---

title: Creating and Freeing the Event Loop
description: Demonstrates the creation of a new event loop using `us_create_loop`, which allows for user data extension through the `ext_size` parameter and specifies callback functions for wakeup, pre-loop, and post-loop operations. It also shows how to free the allocated memory for the loop using `us_loop_free` when it's no longer needed.
source: packages/bun-usockets/misc/manual.md#_snippet_0

language: c
code:
```
/* Returns a new event loop with user data extension */
WIN32_EXPORT struct us_loop_t *us_create_loop(void *hint, void (*wakeup_cb)(struct us_loop_t *loop), void (*pre_cb)(struct us_loop_t *loop), void (*post_cb)(struct us_loop_t *loop), unsigned int ext_size);

/* Frees the loop immediately */
WIN32_EXPORT void us_loop_free(struct us_loop_t *loop);
```

---

title: Creating a Socket Context with Options
description: Demonstrates how to create a new socket context using `us_create_socket_context`, specifying whether it is SSL-enabled and providing options like key and certificate file names via the `us_socket_context_options_t` struct. It also shows how to free the allocated memory using `us_socket_context_free`.
source: packages/bun-usockets/misc/manual.md#_snippet_2

language: c
code:
```
struct us_socket_context_options_t {
    const char *key_file_name;
    const char *cert_file_name;
    const char *passphrase;
    const char *dh_params_file_name;
    const char *ca_file_name;
    const char *ssl_ciphers;
    int ssl_prefer_low_memory_usage;
};

/* A socket context holds shared callbacks and user data extension for associated sockets */
WIN32_EXPORT struct us_socket_context_t *us_create_socket_context(int ssl, struct us_loop_t *loop, int ext_size, struct us_socket_context_options_t options);

/* Delete resources allocated at creation time. */
WIN32_EXPORT void us_socket_context_free(int ssl, struct us_socket_context_t *context);
```

---

title: Running the Development Server Using Bun
description: Illustrates how to run the development server using the `bun run dev` command. This command leverages the updated `dev` script in `package.json` to start Vite with Bun.
source: docs/guides/ecosystem/vite.md#_snippet_4

language: bash
code:
```
bun run dev
```

---

title: Starting a Development Server with Bun
description: Illustrates starting a development server using the `bun dev` command. This command typically launches a local server with features like hot reloading, which automatically updates the application in the browser when code changes are saved, speeding up the development process.
source: src/cli/init/README2.default.md#_snippet_1

language: bash
code:
```
bun dev
```

---

title: Starting the Expo Application
description: Illustrates how to start the Expo application using `npx expo start`. This command starts the Expo development server, providing options to open the app in a web browser, an Android emulator, an iOS simulator, or the Expo Go app.
source: test/integration/expo-app/README.md#_snippet_1

language: bash
code:
```
npx expo start
```

---

title: Running in Development Mode
description: Illustrates how to start the application in development mode using `npm run dev`. This command launches a development server that typically supports hot module replacement and other developer-friendly features, making it easier to test and debug code changes.
source: test/js/third_party/pnpm/install_fixture/README.md#_snippet_1

language: bash
code:
```
$ npm run dev
```

---

title: Building for Production
description: Shows how to build the application for production using `npm run build`. This command optimizes the code, minifies it, and prepares it for deployment, ensuring optimal performance and reduced file sizes.
source: test/js/third_party/pnpm/install_fixture/README.md#_snippet_2

language: bash
code:
```
$ npm run build
```

---

title: Editing the Index Page - TypeScript
description: Illustrates how to modify the main page of a Next.js application by editing the `pages/index.tsx` file. Changes made to this file are automatically reflected in the browser due to Next.js's hot reloading feature, providing an efficient development workflow.
source: test/integration/next-pages/README.md#_snippet_1

language: typescript
code:
```
pages/index.tsx
```

---

title: Accessing API Routes - TypeScript
description: Demonstrates how to access API routes in a Next.js application via `http://localhost:3000/api/hello`. The endpoint's logic is defined in `pages/api/hello.ts`, which allows developers to create backend functionalities directly within their Next.js project.
source: test/integration/next-pages/README.md#_snippet_2

language: typescript
code:
```
pages/api/hello.ts
```

---

title: Running the Project with Bun
description: Illustrates how to execute the project's entry point using the `bun run {[entryPoint]s}` command.  This command starts the application, utilizing Bun's JavaScript runtime environment.
source: src/cli/init/README.default.md#_snippet_1

language: bash
code:
```
bun run {[entryPoint]s}
```

---

title: Running Tests - Shell
description: Demonstrates how to execute tests using the `bun test` command. It shows how to run all tests, tests within a specific directory, and a specific test file.
source: test/README.md#_snippet_0

language: sh
code:
```
bun test # Run all tests
bun test js/bun # Only run tests in a directory
bun test sqlite.test.ts # Only run a specific test
```

---

title: Writing Tests with Bun Test API - TypeScript
description: Illustrates how to write tests using `bun:test`'s `describe`, `test`, and `expect` APIs, along with the `gcTick` utility for garbage collection management. Demonstrates a basic test case for the `TextEncoder` API.
source: test/README.md#_snippet_1

language: ts
code:
```
import { describe, test, expect } from "bun:test";
import { gcTick } from "harness";

describe("TextEncoder", () => {
  test(
```

language: ts
code:
```
can encode a string", async () => {
    const encoder = new TextEncoder();
    const actual = encoder.encode("bun");
    await gcTick();
    expect(actual).toBe(new Uint8Array([0x62, 0x75, 0x6E]));
  });
});
```

---

title: Running TypeScript and JSX
description: Demonstrates executing TypeScript and JSX files directly using the `bun run` command. This eliminates the need for separate compilation steps, streamlining the development workflow.
source: README.md#_snippet_0

language: bash
code:
```
bun run index.tsx             # TS and JSX supported out-of-the-box
```

---

title: Utilizing Bun's Built-in Tools
description: Illustrates the usage of various built-in tools provided by Bun, such as the test runner (`bun test`), script runner (`bun run start`), package manager (`bun install <pkg>`), and package executor (`bunx`). These tools offer faster alternatives to existing Node.js solutions.
source: README.md#_snippet_1

language: bash
code:
```
bun test                      # run tests
bun run start                 # run the `start` script in `package.json`
bun install <pkg>             # install a package
bunx cowsay 'Hello, world!'   # execute a package
```

---

title: Creating a Mock Stream Using ArrayStream
description: Demonstrates how to create and use a simple mock stream using the `ArrayStream` module. The stream pushes elements from a given array and is useful for testing purposes.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_2

language: javascript
code:
```
const ArrayStream = require('../common/arraystream');
const stream = new ArrayStream();
stream.run(['a', 'b', 'c']);
```

---

title: Writing Http2 Client Magic Bytes
description: Shows how to write the `http2.kClientMagic` bytes to a socket. This is required as the initial preamble for an HTTP/2 client when establishing a new connection.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_3

language: js
code:
```
socket.write(http2.kClientMagic);
```

---

title: Spawning Bun Processes in Tests - TypeScript
description: Illustrates how to spawn Bun processes within tests using `bunExe` and `bunEnv` from the `harness`. These utilities ensure that the correct Bun build is used for testing and that debug logging is disabled.
source: test/AGENTS.md#_snippet_2

language: typescript
code:
```
import { bunEnv, bunExe } from "harness";
import { test, expect } from "bun:test";

test("spawns a Bun process", async () => {
  const dir = tempDirWithFiles("my-test-prefix", {
    "my.fixture.ts": `
      console.log("Hello, world!");
    `,
  });

  await using proc = Bun.spawn({
    cmd: [bunExe(), "my.fixture.ts"],
    env: bunEnv,
    cwd: dir,
  });

  const [stdout, stderr, exitCode] = await Promise.all([

    // ReadableStream in Bun supports:
    //  - `await stream.text()`
    //  - `await stream.json()`
    //  - `await stream.bytes()`
    //  - `await stream.blob()`
    proc.stdout.text(),
    proc.stderr.text(),

    proc.exitCode,
  ]);

  expect(stdout).toBe("Hello, world!");
  expect(stderr).toBe("");
  expect(exitCode).toBe(0);
```

---

title: Piping Data Natively With Zero-Copy - Zig
description: Illustrates Bun's optimization for high-throughput scenarios, piping data directly between native components like `FileReader` and `HTTPSResponseSink` in Zig, avoiding the JavaScript layer and enabling zero-copy data transfer from disk to the network socket.
source: src/bun.js/STREAMS.md#_snippet_0

language: mermaid
code:
```
%%{init: {'theme':'base', 'themeVariables': {'primaryColor':'#2563eb','primaryTextColor':'#fff','primaryBorderColor':'#3b82f6','lineColor':'#94a3b8','secondaryColor':'#fbbf24','background':'#f8fafc','mainBkg':'#ffffff','secondBkg':'#f1f5f9'}}}%%
graph TD
    subgraph " "
        subgraph js["[U+1F7E8] JavaScript Layer"]
            C["[U+1F4C4] new Response(file.stream()"]
        end
        subgraph native["âš¡ Native Layer (Zig)"]
            A["[U+1F4BE] Disk I/O<br><b>FileReader Source</b>"]
            B["[U+1F50C] Socket Buffer<br><b>HTTPSResponseSink</b>"]
            A -."[U+1F680] Zero-Copy View<br>streams.Result.temporary".-> B
            B -."[U+1F519] Backpressure Signal".-> A
        end
    end
    B ==>|"[U+1F4E1] Send"|D["[U+1F310] Network"]
    C ==>|"Direct Native<br>Connection"|A

    style js fill:#fef3c7,stroke:#92400e,stroke-width:3px,color:#451a03
    style native fill:#dbeafe,stroke:#1e40af,stroke-width:3px,color:#172554
    style A fill:#60a5fa,stroke:#1e40af,stroke-width:2px,color:#172554
    style B fill:#60a5fa,stroke:#1e40af,stroke-width:2px,color:#172554
    style C fill:#fbbf24,stroke:#92400e,stroke-width:2px,color:#451a03
    style D fill:#22c55e,stroke:#166534,stroke-width:2px,color:#ffffff

    classDef jsClass fill:#fef3c7,stroke:#f59e0b,stroke-width:2px
    classDef nativeClass fill:#dbeafe,stroke:#3b82f6,stroke-width:2px
    classDef networkClass fill:#d1fae5,stroke:#10b981,stroke-width:2px
```

---

title: Getting Node.js Version Info - Bash
description: Demonstrates using `curl` and `jq` to fetch and parse JSON data from the Node.js website, extracting the latest Node.js version information.
source: .claude/commands/upgrade-nodejs.md#_snippet_0

language: bash
code:
```
# Get latest Node.js version info
curl -s https://nodejs.org/dist/index.json | jq '.[0]'

# Get V8 version for a specific Node.js version (replace v24.3.0)
curl -s https://nodejs.org/dist/v24.3.0/node-v24.3.0-headers.tar.gz | tar -xzO node-v24.3.0/include/node/node_version.h | grep V8_VERSION

# Get ABI version for a specific Node.js version
curl -s https://nodejs.org/dist/v24.3.0/node-v24.3.0-headers.tar.gz | tar -xzO node-v24.3.0/include/node/node_version.h | grep NODE_MODULE_VERSION

# Or use the ABI registry
curl -s https://raw.githubusercontent.com/nodejs/node/main/doc/abi_version_registry.json | jq '.NODE_MODULE_VERSION."<version>"'
```

---

title: Writing Tests - Test Fixture Example
description: Illustrates the structure of a test using Bun's Jest-compatible test runner.  It creates a temporary directory, spawns a Bun process, and asserts the output, demonstrating a typical integration test setup.
source: AGENTS.md#_snippet_3

language: typescript
code:
```
import { test, expect } from "bun:test";
import { bunEnv, bunExe, tempDirWithFiles } from "harness";

test("my feature", async () => {
  // Create temp directory with test files
  const dir = tempDirWithFiles("test-prefix", {
    "index.js": `console.log("hello");`,
  });

  // Spawn Bun process
  await using proc = Bun.spawn({
    cmd: [bunExe(), "index.js"],
    env: bunEnv,
    cwd: dir,
  });

  const [stdout, stderr, exitCode] = await Promise.all([
    new Response(proc.stdout).text(),
    new Response(proc.stderr).text(),
    proc.exited,
  ]);

  expect(exitCode).toBe(0);
  expect(stdout).toBe("hello\n");
});
```

---

title: Testing with Bun
description: Demonstrates a basic test using the `bun:test` module. It imports `test` and `expect` for defining and asserting test conditions, providing a simple example of verifying equality.
source: src/init/rule.md#_snippet_0

language: typescript
code:
```
import { test, expect } from "bun:test";

test("hello world", () => {
  expect(1).toBe(1);
});
```

---

title: Running Bun with Hot Reloading
description: Shows how to execute a TypeScript file (`index.ts`) using Bun with hot reloading enabled via the `--hot` flag. This allows for automatic updates in the browser when changes are made to the source code.
source: src/init/rule.md#_snippet_4

language: shell
code:
```
bun --hot ./index.ts
```

---

title: Initializing a New Bun Project
description: Demonstrates how to initialize a new Bun project using the `bun init` command.  This command generates a default `tsconfig.json` file with recommended compiler options configured for Bun, facilitating a quick and easy setup for new projects.
source: docs/typescript.md#_snippet_2

language: sh
code:
```
$ bun init
```

---

title: Running TypeScript and JSX
description: Demonstrates how to execute TypeScript and JSX files directly using the `bun run` command. This eliminates the need for manual transpilation steps, streamlining the development workflow.
source: docs/index.md#_snippet_0

language: bash
code:
```
$ bun run index.tsx  # TS and JSX supported out of the box
```

---

title: Executing Common Bun Commands
description: Illustrates common `bun` commands for script execution, package installation, bundling, and testing. These commands provide a faster alternative to Node.js equivalents.
source: docs/index.md#_snippet_1

language: bash
code:
```
$ bun run start                 # run the `start` script
$ bun install <pkg>             # install a package
$ bun build ./index.tsx         # bundle a project for browsers
$ bun test                      # run tests
$ bunx cowsay 'Hello, world!'   # execute a package
```

---

title: Reading JSON File Using BunFile
description: Demonstrates how to read and parse a JSON file using `Bun.file()` and the `.json()` method. It sets the MIME type of the `BunFile` instance to `application/json;charset=utf-8` and parses the file contents into a plain JavaScript object.
source: docs/guides/read-file/json.md#_snippet_0

language: typescript
code:
```
const path = "/path/to/package.json";
const file = Bun.file(path);

const contents = await file.json();
// { name: "my-package" }

file.type; // => "application/json;charset=utf-8";
```

---

title: Reading File to Buffer - Bun
description: Demonstrates how to read a file into a `Buffer` instance in Bun. It uses `Bun.file()` to access the file, then asynchronously converts the file contents to an `ArrayBuffer` using `.arrayBuffer()`. Finally, it converts the `ArrayBuffer` to a `Buffer` using `Buffer.from()`.
source: docs/guides/read-file/buffer.md#_snippet_0

language: typescript
code:
```
const path = "/path/to/package.json";
const file = Bun.file(path);

const arrbuf = await file.arrayBuffer();
const buffer = Buffer.from(arrbuf);
```

---

title: Running Tests - Single Test File
description: Illustrates how to run a specific test file using the debug build of Bun. This command ensures that changes are included in the test execution.
source: CLAUDE.md#_snippet_0

language: shell
code:
```
bun bd test test/js/bun/http/serve.test.ts
```

---

title: Running Tests - Fuzzy Matching
description: Demonstrates running tests by fuzzy matching the test file name. This is useful when you want to run tests based on a partial name or path.
source: CLAUDE.md#_snippet_1

language: shell
code:
```
bun bd test http/serve.test.ts
```

---

title: Running Tests - Filtering with a Specific Term
description: Illustrates how to filter tests by a specific term within the test file. This allows focusing on specific test cases or scenarios.
source: CLAUDE.md#_snippet_2

language: shell
code:
```
bun bd test test/js/bun/http/serve.test.ts -t "should handle"
```

---

title: Writing Tests - Importing Test Fixtures
description: Demonstrates how to import necessary modules for writing tests with Bun's Jest-compatible test runner. It shows importing `test` and `expect` from `bun:test` and fixtures from `harness`.
source: CLAUDE.md#_snippet_3

language: typescript
code:
```
import { test, expect } from "bun:test";
import { bunEnv, bunExe, tempDirWithFiles } from "harness";
```

---

title: Writing Tests - Defining a Test Case
description: Demonstrates defining a test case using Bun's testing framework. This includes creating a temporary directory with files, spawning a Bun process, and asserting on the output and exit code.
source: CLAUDE.md#_snippet_4

language: typescript
code:
```
test("my feature", async () => {
  // Create temp directory with test files
  const dir = tempDirWithFiles("test-prefix", {
    "index.js": `console.log("hello");`,
  });

  // Spawn Bun process
  await using proc = Bun.spawn({
    cmd: [bunExe(), "index.js"],
    env: bunEnv,
    cwd: dir,
  });

  const [stdout, stderr, exitCode] = await Promise.all([
    new Response(proc.stdout).text(),
    new Response(proc.stderr).text(),
    proc.exited,
  ]);

  expect(exitCode).toBe(0);
  expect(stdout).toBe("hello\n");
});
```

---

title: Minifying Identifiers with Frequency Analysis - JavaScript
description: Demonstrates how identifier minification is performed using frequency analysis. The input code shows a function `calculateUserMetrics` and its dependencies, and the minified output shows how the identifiers are replaced with shorter names (e.g., `a`, `b`, `c`) based on their frequency of usage.
source: src/bundler/linker_context/README.md#_snippet_1

language: javascript
code:
```
// Input:
function calculateUserMetrics(userData, configuration) {
  const processedData = processConfiguration(userData, configuration);
  return generateMetrics(processedData);
}

// Minified output:
function a(b, c) {
  const d = e(b, c);
  return f(d);
}
```

---

title: Bundling a Simple ES6 Module
description: Demonstrates how to bundle a simple ES6 module using `itBundled`. It defines two files, `/entry.js` which imports a function from `/foo.js`, and `/foo.js` which exports the function. The test then runs the bundled output and asserts that the standard output matches the expected value of '123'.
source: test/bundler/expectBundled.md#_snippet_1

language: typescript
code:
```
itBundled("default/SimpleES6", {
  files: {
    // Define one or more files. Strings are passed through `dedent`
    // First file is the entry file
    "/entry.js": /* js */ `
      import { fn } from './foo';
      console.log(fn());
    `,
    "/foo.js": /* js */ `
      export function fn() {
        return 123
      }
    `,
  },
  // outfile: "out.js", // Default is "out.js"

  // Passing `run` will run the bundle
  run: {
    stdout: "123",
    // file: "out.js", // Default is whatever `outfile` is
  },
});
```

---

title: Reading File Contents as String - TypeScript
description: Demonstrates how to read the content of a file as a string using `Bun.file()` and the `.text()` method. The `Bun.file()` function accepts a file path, and the `.text()` method asynchronously returns the file content as a string.
source: docs/guides/read-file/string.md#_snippet_0

language: typescript
code:
```
const path = "/path/to/file.txt";
const file = Bun.file(path);

const text = await file.text();
// string
```

---

title: Reading File Contents Into Uint8Array
description: Demonstrates how to read the contents of a file into a `Uint8Array` using `Bun.file()` and the `.bytes()` method. This is useful for processing binary data from files in Bun.
source: docs/guides/read-file/uint8array.md#_snippet_0

language: typescript
code:
```
const path = "/path/to/package.json";
const file = Bun.file(path);

const byteArray = await file.bytes();

byteArray[0]; // first byteArray
byteArray.length; // length of byteArray
```

---

title: Checking If a File Exists - TypeScript
description: Demonstrates how to check if a file exists using `Bun.file()` and the `.exists()` method. The `Bun.file()` function accepts a path to a file, and the `.exists()` method returns a boolean indicating whether the file exists at that path. This is useful for validating file paths before attempting to read or write to them.
source: docs/guides/read-file/exists.md#_snippet_0

language: typescript
code:
```
const path = "/path/to/package.json";
const file = Bun.file(path);

await file.exists(); // boolean;
```

---

title: Orchestrating the Linking Process
description: Illustrates the main linking orchestrator function that coordinates all bundling phases. It highlights the sequence of operations, including `load()`, source map computation, `scanImportsAndExports()`, `treeShakingAndCodeSplitting()`, `computeChunks()`, and `computeCrossChunkDependencies()`. It also mentions error handling and memory corruption checks.
source: src/bundler/linker_context/README.md#_snippet_1

---

title: Streaming a File as ReadableStream - TypeScript
description: Demonstrates how to stream a file as a `ReadableStream` using `Bun.file()` and the `.stream()` method. This allows for incrementally reading a file, which is useful for large files or when you want to process the file contents as they become available.
source: docs/guides/read-file/stream.md#_snippet_0

language: typescript
code:
```
const path = "/path/to/package.json";
const file = Bun.file(path);

const stream = file.stream();
```

---

title: Getting MIME Type From File - TypeScript
description: Demonstrates how to read the MIME type of a file using `Bun.file()` and the `.type` property. The `Bun.file()` function returns a `BunFile` instance, which extends `Blob` and provides access to the MIME type.
source: docs/guides/read-file/mime.md#_snippet_0

language: typescript
code:
```
const file = Bun.file("./package.json");
file.type; // application/json

const file = Bun.file("./index.html");
file.type; // text/html

const file = Bun.file("./image.png");
file.type; // image/png
```

---

title: Reading File as ArrayBuffer
description: Demonstrates how to read a file into an `ArrayBuffer` using `Bun.file()` and its `.arrayBuffer()` method. This is useful for accessing the raw binary data of a file.
source: docs/guides/read-file/arraybuffer.md#_snippet_0

language: typescript
code:
```
const path = "/path/to/package.json";
const file = Bun.file(path);

const buffer = await file.arrayBuffer();
```

---

title: Running a Simple HTTP Server - Bun Serve API
description: Illustrates how to create a simple HTTP server using the `Bun.serve` API. The server listens on port 3000 and returns a basic "Bun!" response for all requests. This example showcases the core functionality for setting up a web server with Bun.
source: docs/quickstart.md#_snippet_1

language: typescript
code:
```
const server = Bun.serve({
  port: 3000,
  fetch(req) {
    return new Response("Bun!");
  },
});

console.log(`Listening on http://localhost:${server.port} ...`);
```

---

title: Defining HTTP Server
description: Defines a simple HTTP server using Bun.js. The server listens on port 3000 and returns 'Hello World' for every request. This demonstrates the basic structure for creating a web server with Bun.
source: docs/benchmarks.md#_snippet_0

language: typescript
code:
```
export default {
  port: 3000,
  fetch(request: Request) {
    return new Response("Hello World");
  },
};
```

---

title: Getting Test Cases for Process Exit Codes
description: Illustrates how to use the `process-exit-code-test-cases` module to retrieve an array of test cases for validating the exit codes of the `process` object. The `isWorker` parameter is used to adjust the test cases for worker threads.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_1

language: javascript
code:
```
### `getTestCases(isWorker)`

* `isWorker` [\[<boolean>\]][<boolean>]
* return [\[<Array>\]][<Array>]

Returns an array of test cases for testing the exit codes of the `process`. Each
test case is an object with a `func` property that is a function that runs the
test case, a `result` property that is the expected exit code, and sometimes an
`error` property that is a regular expression that the error message should
match when the test case is run in a worker thread.

The `isWorker` parameter is used to adjust the test cases for worker threads.
The default value is `false`.
```

---

title: Demonstrating Import Resolution - Javascript
description: Demonstrates how import resolution works by tracing how the `square` function, originally defined in `math.js`, is re-exported in `utils.js` and then imported and used in `app.js`. The system tracks the dependency from `app.js` directly to `math.js`, bypassing the intermediate re-export in `utils.js` for efficiency.
source: src/bundler/linker_context/README.md#_snippet_1

language: javascript
code:
```
// math.js
export const PI = 3.14159;
export function square(x) {
  return x * x;
} // Declared in part 0

// utils.js
export { PI, square } from "./math.js"; // Re-export in part 0

// app.js
import { square } from "./utils.js"; // Part 1 imports square
console.log(square(5)); // Usage in part 1

// Result: app.js part 1 depends on math.js part 0 (where square is declared)
// The re-export through utils.js is tracked but doesn't create additional dependencies
```

---

title: Spying on Methods - Bun Test
description: Defines an object `leo` with a method `sayHi` and uses `spyOn` from `bun:test` to create a spy on this method. This allows tracking of calls to the `sayHi` method.
source: docs/guides/test/spy-on.md#_snippet_0

language: ts
code:
```
import { test, expect, spyOn } from "bun:test";

const leo = {
  name: "Leonardo",
  sayHi(thing: string) {
    console.log(`Sup I'm ${this.name} and I like ${thing}`);
  },
};

const spy = spyOn(leo, "sayHi");
```

---

title: Testing Method Call Count Using Spies - Bun Test
description: Demonstrates how to use the spy created with `spyOn` to assert the number of times the method `sayHi` was called and the arguments it received.  It checks that `spy` has not been called, then calls `leo.sayHi('pizza')` and confirms the call count and arguments.
source: docs/guides/test/spy-on.md#_snippet_1

language: ts-diff
code:
```
  import { test, expect, spyOn } from "bun:test";

  const leo = {
    name: "Leonardo",
    sayHi(thing: string) {
      console.log(`Sup I'm ${this.name} and I like ${thing}`);
    },
  };

  const spy = spyOn(leo, "sayHi");

+ test("turtles", ()=>{
+   expect(spy).toHaveBeenCalledTimes(0);
+   leo.sayHi("pizza");
+   expect(spy).toHaveBeenCalledTimes(1);
+   expect(spy.mock.calls).toEqual([[ "pizza" ]]);
+ })
```

---

title: Testing Snapshots - TypeScript
description: Demonstrates how to create a snapshot test using `bun:test`. The `toMatchSnapshot()` method captures the structure and content of the object, which is then saved to a file in the `__snapshots__` directory.
source: docs/guides/test/update-snapshots.md#_snippet_0

language: typescript
code:
```
import { test, expect } from "bun:test";

test("snapshot", () => {
  expect({ foo: "bar" }).toMatchSnapshot();
});
```

---

title: Converting Readable Stream to String - TypeScript
description: Demonstrates how to convert a Node.js `Readable` stream to a string using Bun. It creates a new `Response` object from the stream and then uses the `response.text()` method to read the stream's content as a string.
source: docs/guides/streams/node-readable-to-string.md#_snippet_0

language: typescript
code:
```
import { Readable } from "stream";
const stream = Readable.from([Buffer.from("Hello, world!")]);
const text = await new Response(stream).text();
console.log(text); // "Hello, world!"
```

---

title: Using Snapshot Testing with Bun Test
description: Demonstrates how to use snapshot testing in Bun's test runner via the `.toMatchSnapshot()` method. The test runner will create a `__snapshots__` directory and `.snap` file to store the serialized value.
source: docs/guides/test/snapshot.md#_snippet_0

language: ts
code:
```
import { test, expect } from "bun:test";

test("snapshot", () => {
  expect({ foo: "bar" }).toMatchSnapshot();
});
```

---

title: Running a Test and Adding a Snapshot
description: Illustrates the output when running a test that uses snapshot testing for the first time. The output shows that a snapshot file has been added, confirming the successful creation of the snapshot.
source: docs/guides/test/snapshot.md#_snippet_1

language: sh
code:
```
$ bun test test/snap
bun test v$BUN_LATEST_VERSION (9c68abdb)

test/snap.test.ts:
âœ“ snapshot [1.48ms]

 1 pass
 0 fail
 snapshots: +1 added
 1 expect() calls
Ran 1 tests across 1 files. [82.00ms]
```

---

title: Converting ReadableStream to Text - TypeScript
description: Demonstrates how to convert a `ReadableStream` to a string using `Bun.readableStreamToText()`. This is a convenience function provided by Bun for easily reading the contents of a `ReadableStream`.
source: docs/guides/streams/to-string.md#_snippet_0

language: typescript
code:
```
const stream = new ReadableStream();
const str = await Bun.readableStreamToText(stream);
```

---

title: Creating a Mock Function - TypeScript
description: Defines a mock function using the `mock` function from `bun:test`. This allows replacing the actual implementation of `Math.random()` with a mock version during testing.
source: docs/guides/test/mock-functions.md#_snippet_0

language: typescript
code:
```
import { test, expect, mock } from "bun:test";

const random = mock(() => Math.random());
```

---

title: Adding Arguments to a Mock Function - TypeScript
description: Demonstrates how to define a mock function that accepts arguments. The `mock` function is called with a function that takes a `multiplier` argument, allowing for more complex mock implementations.
source: docs/guides/test/mock-functions.md#_snippet_1

language: typescript
code:
```
import { test, expect, mock } from "bun:test";

const random = mock((multiplier: number) => multiplier * Math.random());
```

---

title: Converting Readable Stream to JSON - TypeScript
description: Demonstrates how to convert a Node.js `Readable` stream to a JSON object using Bun. It creates a `Response` object from the stream and then uses `response.json()` to parse the stream into a JSON object.
source: docs/guides/streams/node-readable-to-json.md#_snippet_0

language: typescript
code:
```
import { Readable } from "stream";
const stream = Readable.from([JSON.stringify({ hello: "world" })]);
const json = await new Response(stream).json();
console.log(json); // { hello: "world" }
```

---

title: Converting ReadableStream to JSON - TypeScript
description: Demonstrates how to convert a `ReadableStream` to JSON using `Bun.readableStreamToJSON`. This is a convenience function provided by Bun for easily consuming stream data as JSON.
source: docs/guides/streams/to-json.md#_snippet_0

language: typescript
code:
```
const stream = new ReadableStream();
const json = await Bun.readableStreamToJSON(stream);
```

---

title: Writing a DOM Test with Happy DOM - TypeScript
description: Illustrates a basic DOM test using Bun's test runner and Happy DOM. The test sets the `innerHTML` of the `document.body`, queries for a button, and asserts that the button's `innerText` matches the expected value. This demonstrates how to use mocked browser APIs in Bun tests.
source: docs/guides/test/happy-dom.md#_snippet_3

language: ts
code:
```
import { test, expect } from "bun:test";

test("set button text", () => {
  document.body.innerHTML = `<button>My button</button>`;
  const button = document.querySelector("button");
  expect(button?.innerText).toEqual("My button");
});
```

---

title: Converting ReadableStream to ArrayBuffer - TypeScript
description: Demonstrates how to convert a `ReadableStream` to an `ArrayBuffer` using `Bun.readableStreamToArrayBuffer(stream)`. This is useful for processing stream data as a contiguous memory block.
source: docs/guides/streams/to-arraybuffer.md#_snippet_0

language: typescript
code:
```
const stream = new ReadableStream();
const buf = await Bun.readableStreamToArrayBuffer(stream);
```

---

title: Migrating from Jest with Bun
description: Illustrates how to migrate from Jest to Bun's test runner by replacing Jest commands with `bun test`. This often requires no code changes, as Bun internally rewrites imports and injects globals.
source: docs/guides/test/migrate-from-jest.md#_snippet_0

language: sh
code:
```
- $ npx jest
- $ yarn test
+ $ bun test
```

---

title: Enabling TypeScript Support for Global Test Functions
description: Demonstrates how to enable TypeScript support for global test functions using a triple-slash directive. Adding `/// <reference types="bun/test-globals" />` to a single file provides TypeScript support for Jest globals throughout the project, simplifying migration.
source: docs/guides/test/migrate-from-jest.md#_snippet_2

language: ts
code:
```
/// <reference types="bun/test-globals" />
```

---

title: Using Jest Globals with TypeScript
description: Illustrates how to use Jest globals like `describe`, `test`, `expect`, `beforeAll`, and `afterEach` in a TypeScript test file. The triple-slash directive enables TypeScript support for these globals, allowing for a smooth transition from Jest.
source: docs/guides/test/migrate-from-jest.md#_snippet_3

language: ts
code:
```
describe("my test suite", () => {
  test("should work", () => {
    expect(1 + 1).toBe(2);
  });

  beforeAll(() => {
    // setup code
  });

  afterEach(() => {
    // cleanup code
  });
});
```

---

title: Converting Readable Stream to ArrayBuffer - Bun
description: Demonstrates converting a Node.js `Readable` stream to an `ArrayBuffer` in Bun. It creates a new `Response` object using the stream as the body and then uses the `arrayBuffer()` method to read the stream's contents into an `ArrayBuffer`.
source: docs/guides/streams/node-readable-to-arraybuffer.md#_snippet_0

language: typescript
code:
```
import { Readable } from "stream";
const stream = Readable.from(["Hello, ", "world!"]);
const buf = await new Response(stream).arrayBuffer();
```

---

title: Converting Readable Stream to Blob - TypeScript
description: Demonstrates converting a Node.js `Readable` stream into a `Blob` using Bun. It creates a new `Response` object with the stream as its body and then uses `response.blob()` to read the stream into a `Blob`.
source: docs/guides/streams/node-readable-to-blob.md#_snippet_0

language: typescript
code:
```
import { Readable } from "stream";
const stream = Readable.from(["Hello, ", "world!"]);
const blob = await new Response(stream).blob();
```

---

title: Setting System Time in Bun Test
description: Demonstrates how to set the system time within a Bun test using the `setSystemTime` function. This allows tests to simulate specific dates and times, ensuring consistent and predictable behavior when dealing with time-dependent logic. The example sets the system time to January 1, 1999, and then asserts that the current date reflects this change.
source: docs/guides/test/mock-clock.md#_snippet_0

language: typescript
code:
```
import { test, expect, setSystemTime } from "bun:test";

test("party like it's 1999", () => {
  const date = new Date("1999-01-01T00:00:00.000Z");
  setSystemTime(date); // it's now January 1, 1999

  const now = new Date();
  expect(now.getFullYear()).toBe(1999);
  expect(now.getMonth()).toBe(0);
  expect(now.getDate()).toBe(1);
});
```

---

title: Getting Process Uptime - TypeScript
description: Demonstrates how to use `Bun.nanoseconds()` to retrieve the total number of nanoseconds that the Bun process has been running. This is useful for performance monitoring, benchmarking, and debugging timing-sensitive code.
source: docs/guides/process/nanoseconds.md#_snippet_0

language: typescript
code:
```
Bun.nanoseconds();
```

---

title: Defining Tests and Suites with Bun Test
description: Demonstrates how to structure tests using the `test` function and group related tests into suites using the `describe` function from the `bun:test` module.  This structure enhances test organization and readability, making it easier to manage and understand test results.
source: docs/guides/test/run-tests.md#_snippet_2

language: ts
code:
```
import { test, expect, describe } from "bun:test";

describe("math", () => {
  test("add", () => {
    expect(2 + 2).toEqual(4);
  });

  test("multiply", () => {
    expect(2 * 2).toEqual(4);
  });
});
```

---

title: Converting ReadableStream to Uint8Array
description: Demonstrates how to convert a `ReadableStream` to a `Uint8Array` using `Bun.readableStreamToArrayBuffer`. First, it reads the stream into an `ArrayBuffer`, then creates a `Uint8Array` that points to the buffer.
source: docs/guides/streams/to-typedarray.md#_snippet_0

language: typescript
code:
```
const stream = new ReadableStream();
const buf = await Bun.readableStreamToArrayBuffer(stream);
const uint8 = new Uint8Array(buf);
```

---

title: Converting ReadableStream to Uint8Array - Alternative Method
description: Illustrates a more direct approach to converting a `ReadableStream` to a `Uint8Array` using `Bun.readableStreamToBytes`. This method provides a more convenient way to achieve the same result.
source: docs/guides/streams/to-typedarray.md#_snippet_1

language: typescript
code:
```
const stream = new ReadableStream();
const uint8 = await Bun.readableStreamToBytes(stream);
```

---

title: Checking Bun Version
description: Demonstrates how to check the installed version of Bun using the `bun --version` command. This verifies that the installation was successful.
source: docs/installation.md#_snippet_6

language: sh
code:
```
$ bun --version
1.x.y
```

---

title: Using Testing Library with Bun
description: Demonstrates how to use Testing Library in a Bun test. It imports necessary modules from `bun:test` and `@testing-library/react`, renders a component, and uses Testing Library's `screen` object and matchers to make assertions.
source: docs/guides/test/testing-library.md#_snippet_6

language: typescript
code:
```
import { test, expect } from "bun:test";
import { screen, render } from "@testing-library/react";
import { MyComponent } from "./myComponent";

test("Can use Testing Library", () => {
  render(MyComponent);
  const myComponent = screen.getByTestId("my-component");
  expect(myComponent).toBeInTheDocument();
});
```

---

title: Starting an HTTP Server with Bun
description: Demonstrates how to create a basic HTTP server using `Bun.serve`. The server listens on port 3000 and responds to all requests with a status code of 200 and the body "Welcome to Bun!". This provides a simple example for getting started with HTTP server development in Bun.
source: docs/guides/http/simple.md#_snippet_0

language: typescript
code:
```
const server = Bun.serve({
  port: 3000,
  fetch(request) {
    return new Response("Welcome to Bun!");
  },
});

console.log(`Listening on ${server.url}`);
```

---

title: Consuming Stdout Stream - Bun
description: Demonstrates how to consume the `stdout` of a child process spawned using `Bun.spawn()` as a `ReadableStream` via `proc.stdout`. This allows you to capture and process the output of the child process within the parent process.
source: docs/guides/process/spawn-stdout.md#_snippet_0

language: ts
code:
```
const proc = Bun.spawn(["echo", "hello"]);

const output = await proc.stdout.text();
output; // => "hello"
```

---

title: Logging Command-Line Arguments - Bun
description: Demonstrates how to access the command-line arguments passed to a Bun script using `Bun.argv`. The output shows an array containing the path to the `bun` executable, the script's path, and any additional arguments provided when running the script.
source: docs/guides/process/argv.md#_snippet_0

language: typescript
code:
```
console.log(Bun.argv);
```

---

title: Reading Lines from Stdin - TypeScript
description: Demonstrates reading lines from standard input using the `console` object, which is an `AsyncIterable` in Bun. Each iteration of the loop receives a line of text that the user typed. The example writes a prompt to `stdout` and echoes user input from `stdin`.
source: docs/guides/process/stdin.md#_snippet_0

language: typescript
code:
```
const prompt = "Type something: ";
process.stdout.write(prompt);
for await (const line of console) {
  console.log(`You typed: ${line}`);
  process.stdout.write(prompt);
}
```

---

title: Proxying HTTP Requests with Fetch
description: Demonstrates how to use the `proxy` option with `fetch` to send requests through an HTTP or HTTPS proxy in Bun. This is useful for routing requests through corporate networks or specific IP addresses.
source: docs/guides/http/proxy.md#_snippet_0

language: typescript
code:
```
await fetch("https://example.com", {
  // The URL of the proxy server
  proxy: "https://username:password@proxy.example.com:8080",
});
```

---

title: Streaming HTTP Response Using Node.js Readable Stream
description: Demonstrates how to use a Node.js `Readable` stream as the body of a Bun `Response` object. This allows for streaming data directly from a Node.js stream to an HTTP client. The `serve` function creates an HTTP server that responds with the stream.
source: docs/guides/http/stream-node-streams-in-bun.md#_snippet_0

language: typescript
code:
```
import { Readable } from "stream";
import { serve } from "bun";
serve({
  port: 3000,
  fetch(req) {
    return new Response(Readable.from(["Hello, ", "world!"]), {
      headers: { "Content-Type": "text/plain" },
    });
  },
});
```

---

title: Spawning a Child Process with Bun
description: Demonstrates how to use `Bun.spawn()` to execute a child process. The example spawns an `echo` command and awaits its completion, illustrating the basic usage of the function.
source: docs/guides/process/spawn.md#_snippet_0

language: ts
code:
```
const proc = Bun.spawn(["echo", "hello"]);

// await completion
await proc.exited;
```

---

title: Writing a ReadableStream to Disk - TypeScript
description: Demonstrates writing a `ReadableStream` to disk using `Bun.write()`. First, creates a `Response` from the stream. Then, the `Response` is passed to `Bun.write()` with the file path to write the stream to the file.
source: docs/guides/write-file/stream.md#_snippet_0

language: typescript
code:
```
const stream: ReadableStream = ...;
const path = "./file.txt";
const response = new Response(stream);

await Bun.write(path, response);
```

---

title: Fetching Data Using Unix Domain Sockets - Typescript
description: Demonstrates how to use the `unix` option in Bun's `fetch()` to send an HTTP request over a unix domain socket to a specified path. This is useful for communicating with services that expose a unix socket, such as Docker.
source: docs/guides/http/fetch-unix.md#_snippet_0

language: ts
code:
```
const unix = "/var/run/docker.sock";

const response = await fetch("http://localhost/info", { unix });

const body = await response.json();
console.log(body); // { ... }
```

---

title: Writing to Stdout - Console.log
description: Demonstrates writing to standard output using `console.log`. This function automatically appends a line break to the printed data.
source: docs/guides/write-file/stdout.md#_snippet_0

language: ts
code:
```
console.log("Lorem ipsum");
```

---

title: Sending and Receiving IPC Messages - TypeScript
description: Illustrates how the parent process sends messages to the child process using the `.send()` method on the `Subprocess` instance, and how the child process responds. The parent's `ipc` handler receives messages from the child, and the child uses `process.send()` to send messages and `process.on("message")` to listen for messages.
source: docs/guides/process/ipc.md#_snippet_1

language: typescript
code:
```
const childProc = Bun.spawn(["bun", "child.ts"], {
  ipc(message, childProc) {
    /**
     * The message received from the sub process
     **/
    childProc.send(
```

language: typescript
code:
```
process.send("Hello from child as string");
process.send({ message: "Hello from child as object" });

process.on("message", (message) => {
  // print message from parent
  console.log(message);
});
```

---

title: Fetching a Web Page Using the Fetch API
description: Demonstrates a simple `GET` request using the `fetch` API to retrieve the HTML content from a URL. The `response.text()` method converts the response body into an HTML string, enabling further processing or display of the webpage content.
source: docs/guides/http/fetch.md#_snippet_0

language: ts
code:
```
const response = await fetch("https://bun.com");
const html = await response.text(); // HTML string
```

---

title: Posting Data to an API Endpoint Using Fetch
description: Illustrates how to send a `POST` request with a JSON payload to an API endpoint using the `fetch` API.  It serializes a JavaScript object into JSON using `JSON.stringify()` and sets the `Content-Type` header to `application/json`. The server's response is parsed into a JavaScript object using `response.json()`.
source: docs/guides/http/fetch.md#_snippet_1

language: ts
code:
```
const response = await fetch("https://bun.com/api", {
  method: "POST",
  body: JSON.stringify({ message: "Hello from Bun!" }),
  headers: { "Content-Type": "application/json" },
});

const body = await response.json();
```

---

title: Serving Basic HTTP Responses Using Bun
description: Demonstrates how to serve HTTP responses with Bun using various methods. It showcases handling different routes, redirecting requests, serving files, responding with JSON, and handling POST requests with JSON and form data. This is useful for building basic web servers and APIs with Bun.
source: docs/guides/http/server.md#_snippet_0

language: ts
code:
```
const server = Bun.serve({
  async fetch(req) {
    const path = new URL(req.url).pathname;

    // respond with text/html
    if (path === "/") return new Response("Welcome to Bun!");

    // redirect
    if (path === "/abc") return Response.redirect("/source", 301);

    // send back a file (in this case, *this* file)
    if (path === "/source") return new Response(Bun.file(import.meta.path));

    // respond with JSON
    if (path === "/api") return Response.json({ some: "buns", for: "you" });

    // receive JSON data to a POST request
    if (req.method === "POST" && path === "/api/post") {
      const data = await req.json();
      console.log("Received JSON:", data);
      return Response.json({ success: true, data });
    }

    // receive POST data from a form
    if (req.method === "POST" && path === "/form") {
      const data = await req.formData();
      console.log(data.get("someField"));
      return new Response("Success");
    }

    // 404s
    return new Response("Page not found", { status: 404 });
  },
});

console.log(`Listening on ${server.url}`);
```

---

title: Defining Simple Counter Component - Svelte
description: Defines a simple Svelte component (`Counter.svelte`) with a button that increments a counter. This component is used in the subsequent test to verify the testing setup.
source: docs/guides/test/svelte-test.md#_snippet_3

language: html
code:
```
<script>
  export let initialCount = 0;
  let count = initialCount;
</script>

<button on:click={() => (count += 1)}>+1</button>
```

---

title: Testing Svelte Component - TypeScript
description: Illustrates how to import and test a Svelte component (`Counter.svelte`) using `@testing-library/svelte` and `bun:test`. The test renders the component, simulates a button click, and asserts that the counter value is incremented correctly. The test imports `render` and `fireEvent` from `@testing-library/svelte`.
source: docs/guides/test/svelte-test.md#_snippet_4

language: typescript
code:
```
import { test, expect } from "bun:test";
import { render, fireEvent } from "@testing-library/svelte";
import Counter from "./Counter.svelte";

test("Counter increments when clicked", async () => {
  const { getByText, component } = render(Counter);
  const button = getByText("+1");

  // Initial state
  expect(component.$$.ctx[0]).toBe(0); // initialCount is the first prop

  // Click the increment button
  await fireEvent.click(button);

  // Check the new state
  expect(component.$$.ctx[0]).toBe(1);
});
```

---

title: Writing to Stdout Using Bun-TS
description: Demonstrates writing the contents of a file to standard output using `Bun.write()` and `Bun.stdout`. This is useful for creating command-line tools that process and output file content, similar to the `cat` command.
source: docs/guides/write-file/cat.md#_snippet_0

language: ts
code:
```
const path = "/path/to/file.txt";
const file = Bun.file(path);
await Bun.write(Bun.stdout, file);
```

---

title: Serving Streaming Responses Using Async Generator Function - TS
description: Demonstrates how to use an async generator function to stream a response in Bun. The `Bun.serve` function is used to create an HTTP server that responds with a `Response` object. The body of the `Response` is an async generator that yields strings and a `Uint8Array`, which are streamed to the client.
source: docs/guides/http/stream-iterator.md#_snippet_0

language: ts
code:
```
Bun.serve({
  port: 3000,
  fetch(req) {
    return new Response(
      // An async generator function
      async function* () {
        yield "Hello, ";
        await Bun.sleep(100);
        yield "world!";

        // you can also yield a TypedArray or Buffer
        yield new Uint8Array(["\n".charCodeAt(0)]);
      },
      { headers: { "Content-Type": "text/plain" } },
    );
  },
});
```

---

title: Serving Streaming Responses Using Async Iterable - TS
description: Illustrates how to use an async iterable directly within a `Response` object in Bun. The `Bun.serve` function creates an HTTP server that responds with data from an async iterable, defined using `Symbol.asyncIterator`. This approach allows streaming data to the client as it becomes available.
source: docs/guides/http/stream-iterator.md#_snippet_1

language: ts
code:
```
Bun.serve({
  port: 3000,
  fetch(req) {
    return new Response(
      {
        [Symbol.asyncIterator]: async function* () {
          yield "Hello, ";
          await Bun.sleep(100);
          yield "world!";
        },
      },
      { headers: { "Content-Type": "text/plain" } },
    );
  },
});
```

---

title: Writing Text to a File Using BunWrite - TypeScript
description: Demonstrates how to write text to a file using `Bun.write()`. This API efficiently writes data to disk using a destination path and the data to write.
source: docs/guides/write-file/blob.md#_snippet_0

language: typescript
code:
```
const path = "/path/to/file.txt";
await Bun.write(path, "Lorem ipsum");
```

---

title: Writing BunFile Contents to a File Using BunWrite - TypeScript
description: Illustrates how to write the contents of a `BunFile` to another file using `Bun.write()`. The `BunFile` class extends `Blob`, so you can pass a `BunFile` directly into `Bun.write()` to copy its contents to the specified path.
source: docs/guides/write-file/blob.md#_snippet_1

language: typescript
code:
```
const path = "./out.txt";
const data = Bun.file("./in.txt");

// write the contents of ./in.txt to ./out.txt
await Bun.write(path, data);
```

---

title: Copying A File - TypeScript
description: Demonstrates copying a file to another location using `Bun.write`. It reads the content of `/path/to/original.txt` using `Bun.file` and then writes it to `/path/to/copy.txt`.
source: docs/guides/write-file/file-cp.md#_snippet_0

language: typescript
code:
```
const file = Bun.file("/path/to/original.txt");
await Bun.write("/path/to/copy.txt", file);
```

---

title: Streaming a File as Response - Bun
description: Demonstrates how to create a `Response` object from a `BunFile` instance, which is obtained by reading a file using `Bun.file()`. The `BunFile` instance is directly passed to the `new Response` constructor for creating the HTTP response.
source: docs/guides/http/stream-file.md#_snippet_0

language: typescript
code:
```
const path = "/path/to/file.txt";
const file = Bun.file(path);
const resp = new Response(file);
```

---

title: Serving Static Files Using Bun Serve
description: Shows how to create a basic static file server using `Bun.serve()`.  The server fetches the file corresponding to the request's pathname using `Bun.file()` and returns it as a `Response`, handling the `Content-Type` automatically.
source: docs/guides/http/stream-file.md#_snippet_2

language: typescript
code:
```
// static file server
Bun.serve({
  async fetch(req) {
    const path = new URL(req.url).pathname;
    const file = Bun.file(path);
    return new Response(file);
  },
});
```

---

title: Deleting a File Using Bun
description: Demonstrates how to delete a file using `Bun.file(path).delete()`. It shows how to create a `Bun.file` object, delete the file, and then verify that the file no longer exists by checking `file.exists()`.
source: docs/guides/runtime/delete-file.md#_snippet_0

language: typescript
code:
```
// Delete a file
const file = Bun.file("path/to/file.txt");
await file.delete();

// Now the file doesn't exist
const exists = await file.exists();
// => false
```

---

title: Serving HTML (index.ts)
description: Defines an HTTP server using Bun that serves an HTML file (`index.html`) for the root path. It listens on port 4000 and returns a 404 status for other routes. This provides the initial setup for handling file uploads via a web form.
source: docs/guides/http/file-uploads.md#_snippet_0

language: typescript
code:
```
const server = Bun.serve({
  port: 4000,
  async fetch(req) {
    const url = new URL(req.url);

    // return index.html for root path
    if (url.pathname === "/")
      return new Response(Bun.file("index.html"), {
        headers: {
          "Content-Type": "text/html",
        },
      });

    return new Response("Not Found", { status: 404 });
  },
});

console.log(`Listening on http://localhost:${server.port}`);
```

---

title: Defining HTML Form (index.html)
description: Defines a simple HTML form with a text input for `name` and a file input for `profilePicture`. The form submits a `POST` request to the `/action` endpoint with `multipart/form-data` encoding, enabling file uploads.
source: docs/guides/http/file-uploads.md#_snippet_1

language: html
code:
```
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Form</title>
  </head>
  <body>
    <form action="/action" method="post" enctype="multipart/form-data">
      <input type="text" name="name" placeholder="Name" />
      <input type="file" name="profilePicture" />
      <input type="submit" value="Submit" />
    </form>
  </body>
</html>
```

---

title: Importing HTML File As Text - TypeScript
description: Demonstrates how to import a `.html` file as a text string in Bun using the `with { type: "text" }` attribute. This approach allows you to read the HTML content directly into a string variable, enabling further processing or manipulation. It also integrates with hot module reloading and watch mode.
source: docs/guides/runtime/import-html.md#_snippet_0

language: typescript
code:
```
import html from "./file.html" with { type: "text" };

console.log(html); // <!DOCTYPE html><html><head>...
```

---

title: Importing TOML Data in Bun
description: Demonstrates how to import a `.toml` file in Bun. The `import` statement allows direct access to TOML data as a JavaScript object.
source: docs/guides/runtime/import-toml.md#_snippet_0

language: toml
code:
```
name = "bun"
version = "1.0.0"

[author]
name = "John Dough"
email = "john@dough.com"
```

language: typescript
code:
```
import data from "./data.toml";

data.name; // => "bun"
data.version; // => "1.0.0"
data.author.name; // => "John Dough"
```

---

title: Accessing Environment Variables - TypeScript
description: Demonstrates how to access environment variables using `Bun.env` and `process.env`. Both methods provide access to the same environment variables, allowing developers to use whichever API they prefer.
source: docs/guides/runtime/set-env.md#_snippet_0

language: ts
code:
```
Bun.env.API_TOKEN; // => "secret"
process.env.API_TOKEN; // => "secret"
```

---

title: Writing to a File Incrementally - TypeScript
description: Demonstrates how to incrementally write to a file using Bun's `FileSink` API. It shows how to retrieve a `FileSink` instance from a `BunFile` object and use the `write` method to buffer data, followed by `flush` to write it to disk.
source: docs/guides/write-file/filesink.md#_snippet_0

language: typescript
code:
```
const file = Bun.file("/path/to/file.txt");
const writer = file.writer();

writer.write("lorem");
writer.write("ipsum");
writer.write("dolor");

writer.flush();

// continue writing & flushing
```

---

title: Writing a String to a File with Absolute Path - TS
description: Demonstrates writing a string to a file using an absolute path with `Bun.write()`. This method is efficient for writing data to disk when the exact location is known.
source: docs/guides/write-file/basic.md#_snippet_0

language: ts
code:
```
const path = "/path/to/file.txt";
await Bun.write(path, "Lorem ipsum");
```

---

title: Writing a String to a File with Relative Path - TS
description: Illustrates writing a string to a file using a relative path with `Bun.write()`. Relative paths are resolved based on the project root, the directory containing the `package.json` file.
source: docs/guides/write-file/basic.md#_snippet_1

language: ts
code:
```
const path = "./file.txt";
await Bun.write(path, "Lorem ipsum");
```

---

title: Importing JSON Data - TypeScript
description: Demonstrates how to import a `.json` file in Bun using a standard import statement. The imported data can then be accessed like a regular JavaScript object, allowing you to easily read and use the JSON data within your TypeScript code.
source: docs/guides/runtime/import-json.md#_snippet_0

language: json
code:
```
{
  "name": "bun",
  "version": "1.0.0",
  "author": {
    "name": "John Dough",
    "email": "john@dough.com"
  }
}
```

language: typescript
code:
```
import data from "./package.json";

data.name; // => "bun"
data.version; // => "1.0.0"
data.author.name; // => "John Dough"
```

---

title: Building a WebSocket Server with Bun
description: Demonstrates how to create a simple WebSocket server using `Bun.serve`. The `fetch` function attempts to upgrade incoming `ws:` or `wss:` requests to WebSocket connections.  It defines the `message` callback to handle incoming messages and send responses.
source: docs/guides/websocket/simple.md#_snippet_0

language: typescript
code:
```
const server = Bun.serve<{ authToken: string }>({
  fetch(req, server) {
    const success = server.upgrade(req);
    if (success) {
      // Bun automatically returns a 101 Switching Protocols
      // if the upgrade succeeds
      return undefined;
    }

    // handle HTTP request normally
    return new Response("Hello world!");
  },
  websocket: {
    // this is called when a message is received
    async message(ws, message) {
      console.log(`Received ${message}`);
      // send back a message
      ws.send(`You said: ${message}`);
    },
  },
});

console.log(`Listening on ${server.hostname}:${server.port}`);
```

---

title: Running Shell Commands with Bun
description: Demonstrates how to execute shell commands using the `$` function from the `bun` package. It shows a basic example of running `echo` and capturing its output.
source: docs/guides/runtime/shell.md#_snippet_0

language: typescript
code:
```
import { $ } from "bun";

await $`echo Hello, world!`; // => "Hello, world!"
```

---

title: Deleting Directory Recursively Using `rm` - TypeScript
description: Demonstrates how to recursively delete a directory and all its contents using the `rm` function from the `node:fs/promises` module. The `recursive: true` option enables recursive deletion, and `force: true` prevents errors if the directory does not exist. This is equivalent to the `rm -rf` command.
source: docs/guides/runtime/delete-directory.md#_snippet_0

language: typescript
code:
```
import { rm } from "node:fs/promises";

// Delete a directory and all its contents
await rm("path/to/directory", { recursive: true, force: true });
```

---

title: Building a Publish-Subscribe WebSocket Server - TS
description: Demonstrates how to create a simple single-channel chat server using Bun's built-in publish-subscribe `WebSocket` API. Sockets are subscribed to a channel using `socket.subscribe(<name>)` and messages are published using `socket.publish(<name>, <message>)`. The server rebroadcasts incoming messages to all subscribed clients.
source: docs/guides/websocket/pubsub.md#_snippet_0

language: ts
code:
```
const server = Bun.serve<{ username: string }>({
  fetch(req, server) {
    const cookies = req.headers.get("cookie");
    const username = getUsernameFromCookies(cookies);
    const success = server.upgrade(req, { data: { username } });
    if (success) return undefined;

    return new Response("Hello world");
  },
  websocket: {
    open(ws) {
      const msg = `${ws.data.username} has entered the chat`;
      ws.subscribe("the-group-chat");
      server.publish("the-group-chat", msg);
    },
    message(ws, message) {
      // the server re-broadcasts incoming messages to everyone
      server.publish("the-group-chat", `${ws.data.username}: ${message}`);
    },
    close(ws) {
      const msg = `${ws.data.username} has left the chat`;
      server.publish("the-group-chat", msg);
      ws.unsubscribe("the-group-chat");
    },
  },
});

console.log(`Listening on ${server.hostname}:${server.port}`);
```

---

title: Importing and Using Zod After Tarball Installation - TypeScript
description: Shows how to import and use the `zod` package after installing it from a tarball. Demonstrates that the package can be imported and used in TypeScript code as usual after the tarball is installed as a dependency.
source: docs/guides/install/add-tarball.md#_snippet_2

language: ts
code:
```
import { z } from "zod";
```

---

title: Adding Zod as Dependency
description: Demonstrates how to add the `zod` package as a dependency using `bun add`. This command adds the package to the `dependencies` section in `package.json` using the `^` range specifier by default.
source: docs/guides/install/add.md#_snippet_0

language: sh
code:
```
$ bun add zod
```

---

title: Importing and Using Aliased Package
description: Illustrates how to import and use a package installed under an alias. After installing `zod` as `my-custom-name`, the code imports the `z` object from `my-custom-name` and uses it to define a string schema with `z.string()`.
source: docs/guides/install/npm-alias.md#_snippet_1

language: typescript
code:
```
import { z } from "my-custom-name";

z.string();
```

---

title: Generating a Yarn-Compatible Lockfile
description: Demonstrates how to use the `--yarn` flag with `bun install` to generate a `yarn.lock` file in addition to the default `bun.lock` file. This allows Bun to interoperate with Yarn's dependency management.
source: docs/guides/install/yarnlock.md#_snippet_0

language: sh
code:
```
$ bun install --yarn
```

---

title: Encoding and Decoding Base64 Strings - Web API
description: Demonstrates the use of `btoa` to encode a string into base64 and `atob` to decode a base64 string back to its original value. This is useful for encoding data for transmission or storage where only ASCII characters are allowed.
source: docs/guides/util/base64.md#_snippet_0

language: typescript
code:
```
const data = "hello world";
const encoded = btoa(data); // => "aGVsbG8gd29ybGQ="
const decoded = atob(encoded); // => "hello world"
```

---

title: Checking if File is Entrypoint - TypeScript
description: Demonstrates how to use `import.meta.main` to determine if the current file is the entrypoint of the Bun process. This is useful for conditionally executing code based on whether the file is run directly or imported as a module.
source: docs/guides/util/entrypoint.md#_snippet_0

language: ts
code:
```
if (import.meta.main) {
  // this file is directly executed with `bun run`
} else {
  // this file is being imported by another file
}
```

---

title: Sleeping with Bun-TypeScript
description: Demonstrates using `Bun.sleep` to pause execution for a specified duration. This is useful for creating delays in asynchronous operations or simulations.
source: docs/guides/util/sleep.md#_snippet_0

language: typescript
code:
```
// sleep for 1 second
await Bun.sleep(1000);
```

---

title: Getting Absolute Path - TypeScript
description: Demonstrates how to use `import.meta.path` to get the absolute path of the current file in Bun. This is useful for resolving relative paths or determining the location of the current module.
source: docs/guides/util/import-meta-path.md#_snippet_0

language: typescript
code:
```
import.meta.path; // => "/a/b/c.ts"
```

---

title: Getting Current Directory - TypeScript
description: Demonstrates how to get the directory of the current file using `import.meta.dir`. This is useful for resolving paths relative to the current module.
source: docs/guides/util/import-meta-dir.md#_snippet_0

language: typescript
code:
```
import.meta.dir; // => "/a/b"
```

---

title: Checking for Bun Global
description: Demonstrates how to conditionally detect if code is running with `bun` by checking for the existence of the `Bun` global variable. This is analogous to checking for the `window` object in a browser environment and avoids type errors when `bun-types` isn't globally installed.
source: docs/guides/util/detect-bun.md#_snippet_0

language: typescript
code:
```
if (typeof Bun !== "undefined") {
  // this code will only run when the file is run with Bun
}
```

---

title: Detecting Bun Using Process Versions
description: Illustrates an alternative method to detect the `bun` runtime using `process.versions`. This method is particularly useful in TypeScript environments to avoid type errors when `bun-types` is not globally installed, providing a reliable way to conditionally execute code specifically within the Bun runtime.
source: docs/guides/util/detect-bun.md#_snippet_1

language: typescript
code:
```
if (process.versions.bun) {
  // this code will only run when the file is run with Bun
}
```

---

title: Extracting Links Using HTMLRewriter
description: Demonstrates how to use Bun's `HTMLRewriter` API to extract links from a webpage. It fetches the HTML content from a given URL, uses CSS selectors to find `<a>` tags with `href` attributes, and extracts the link URLs. The extracted links are then printed to the console.
source: docs/guides/html-rewriter/extract-links.md#_snippet_0

language: typescript
code:
```
async function extractLinks(url: string) {
  const links = new Set<string>();
  const response = await fetch(url);

  const rewriter = new HTMLRewriter().on("a[href]", {
    element(el) {
      const href = el.getAttribute("href");
      if (href) {
        links.add(href);
      }
    },
  });

  // Wait for the response to be processed
  await rewriter.transform(response).blob();
  console.log([...links]); // ["https://bun.com", "/docs", ...]
}

// Extract all links from the Bun website
await extractLinks("https://bun.com");
```

---

title: Adding Workspace Dependencies (package.json)
description: Demonstrates how to add dependencies between workspaces using the `workspace:*` syntax. It shows how `stuff-a` is added as a dependency of `stuff-b`, allowing `stuff-b` to import and use modules from `stuff-a`.
source: docs/guides/install/workspaces.md#_snippet_2

language: json-diff
code:
```
{
  "name": "stuff-b",
  "dependencies": {
+   "stuff-a": "workspace:*"
  }
}
```

---

title: Getting Bun Version
description: Demonstrates how to retrieve the current Bun version in semver format using `Bun.version`. This is useful for checking the installed Bun version and ensuring compatibility with specific features or dependencies.
source: docs/guides/util/version.md#_snippet_0

language: typescript
code:
```
Bun.version; // => "$BUN_LATEST_VERSION"
```

---

title: Finding Executable Path Using Bun Which
description: Demonstrates how to use `Bun.which` to find the absolute path of an executable file. It returns the path if the executable is found, and `null` if it is not.
source: docs/guides/util/which-path-to-executable-bin.md#_snippet_0

language: typescript
code:
```
Bun.which("sh"); // => "/bin/sh"
Bun.which("notfound"); // => null
Bun.which("bun"); // => "/home/user/.bun/bin/bun"
```

---

title: Generating a UUID v4 Using Crypto
description: Demonstrates how to generate a UUID v4 using the `crypto.randomUUID()` method. This API is available in Bun, Node.js, and browsers, providing a dependency-free way to create UUIDs.
source: docs/guides/util/javascript-uuid.md#_snippet_0

language: typescript
code:
```
crypto.randomUUID();
// => "123e4567-e89b-12d3-a456-426614174000"
```

---

title: Getting File Name with `import.meta.file`
description: Demonstrates how to access the current file's name using `import.meta.file`. This property is useful for resolving paths relative to the current module in Bun.
source: docs/guides/util/import-meta-file.md#_snippet_0

language: typescript
code:
```
import.meta.file; // => "c.ts"
```

---

title: Checking Deep Equality of Objects - TypeScript
description: Demonstrates how to use `Bun.deepEquals` to check if two objects have deeply equal values. This is useful for comparing complex objects where simple equality checks would fail.
source: docs/guides/util/deep-equals.md#_snippet_0

language: typescript
code:
```
const a = { a: 1, b: 2, c: { d: 3 } };
const b = { a: 1, b: 2, c: { d: 3 } };

Bun.deepEquals(a, b); // true
```

---

title: Logging Entrypoint Path Using Bun Main
description: Demonstrates how to access the absolute path of the current entrypoint using `Bun.main`. The `console.log` statement prints the path of the file that is executed with `bun run`.
source: docs/guides/util/main.md#_snippet_0

language: typescript
code:
```
console.log(Bun.main);
```

---

title: Importing and Executing a File
description: Illustrates how to import and execute a file using TypeScript. The `import "./foo.ts"` statement imports the `foo.ts` file, causing its code to be executed.
source: docs/guides/util/main.md#_snippet_1

language: typescript
code:
```
import "./foo.ts";
```

---

title: Running TypeScript Files with Bun
description: Demonstrates how to execute TypeScript files using the `bun run` command. The output shows the absolute path of the executed file, which corresponds to the `Bun.main` property.
source: docs/guides/util/main.md#_snippet_2

language: shell
code:
```
$ bun run index.ts
/path/to/index.ts
$ bun run foo.ts
/path/to/foo.ts
```

---

title: Extracting Social Metadata With HTMLRewriter - TypeScript
description: Demonstrates how to use Bun's `HTMLRewriter` API to efficiently extract social share images and Open Graph metadata from HTML content. The `extractSocialMetadata` function fetches HTML, parses it with the rewriter, extracts relevant meta tags, and converts relative image URLs to absolute URLs, providing a comprehensive social metadata object.
source: docs/guides/html-rewriter/extract-social-meta.md#_snippet_0

language: typescript
code:
```
interface SocialMetadata {
  title?: string;
  description?: string;
  image?: string;
  url?: string;
  siteName?: string;
  type?: string;
}

async function extractSocialMetadata(url: string): Promise<SocialMetadata> {
  const metadata: SocialMetadata = {};
  const response = await fetch(url);

  const rewriter = new HTMLRewriter()
    // Extract Open Graph meta tags
    .on('meta[property^="og:"]', {
      element(el) {
        const property = el.getAttribute("property");
        const content = el.getAttribute("content");
        if (property && content) {
          // Convert "og:image" to "image" etc.
          const key = property.replace("og:", "") as keyof SocialMetadata;
          metadata[key] = content;
        }
      },
    })
    // Extract Twitter Card meta tags as fallback
    .on('meta[name^="twitter:"]', {
      element(el) {
        const name = el.getAttribute("name");
        const content = el.getAttribute("content");
        if (name && content) {
          const key = name.replace("twitter:", "") as keyof SocialMetadata;
          // Only use Twitter Card data if we don't have OG data
          if (!metadata[key]) {
            metadata[key] = content;
          }
        }
      },
    })
    // Fallback to regular meta tags
    .on('meta[name="description"]', {
      element(el) {
        const content = el.getAttribute("content");
        if (content && !metadata.description) {
          metadata.description = content;
        }
      },
    })
    // Fallback to title tag
    .on("title", {
      text(text) {
        if (!metadata.title) {
          metadata.title = text.text;
        }
      },
    });

  // Process the response
  await rewriter.transform(response).blob();

  // Convert relative image URLs to absolute
  if (metadata.image && !metadata.image.startsWith("http")) {
    try {
      metadata.image = new URL(metadata.image, url).href;
    } catch {
      // Keep the original URL if parsing fails
    }
  }

  return metadata;
}
```

---

title: Hashing a Password with Argon2id
description: Demonstrates how to hash a password using the default Argon2id algorithm provided by `Bun.password.hash()`. This function provides a built-in mechanism for securely hashing passwords without third-party dependencies.
source: docs/guides/util/hash-a-password.md#_snippet_0

language: typescript
code:
```
const password = "super-secure-pa$$word";

const hash = await Bun.password.hash(password);
// => $argon2id$v=19$m=65536,t=2,p=1$tFq+9AVr1bfPxQdh6E8DQRhEXg/M/...
```

---

title: Starting the Nuxt Dev Server with Bun
description: Illustrates how to start the Nuxt development server using Bun.  The `bun --bun run dev` command executes the `nuxt dev` script defined in `package.json`, utilizing the Bun runtime to launch the development server. This command spins up a local development environment accessible via a specified port.
source: docs/guides/ecosystem/nuxt.md#_snippet_1

language: sh
code:
```
$ cd my-nuxt-app
$ bun --bun run dev
 $ nuxt dev
Nuxi 3.6.5
Nuxt 3.6.5 with Nitro 2.5.2
  > Local:    http://localhost:3000/
  > Network:  http://192.168.0.21:3000/
  > Network:  http://[fd8a:d31d:481c:4883:1c64:3d90:9f83:d8a2]:3000/

âœ” Nuxt DevTools is enabled v0.8.0 (experimental)
â„¹ Vite client warmed up in 547ms
âœ” Nitro built in 244 ms
```

---

title: Running the SolidStart Development Server
description: Demonstrates how to start the SolidStart development server using `bun run dev` or `bunx solid-start dev`. This command launches the development server, enabling hot-reloading for changes made to the project files.  It provides a live preview of the application during development.
source: docs/guides/ecosystem/solidstart.md#_snippet_2

language: sh
code:
```
$ bun run dev
# or, equivalently
$ bunx solid-start dev
```

---

title: Defining HTTP Route with Elysia
description: Illustrates defining a simple HTTP route and starting an Elysia server. The code imports the `Elysia` class, creates a new instance, defines a GET route for the root path (`/`) that returns 'Hello Elysia', and starts the server on port 8080.
source: docs/guides/ecosystem/elysia.md#_snippet_1

language: typescript
code:
```
import { Elysia } from 'elysia'

const app = new Elysia()
	.get('/', () => 'Hello Elysia')
	.listen(8080)

console.log(`[U+1F98A] Elysia is running at on port ${app.server?.port}...`)
```

---

title: Starting Application Using PM2 With Interpreter
description: Starts an application using `pm2` with `bun` specified as the interpreter. This command utilizes the `--interpreter` option to execute the `index.ts` file with Bun, ensuring the application runs as a daemon.
source: docs/guides/ecosystem/pm2.md#_snippet_0

language: bash
code:
```
pm2 start --interpreter ~/.bun/bin/bun index.ts
```

---

title: Starting Application Using PM2 With Configuration File
description: Demonstrates starting an application managed by `pm2` using a configuration file. This command instructs `pm2` to read and apply the settings defined in `pm2.config.js` to manage the application as a daemon process.
source: docs/guides/ecosystem/pm2.md#_snippet_2

language: bash
code:
```
pm2 start pm2.config.js
```

---

title: Defining an Express Server with Bun
description: Demonstrates how to create a simple Express server using Bun. The `express` library is used to define routes, and the server listens on a specified port (or 3001 if `process.env.PORT` is not defined). This server responds with 'Hello World!' on the root route.
source: docs/guides/ecosystem/render.md#_snippet_0

language: typescript
code:
```
import express from "express";

const app = express();
const port = process.env.PORT || 3001;

app.get("/", (req, res) => {
  res.send(
```

---

title: Specifying a Starter Template
description: Illustrates how to use the `--example` flag with `bun create next-app` to specify a starter template. This allows you to quickly set up a Next.js project with pre-configured features and dependencies.
source: docs/guides/ecosystem/nextjs.md#_snippet_1

language: sh
code:
```
$ bun create next-app --example with-supabase
âœ” What is your project named? ... my-app
...
```

---

title: Starting the Remix Dev Server
description: Illustrates how to start the Remix development server using `bun run dev`. This command executes the `remix dev` script, which builds the application and starts a development server.  It enables hot-reloading for rapid development cycles.
source: docs/guides/ecosystem/remix.md#_snippet_1

language: sh
code:
```
$ cd my-app
$ bun run dev
  $ remix dev

  [U+1F4BF]  remix dev

  info  building...
  info  built (263ms)
  Remix App Server started at http://localhost:3000 (http://172.20.0.143:3000)
```

---

title: Creating a Simple HTTP Server - TypeScript
description: Illustrates creating a basic HTTP server using StricJS with the `@stricjs/router` package. The `Router` instance is configured to respond with 'Hi' to GET requests on the root path ('/'). This provides a minimal example for setting up a StricJS server.
source: docs/guides/ecosystem/stric.md#_snippet_1

language: typescript
code:
```
import { Router } from '@stricjs/router';

export default new Router()
  .get('/', () => new Response('Hi'));
```

---

title: Initializing Sentry With the Bun SDK - JavaScript
description: Illustrates how to initialize the Sentry SDK in a Bun application using `Sentry.init()`. The `dsn` option configures the connection to your Sentry project, and `tracesSampleRate` enables performance monitoring. This initialization should occur before any other modules are imported to ensure comprehensive error capture.
source: docs/guides/ecosystem/sentry.md#_snippet_1

language: javascript
code:
```
import * as Sentry from "@sentry/bun";

// Ensure to call this before importing any other modules!
Sentry.init({
  dsn: "__SENTRY_DSN__",

  // Add Performance Monitoring by setting tracesSampleRate
  // We recommend adjusting this value in production
  tracesSampleRate: 1.0,
});
```

---

title: Defining an HTTP Route and Starting a Server with Express
description: Demonstrates how to define a simple HTTP route using Express and start a server. The code imports the `express` module, creates an Express application, defines a route for the root path (`/`) that sends a 'Hello World!' response, and starts the server on port 8080.
source: docs/guides/ecosystem/express.md#_snippet_1

language: typescript
code:
```
import express from "express";

const app = express();
const port = 8080;

app.get("/", (req, res) => {
  res.send("Hello World!");
});

app.listen(port, () => {
  console.log(`Listening on port ${port}...`);
});
```

---

title: Bundling with Build-Time Constants
description: Demonstrates bundling with build-time constants using the `bun build` command. It sets the `BUILD_VERSION` and `NODE_ENV` variables during the build process, which can then be accessed within the bundled application.
source: docs/guides/runtime/build-time-constants.md#_snippet_0

language: sh
code:
```
# Bundle with build-time constants
$ bun build --define BUILD_VERSION='"1.0.0"' --define NODE_ENV='"production"' src/index.ts --outdir ./dist
```

---

title: Compiling with Build-Time Constants
description: Illustrates compiling to an executable with build-time constants using `bun build --compile`. It defines `BUILD_VERSION` and `BUILD_TIME` to embed these values directly into the compiled binary, eliminating runtime overhead.
source: docs/guides/runtime/build-time-constants.md#_snippet_1

language: sh
code:
```
# Compile to executable with build-time constants
$ bun build --compile --define BUILD_VERSION='"1.0.0"' --define BUILD_TIME='"2024-01-15T10:30:00Z"' src/cli.ts --outfile mycli
```

---

title: Starting the Astro Dev Server with Bun
description: Illustrates starting the Astro development server using `bunx`.  The `--bun` flag is used to specify that the Bun runtime should be used instead of Node.js. This allows developers to leverage Bun's performance and features during development.
source: docs/guides/ecosystem/astro.md#_snippet_1

language: sh
code:
```
$ bunx --bun astro dev
  [U+1F680]  astro  v3.1.4 started in 200ms

  â”ƒ Local    http://localhost:4321/
  â”ƒ Network  use --host to expose
```

---

title: Starting the Development Server
description: Illustrates how to start the SvelteKit development server using `bun --bun run dev`. This command launches the application, making it accessible in a web browser for development and testing. The `--bun` flag specifies that Bun should be used as the runtime.
source: docs/guides/ecosystem/sveltekit.md#_snippet_1

language: sh
code:
```
$ cd my-app
$ bun --bun run dev
  $ vite dev
  Forced re-optimization of dependencies

    VITE v5.4.10  ready in 424 ms

    âžœ  Local:   http://localhost:5173/
    âžœ  Network: use --host to expose
    âžœ  press h + enter to show help
```

---

title: Initializing Prisma Schema and Migration Directory -Bash
description: Demonstrates initializing the Prisma schema and migration directory using the Prisma CLI with `bunx`.  The command `bunx --bun prisma init --datasource-provider sqlite` sets up a basic Prisma project structure with SQLite as the datasource provider, creating the `prisma/schema.prisma` file and related configuration.
source: docs/guides/ecosystem/prisma.md#_snippet_2

language: bash
code:
```
$ bunx --bun prisma init --datasource-provider sqlite
```

---

title: Creating and Counting Users -Typescript
description: Illustrates how to use the Prisma client to create a new user and count the total number of users in the database. It first imports `PrismaClient` and instantiates it. It then uses `prisma.user.create` to create a new user with a dynamically generated email and `prisma.user.count` to get the number of users, logging the count to the console. This snippet depends on the import statement from the previous section.
source: docs/guides/ecosystem/prisma.md#_snippet_7

language: typescript
code:
```
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

// create a new user
await prisma.user.create({
  data: {
    name: "John Dough",
    email: `john-${Math.random()}@example.com`,
  },
});

// count the number of users
const count = await prisma.user.count();
console.log(`There are ${count} users in the database.`);
```

---

title: Building a Basic HTTP Server with Hono - TS
description: Demonstrates how to create a simple HTTP server using Hono. The code imports the `Hono` class, creates a new app instance, defines a route for the root path (`/`) that returns the text 'Hono!', and exports the app instance.
source: docs/guides/ecosystem/hono.md#_snippet_0

language: ts
code:
```
import { Hono } from "hono";
const app = new Hono();

app.get("/", c => c.text("Hono!"));

export default app;
```

---

title: Starting the Development Server with Bun
description: Demonstrates how to start the Hono development server using Bun. The `bun run dev` command starts the development server, typically on `localhost:3000`.
source: docs/guides/ecosystem/hono.md#_snippet_2

language: sh
code:
```
$ bun run dev
```

---

title: Creating Blob From ArrayBuffer
description: Demonstrates how to create a `Blob` from an `ArrayBuffer`. The `Blob` constructor takes an array of chunks, which can include binary data structures like `ArrayBuffer`.
source: docs/guides/binary/arraybuffer-to-blob.md#_snippet_0

language: typescript
code:
```
const buf = new ArrayBuffer(64);
const blob = new Blob([buf]);
```

---

title: Importing and Using Discord.js
description: Illustrates how to import the `discord.js` library and create a Discord client. It then logs into Discord using the token retrieved from the environment variables.
source: docs/guides/ecosystem/discordjs.md#_snippet_3

language: ts
code:
```
// import discord.js
import {Client, Events, GatewayIntentBits} from 'discord.js';

// create a new Client instance
const client = new Client({intents: [GatewayIntentBits.Guilds]});

// listen for the client to be ready
client.once(Events.ClientReady, (c) => {
  console.log(`Ready! Logged in as ${c.user.tag}`);
});

// login with the token from .env.local
client.login(process.env.DISCORD_TOKEN);
```

---

title: Running Discord Bot
description: Shows how to execute the Discord bot using `bun run`. This command starts the bot and connects it to the Discord service.
source: docs/guides/ecosystem/discordjs.md#_snippet_4

language: sh
code:
```
$ bun run bot.ts
Ready! Logged in as my-bot#1234
```

---

title: Using Animal Model with Mongoose and MongoDB (index.ts)
description: Demonstrates how to connect to MongoDB using Mongoose, create a new `Animal` document based on the schema defined in `schema.ts`, save it to the database, and then retrieve and use it. It also shows how to disconnect from the database after operations are complete, and ties the import statements to the usage of those imported items.
source: docs/guides/ecosystem/mongoose.md#_snippet_1

language: typescript
code:
```
import * as mongoose from 'mongoose';
import {Animal} from './schema';

// connect to database
await mongoose.connect('mongodb://127.0.0.1:27017/mongoose-app');

// create new Animal
const cow = new Animal({
  name: 'Cow',
  sound: 'Moo',
});
await cow.save(); // saves to the database

// read all Animals
const animals = await Animal.find();
animals[0].speak(); // logs "Moo!"

// disconnect
await mongoose.disconnect();
```

---

title: Starting the Vite Development Server with Bun
description: Demonstrates how to start the Vite development server using `bunx`.  The `--bun` flag ensures that Vite's CLI is executed using `bun` instead of `node`, respecting the shebang line.
source: docs/guides/ecosystem/vite.md#_snippet_2

language: bash
code:
```
bunx --bun vite
```

---

title: Running PackageJson Scripts Faster
description: These commands show how to run scripts defined in `package.json`, executables from `node_modules/.bin`, and JavaScript/TypeScript files using the `bun` command.  It streamlines the execution of common tasks, providing a unified interface.
source: docs/guides/install/from-npm-install-to-bun-install.md#_snippet_1

language: sh
code:
```
# Run a package.json script:
$ bun my-script
$ bun run my-script

# Run an executable in node_modules/.bin:
$ bun my-executable # such as tsc, esbuild, etc.
$ bun run my-executable

# Run a JavaScript/TypeScript file:
$ bun ./index.ts
```

---

title: Running Neon Example - Shell
description: Illustrates how to start the program using `bun ./index.ts`, which executes the code and prints the Postgres version to the console. This verifies the successful connection and query execution against the Neon database.
source: docs/guides/ecosystem/neon-serverless-postgres.md#_snippet_3

language: shell
code:
```
$ bun ./index.ts
PostgreSQL 16.2 on x86_64-pc-linux-gnu, compiled by gcc (Debian 10.2.1-6) 10.2.1 20210110, 64-bit
```

---

title: Converting Uint8Array To String - TextDecoder
description: Demonstrates how to convert a `Uint8Array` to a string using `TextDecoder`. This is useful when working with binary data and needing to represent it as a human-readable string.
source: docs/guides/binary/typedarray-to-string.md#_snippet_0

language: typescript
code:
```
const arr = new Uint8Array([104, 101, 108, 108, 111]);
const decoder = new TextDecoder();
const str = decoder.decode(arr);
// => "hello"
```

---

title: Converting Uint8Array to Buffer - TypeScript
description: Demonstrates how to convert a `Uint8Array` to a `Buffer` using `Buffer.from()`. This is useful when you need to use `Buffer` specific methods on binary data originally in `Uint8Array` format.
source: docs/guides/binary/typedarray-to-buffer.md#_snippet_0

language: typescript
code:
```
const arr: Uint8Array = ...
const buf = Buffer.from(arr);
```

---

title: Converting Blob to String - TypeScript
description: Demonstrates how to convert a `Blob` object to a string using the `.text()` method. This is useful for reading the textual content of a `Blob` object.
source: docs/guides/binary/blob-to-string.md#_snippet_0

language: typescript
code:
```
const blob = new Blob(["hello world"]);
const str = await blob.text();
// => "hello world"
```

---

title: Converting Uint8Array to Blob
description: Demonstrates how to create a `Blob` from a `Uint8Array`. The `Blob` constructor accepts an array of chunks, including `Uint8Array` instances, which are then combined into a single `Blob` object. This allows for easy manipulation and handling of binary data in web applications.
source: docs/guides/binary/typedarray-to-blob.md#_snippet_0

language: ts
code:
```
const arr = new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f]);
const blob = new Blob([arr]);
console.log(await blob.text());
// => "hello"
```

---

title: Converting Buffer to String - NodeJS
description: Demonstrates how to convert a `Buffer` object to a string using the `.toString()` method. The `Buffer.from()` method creates a new Buffer containing the provided string, and the `.toString()` method converts the buffer's contents into a string.
source: docs/guides/binary/buffer-to-string.md#_snippet_0

language: ts
code:
```
const buf = Buffer.from("hello");
const str = buf.toString();
// => "hello"
```

---

title: Understanding Buffer Instanceof Uint8Array - Typescript
description: Demonstrates that the Node.js `Buffer` class is an instance of `Uint8Array`. This means that `Buffer` objects can be used directly as `Uint8Array` objects without explicit conversion, providing access to all `Uint8Array` properties and methods.
source: docs/guides/binary/buffer-to-typedarray.md#_snippet_0

language: ts
code:
```
const buf = Buffer.alloc(64);
buf instanceof Uint8Array; // => true
```

---

title: Running Bun App in Docker Container
description: Demonstrates how to run a Docker image in a container using the `docker run` command. The `-d` flag runs the container in detached mode, and the `-p` flag maps port 3000 on the host machine to port 3000 on the container. This allows accessing the Bun application running inside the container.
source: docs/guides/ecosystem/docker.md#_snippet_3

language: sh
code:
```
$ docker run -d -p 3000:3000 bun-hello-world
7f03e212a15ede8644379bce11a13589f563d3909a9640446c5bbefce993678d
```

---

title: Converting ArrayBuffer to Buffer - TypeScript
description: Demonstrates how to create a Node.js `Buffer` from an `ArrayBuffer` using the `Buffer.from()` method. This allows interoperability between Node.js APIs that expect `Buffer` and modern JavaScript APIs that use `ArrayBuffer`.
source: docs/guides/binary/arraybuffer-to-buffer.md#_snippet_0

language: typescript
code:
```
const arrBuffer = new ArrayBuffer(64);
const nodeBuffer = Buffer.from(arrBuffer);
```

---

title: Connecting to SQLite with Drizzle and Bun
description: Illustrates how to establish a connection to a SQLite database using the `bun:sqlite` module and Drizzle ORM. It creates a new database instance and exports it for use in other modules.
source: docs/guides/ecosystem/drizzle.md#_snippet_1

language: ts
code:
```
import { drizzle } from "drizzle-orm/bun-sqlite";
import { Database } from "bun:sqlite";

const sqlite = new Database("sqlite.db");
export const db = drizzle(sqlite);
```

---

title: Updating Dependencies with Bun
description: Demonstrates how to update dependencies using the `bun update` command. The first example updates all dependencies, while the second updates a specific package.
source: docs/cli/update.md#_snippet_0

language: shell
code:
```
$ bun update
```

language: shell
code:
```
$ bun update [package]
```

---

title: Removing a Dependency - Bun CLI
description: Demonstrates how to remove a dependency using the Bun CLI. The command `bun remove ts-node` uninstalls the `ts-node` package from the project.
source: docs/cli/remove.md#_snippet_0

language: bash
code:
```
$ bun remove ts-node
```

---

title: Seeding EdgeDB with Data - TypeScript
description: Illustrates how to insert data into EdgeDB using the JavaScript client. It imports `createClient` from the `edgedb` library and defines an EdgeQL query (`INSERT_MOVIE`) that uses a `for` expression for optimized bulk insertion. The client auto-connects to the database, and the `.execute()` method runs the query with the provided movie data.
source: docs/guides/ecosystem/edgedb.md#_snippet_7

language: ts
code:
```
import { createClient } from "edgedb";

const client = createClient();

const INSERT_MOVIE = `
  with movies := <array<tuple<title: str, year: int64>>>$movies
  for movie in array_unpack(movies) union (
    insert Movie {
      title := movie.title,
      releaseYear := movie.year,
    }
  )
`;

const movies = [
  { title: "The Matrix", year: 1999 },
  { title: "The Matrix Reloaded", year: 2003 },
  { title: "The Matrix Revolutions", year: 2003 },
];

await client.execute(INSERT_MOVIE, { movies });

console.log(`Seeding complete.`);
process.exit();
```

---

title: Checking Package Installation Reasons with Bun
description: Demonstrates the basic usage of the `bun why` command to determine why a specific package is installed in the project by displaying the dependency chain.
source: docs/cli/why.md#_snippet_0

language: bash
code:
```
$ bun why <package>
```

---

title: Running a File with Bun
description: Demonstrates how to execute JavaScript, TypeScript, and JSX files using `bun run`. The code snippets show examples of running different file types and using the `--watch` flag for watch mode.
source: docs/cli/run.md#_snippet_0

language: bash
code:
```
$ bun run index.js
$ bun run index.jsx
$ bun run index.ts
$ bun run index.tsx
```

language: bash
code:
```
$ bun index.tsx
$ bun index.js
```

language: bash
code:
```
$ bun --watch run index.tsx
```

---

title: Running a Package JSON Script
description: Illustrates how to define and execute scripts from a `package.json` file using `bun run`. The example shows a `package.json` file with defined scripts and the corresponding `bun run` command to execute those scripts.
source: docs/cli/run.md#_snippet_1

language: json
code:
```
{
  // ... other fields
  "scripts": {
    "clean": "rm -rf dist && echo 'Done.'",
    "dev": "bun server.ts"
  }
}
```

language: bash
code:
```
$ bun run clean
 $ rm -rf dist && echo 'Done.'
 Cleaning...
 Done.
```

language: bash
code:
```
$ bun run dev
```

---

title: Linking a Local Package to a Project
description: Illustrates how to link a locally registered package into another project using `bun link`. This creates a symlink in the target project's `node_modules` directory, pointing to the local package directory, which ensures that changes made to the local package are immediately reflected in the target project.
source: docs/cli/link.md#_snippet_1

language: bash
code:
```
$ cd /path/to/my-app
$ bun link cool-pkg
```

---

title: Verifying `NODE_ENV` Is Set in Tests - TypeScript
description: Demonstrates how `bun test` automatically sets the `$NODE_ENV` environment variable to `test`. The test asserts that `process.env.NODE_ENV` is indeed set to `test` within the test environment.
source: docs/test/runtime-behavior.md#_snippet_0

language: typescript
code:
```
import { test, expect } from "bun:test";

test("NODE_ENV is set to test", () => {
  expect(process.env.NODE_ENV).toBe("test");
});
```

---

title: Publishing Package to npm Registry
description: Demonstrates how to publish a package to the npm registry using `bun publish`. The first example shows publishing from the current working directory, while the second packs the package and publishes the tarball.
source: docs/cli/publish.md#_snippet_0

language: sh
code:
```
## Publishing the package from the current working directory
$ bun publish

## Output
bun publish v$BUN_LATEST_VERSION (ca7428e9)

packed 203B package.json
packed 224B README.md
packed 30B index.ts
packed 0.64KB tsconfig.json

Total files: 4
Shasum: 79e2b4377b63f4de38dc7ea6e5e9dbee08311a69
Integrity: sha512-6QSNlDdSwyG/+[...]X6wXHriDWr6fA==
Unpacked size: 1.1KB
Packed size: 0.76KB
Tag: latest
Access: default
Registry: http://localhost:4873/

 + publish-1@1.0.0
```

language: sh
code:
```
$ bun pm pack
...
$ bun publish ./package.tgz
```

---

title: Initializing Drizzle with Neon Serverless Driver
description: Demonstrates initializing a Drizzle database instance using the Neon serverless driver.  The `neon` function creates a connection to Neon using the `DATABASE_URL` environment variable, and then `drizzle` wraps the connection for use with Drizzle ORM.
source: docs/guides/ecosystem/neon-drizzle.md#_snippet_2

language: ts
code:
```
import { neon } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-http';

// Bun automatically loads the DATABASE_URL from .env.local
// Refer to: https://bun.com/docs/runtime/env for more information
const sql = neon(process.env.DATABASE_URL!);

export const db = drizzle(sql);
```

---

title: Running Packages with Bunx
description: Demonstrates how to execute packages using `bunx`, Bun's equivalent to `npx` or `yarn dlx`. It auto-installs and runs packages from `npm`.
source: docs/cli/bunx.md#_snippet_0

language: bash
code:
```
$ bunx cowsay "Hello world!"
```

---

title: Viewing Package Metadata with Bun Info
description: Demonstrates how to use `bun info` to retrieve metadata for a specified npm package. This includes details like version, description, homepage, and dependencies.  The command is useful for quickly inspecting package details directly from the command line.
source: docs/cli/info.md#_snippet_0

language: bash
code:
```
$ bun info react
```

---

title: Querying Specific Package Properties Using Bun Info
description: Demonstrates how to use `bun info` to query for specific properties from the package metadata. This is useful for quickly accessing information like `version`, `dependencies`, or `repository.url` without retrieving the entire metadata object.
source: docs/cli/info.md#_snippet_2

language: bash
code:
```
$ bun info react version
$ bun info react dependencies
$ bun info react repository.url
```

---

title: Using Snapshot Testing with Bun
description: Demonstrates how to perform snapshot testing using Bun's `test` and `expect` APIs. The code initializes a test case that uses `toMatchSnapshot()` to serialize and store the expected output in a `__snapshots__` directory for future comparisons, ensuring consistency across test runs.
source: docs/test/snapshots.md#_snippet_0

language: ts
code:
```
import { test, expect } from "bun:test";

test("snap", () => {
  expect("foo").toMatchSnapshot();
});
```

---

title: Implementing Inline Snapshots in Bun
description: Demonstrates how to use inline snapshots with `.toMatchInlineSnapshot()` in Bun.  The first time the test runs, Bun will automatically insert the snapshot directly into the test file. Subsequent test runs compare the value against the inline snapshot.
source: docs/test/snapshots.md#_snippet_2

language: ts
code:
```
import { test, expect } from "bun:test";

test("inline snapshot", () => {
  // First run: snapshot will be inserted automatically
  expect({ hello: "world" }).toMatchInlineSnapshot();

  // After first run, the test file will be updated to:
  // expect({ hello: "world" }).toMatchInlineSnapshot(`
  //   {
  //     "hello": "world",
  //   }
  // `);
});
```

---

title: Specifying Exact Test File Paths - Bash
description: Illustrates how to run a specific test file using `bun test` by providing its exact path.  The path must start with `./` or `/` to distinguish it from a filter name. This is useful for running a single test file during development or debugging.
source: docs/test/discovery.md#_snippet_1

language: bash
code:
```
$ bun test ./test/specific-file.test.ts
```

---

title: Using Assertions Count in Tests
description: Demonstrates how to use `expect.assertions(count)` to ensure that a specific number of assertions are called within a test. This is useful for asynchronous tests to verify that assertions are actually executed. It helps prevent false positives when tests complete without running all expected checks.
source: docs/test/writing.md#_snippet_0

language: ts
code:
```
test("exactly two assertions", () => {
  expect.assertions(2); // Will fail if not exactly 2 assertions are called

  expect(1 + 1).toBe(2);
  expect("hello").toContain("ell");
});
```

---

title: Restoring Function Mocks - Bun
description: Illustrates how to restore all function mocks using `mock.restore()` in Bun's testing environment. This method resets mocks to their original implementations, reducing test code by placing it in `afterEach` blocks or test preload code.
source: docs/test/mocks.md#_snippet_0

language: ts
code:
```
import { expect, mock, spyOn, test } from "bun:test";

import * as fooModule from "./foo.ts";
import * as barModule from "./bar.ts";
import * as bazModule from "./baz.ts";

test("foo, bar, baz", () => {
  const fooSpy = spyOn(fooModule, "foo");
  const barSpy = spyOn(barModule, "bar");
  const bazSpy = spyOn(bazModule, "baz");

  expect(fooSpy).toBe("foo");
  expect(barSpy).toBe("bar");
  expect(bazSpy).toBe("baz");

  fooSpy.mockImplementation(() => 42);
  barSpy.mockImplementation(() => 43);
  bazSpy.mockImplementation(() => 44);

  expect(fooSpy).toBe(42);
  expect(barSpy).toBe(43);
  expect(bazSpy).toBe(44);

  mock.restore();

  expect(fooSpy).toBe("foo");
  expect(barSpy).toBe("bar");
  expect(bazSpy).toBe("baz");
});
```

---

title: Creating a React Component Project
description: Demonstrates how to create a new React project from an existing React component using `bun create`. This command analyzes the component's dependencies, generates necessary files like `package.json`, HTML, and CSS, and starts a frontend development server for hot reloading and production builds.
source: docs/cli/bun-create.md#_snippet_0

language: bash
code:
```
$ bun create ./MyComponent.jsx # .tsx also supported
```

---

title: Creating a Project from npm
description: Demonstrates how to create a new project from an npm template using `bun create`. This command downloads and executes the `create-<template>` package from npm, providing a convenient way to bootstrap projects using community-created templates. It shows how it aliases to `bunx create-<template>`.
source: docs/cli/bun-create.md#_snippet_3

language: sh
code:
```
$ bun create <template> [<destination>]
```

language: sh
code:
```
$ bun create remix
$ bunx create-remix
```

---

title: Creating a Project From GitHub
description: Illustrates creating a new project from a GitHub repository using `bun create`. The command downloads the contents of the specified GitHub repo, copies the files to the destination folder, installs dependencies using `bun install`, and initializes a Git repository.
source: docs/cli/bun-create.md#_snippet_4

language: bash
code:
```
$ bun create <user>/<repo>
$ bun create github.com/<user>/<repo>
```

language: bash
code:
```
$ bun create <user>/<repo> mydir
$ bun create github.com/<user>/<repo> mydir
```

---

title: Adding a Package Using Bun
description: Illustrates how to add a package to a project using the `bun add` command. This command installs the specified package and updates the `package.json` file.
source: docs/cli/add.md#_snippet_0

language: bash
code:
```
$ bun add preact
```

---

title: Specifying Package Version with Bun
description: Demonstrates how to specify a version, version range, or tag when adding a package using the `bun add` command. This allows for precise control over the installed package version.
source: docs/cli/add.md#_snippet_1

language: bash
code:
```
$ bun add zod@3.20.0
$ bun add zod@^3.0.0
$ bun add zod@latest
```

---

title: Writing a DOM Test - TypeScript
description: Demonstrates a basic DOM test using `happy-dom` with Bun's test runner. The test creates a button element in the `document.body`, queries for the button, and asserts that its `innerText` is correct. This tests verifies `happy-dom` is correctly simulating a browser environment.
source: docs/test/dom.md#_snippet_2

language: ts
code:
```
import {test, expect} from 'bun:test';

test('dom test', () => {
  document.body.innerHTML = `<button>My button</button>`;
  const button = document.querySelector('button');
  expect(button?.innerText).toEqual('My button');
});
```

---

title: Performing Per-Test Setup and Teardown - Bun
description: Demonstrates how to use `beforeEach` and `afterEach` hooks from the `bun:test` module to execute code before and after each test. This is useful for setting up the environment for each test and cleaning up afterward.
source: docs/test/lifecycle.md#_snippet_0

language: typescript
code:
```
import { beforeEach, afterEach } from "bun:test";

beforeEach(() => {
  console.log("running test.");
});

afterEach(() => {
  console.log("done with test.");
});

// tests...
```

---

title: Mocking a Function with Bun Test
description: Demonstrates how to create a mock function using `mock` from `bun:test`. The mocked function `random` replaces the original implementation with a mock, allowing you to track calls and control its behavior during testing.
source: docs/test/mocks.md#_snippet_0

language: typescript
code:
```
import { test, expect, mock } from "bun:test";
const random = mock(() => Math.random());

test("random", async () => {
  const val = random();
  expect(val).toBeGreaterThan(0);
  expect(random).toHaveBeenCalled();
  expect(random).toHaveBeenCalledTimes(1);
});
```

---

title: Using Jest's `fn` Function for Mocking
description: Illustrates using `jest.fn()` from `bun:test` as an alternative to `mock()`.  `jest.fn()` behaves identically to `mock()`, providing a familiar API for those accustomed to Jest.
source: docs/test/mocks.md#_snippet_1

language: typescript
code:
```
import { test, expect, jest } from "bun:test";
const random = jest.fn(() => Math.random());

test("random", async () => {
  const val = random();
  expect(val).toBeGreaterThan(0);
  expect(random).toHaveBeenCalled();
  expect(random).toHaveBeenCalledTimes(1);
});
```

---

title: Serving a Response with Bun Serve
description: Demonstrates the basic usage of `Bun.serve` to create an HTTP server. The server responds with the text "Success!" to every request.
source: docs/runtime/bun-apis.md#_snippet_0

language: typescript
code:
```
Bun.serve({
  fetch(req: Request) {
    return new Response("Success!");
  },
});
```

---

title: Rendering React Components-TSX
description: Demonstrates how to define and render a React component using JSX syntax within a TypeScript file. The `Component` function takes a `message` prop and renders a heading with the message. The `console.log` statement then renders the component to the console.
source: docs/runtime/loaders.md#_snippet_0

language: tsx
code:
```
function Component(props: {message: string}) {
  return (
    <body>
      <h1 style={{color: 'red'}}>{props.message}</h1>
    </body>
  );
}

console.log(<Component message="Hello world!" />);
```

---

title: Testing with Bun
description: Demonstrates a basic test using `bun:test` to check if `2 + 2` equals `4`. It utilizes the `expect` and `test` functions from Bun's test runner, similar to Jest.
source: docs/cli/test.md#_snippet_0

language: typescript
code:
```
import { expect, test } from "bun:test";

test("2 + 2", () => {
  expect(2 + 2).toBe(4);
});
```

---

title: Importing and Using Modules - TypeScript
description: Demonstrates importing a module named `data` and accessing its exported variable `foo`. The code showcases Bun's ability to resolve the module based on the path mappings defined in `tsconfig.json`, correctly importing and using the `foo` variable.
source: docs/runtime/typescript.md#_snippet_1

language: typescript
code:
```
import { foo } from "data";
console.log(foo); // => "Hello world!"
```

language: typescript
code:
```
export const foo = "Hello world!"
```

---

title: Installing Dependencies
description: Demonstrates how to install all dependencies for a project using `bun install`. This command installs `dependencies`, `devDependencies`, and `optionalDependencies`, runs project lifecycle scripts, and writes a `bun.lock` lockfile.
source: docs/cli/install.md#_snippet_0

language: bash
code:
```
$ bun install
```

---

title: Using Bun CI for Reproducible Builds - Bash
description: Explains how to use `bun ci` to enforce reproducible builds in CI/CD environments. This command fails the build if the `package.json` is out of sync with the lockfile, ensuring consistency.
source: docs/cli/install.md#_snippet_17

language: bash
code:
```
$ bun ci
```

---

title: Using Bun CI in GitHub Actions - YAML
description: Demonstrates how to replace `bun install` with `bun ci` in a GitHub Actions workflow. This ensures that the build fails if the `package.json` does not match the `bun.lock` file, promoting reproducible builds.
source: docs/cli/install.md#_snippet_18

language: yaml
code:
```
name: bun-types
jobs:
  build:
    name: build-app
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
      - name: Install bun
        uses: oven-sh/setup-bun@v2
      - name: Install dependencies
        run: bun ci
      - name: Build app
        run: bun run build
```

---

title: Running TypeScript - CLI
description: Demonstrates how Bun can execute TypeScript files directly from the command line. This eliminates the need for a separate compilation step, simplifying the development workflow.
source: docs/runtime/index.md#_snippet_0

language: bash
code:
```
$ bun index.js
$ bun index.jsx
$ bun index.ts
$ bun index.tsx
```

---

title: Reading Output as JSON - JavaScript
description: Demonstrates how to parse the output of a shell command as a JSON object using the `.json()` method in Bun. This is useful for interacting with command-line tools that produce JSON output and using the data in your JavaScript code.
source: docs/runtime/shell.md#_snippet_0

language: javascript
code:
```
import { $ } from "bun";

const result = await $`echo '{"foo": "bar"}'`.json();

console.log(result); // { foo: "bar" }
```

---

title: Reading Output Line by Line - JavaScript
description: Illustrates how to read the output of a shell command line by line using the `.lines()` method in Bun. This is useful for processing streaming output or when you need to handle each line of output individually.
source: docs/runtime/shell.md#_snippet_1

language: javascript
code:
```
import { $ } from "bun";

for await (let line of $`echo "Hello World!"`.lines()) {
  console.log(line); // Hello World!
}
```

---

title: Running Shell Scripts With Bun Shell
description: Demonstrates how to execute shell scripts (``.sh`` files) directly using `bun`. This provides a cross-platform way to run shell commands.
source: docs/runtime/shell.md#_snippet_7

language: shell
code:
```
echo "Hello World! pwd=$(pwd)"
```

---

title: Executing .sh Files With Bun
description: Illustrates executing a shell script using `bun`. The script prints a greeting and the current working directory.
source: docs/runtime/shell.md#_snippet_8

language: shell
code:
```
$ bun ./script.sh
Hello World! pwd=/home/demo
```

---

title: Running Shell Scripts Cross-Platform
description: Demonstrates running a shell script on Windows using `bun`. The script prints a greeting and the current working directory, showcasing cross-platform compatibility.
source: docs/runtime/shell.md#_snippet_9

language: powershell
code:
```
> bun .\script.sh
Hello World! pwd=C:\Users\Demo
```

---

title: Packing a Package for Publishing
description: Demonstrates the basic usage of `bun pm pack` to create a `.tgz` archive of the current project, which is suitable for publishing to a package registry like npm. This command follows the same rules as `npm pack` for determining which files to include in the tarball.
source: docs/cli/pm.md#_snippet_0

language: bash
code:
```
$ bun pm pack
# Creates my-package-1.0.0.tgz in current directory
```

---

title: Serving a Web Server
description: Demonstrates how to serve a simple web server using `Bun.serve`. The `fetch` function logs the request URL and returns a "Hello, world!" response.
source: docs/runtime/debugger.md#_snippet_0

language: typescript
code:
```
Bun.serve({
  fetch(req){
    console.log(req.url);
    return new Response("Hello, world!");
  }
})
```

---

title: Defining Plugin Structure for Bun
description: Demonstrates the basic structure of a Bun plugin, including the `name` and `setup` properties. The `setup` function receives a `build` object, which is used to register lifecycle hooks.
source: docs/runtime/plugins.md#_snippet_0

language: typescript
code:
```
namespace Bun {
  function plugin(plugin: {
    name: string;
    setup: (build: PluginBuilder) => void;
  }): void;
}

type PluginBuilder = {
  onStart(callback: () => void): void;
  onResolve: (
    args: { filter: RegExp; namespace?: string },
    callback: (args: { path: string; importer: string }) => {
      path: string;
      namespace?: string;
    } | void,
  ) => void;
  onLoad: (
    args: { filter: RegExp; namespace?: string },
    callback: (args: { path: string }) => {
      loader?: Loader;
      contents?: string;
      exports?: Record<string, any>;
    },
  ) => void;
  config: BuildConfig;
};

type Loader = "js" | "jsx" | "ts" | "tsx" | "css" | "json" | "toml" | "object";
```

---

title: Using Fetch API
description: Demonstrates using the `fetch` API to make a simple HTTP request. This is a web standard API supported by Bun for making network requests.
source: docs/runtime/index.md#_snippet_0

language: javascript
code:
```
fetch("https://example.com")
  .then((response) => response.text())
  .then((data) => console.log(data));
```

---

title: Using Bun Serve for HTTP
description: Demonstrates how to create an HTTP server using `Bun.serve`. This is a Bun-specific API optimized for performance.
source: docs/runtime/index.md#_snippet_4

language: javascript
code:
```
Bun.serve({
  fetch(req) {
    return new Response("Welcome to Bun!");
  },
  port: 3000,
});
```

---

title: Adding WebSocket Event Listeners - TS
description: Demonstrates how to add event listeners to a WebSocket to handle `message`, `open`, `close`, and `error` events. This enables handling different stages and events in the lifecycle of a WebSocket connection.
source: docs/api/websockets.md#_snippet_0

language: ts
code:
```
// message is received
      socket.addEventListener("message", event => {});

      // socket opened
      socket.addEventListener("open", event => {});

      // socket closed
      socket.addEventListener("close", event => {});

      // error handler
      socket.addEventListener("error", event => {});
```

---

title: Live-Reloading with Watch Mode
description: Illustrates live-reloading of a TypeScript file using `bun run --watch`. The server restarts on file save, logging the restart time. This allows for rapid iteration during development.
source: docs/runtime/hot.md#_snippet_2

language: bash
code:
```
$ bun run --watch watchy.tsx
```

language: typescript
code:
```
import { serve } from "bun";
console.log("I restarted at:", Date.now());

serve({
  port: 4003,

  fetch(request) {
    return new Response("Sup");
  },
});
```

---

title: Upgrading an HTTP Request to a WebSocket Connection
description: Demonstrates using the `upgrade()` method to establish a `WebSocket` connection from an existing HTTP request. The method checks if the request is a valid WebSocket upgrade request and returns `true` if successful, `false` otherwise.
source: docs/api/websockets.md#_snippet_2

language: typescript
code:
```
`upgrade(req: Request): boolean`
```

---

title: Setting Environment Variables
description: Demonstrates setting environment variables using a `.env` file. Bun automatically reads `.env` files, allowing you to configure environment variables that can be accessed via `process.env`.
source: docs/runtime/env.md#_snippet_0

language: txt
code:
```
FOO=hello
BAR=world
```

---

title: Importing and Using a Local Module - TypeScript
description: Demonstrates importing a function `hello` from a local module `./hello` and then calling it. This example illustrates basic module usage within a TypeScript environment, showcasing how to structure and connect different parts of a simple application.
source: docs/runtime/modules.md#_snippet_0

language: ts
code:
```
import { hello } from "./hello";

hello();
```

language: ts
code:
```
export function hello() {
  console.log("Hello world!");
}
```

---

title: Defining a Simple Test with Bun:test
description: Demonstrates the basic usage of `bun:test` for defining a simple test case. It imports `expect` and `test` from `bun:test` and uses `expect` to assert that the sum of 2 + 2 equals 4.
source: docs/test/writing.md#_snippet_0

language: ts
code:
```
import { expect, test } from "bun:test";

test("2 + 2", () => {
  expect(2 + 2).toBe(4);
});
```

---

title: Defining a Plugin with Bun
description: Demonstrates how to define a Bun plugin with a `name` and `setup` function, and register it using the `plugin` function. The `setup` function is where you implement the plugin's custom loading logic.
source: docs/runtime/plugins.md#_snippet_0

language: tsx
code:
```
import { plugin, type BunPlugin } from "bun";

const myPlugin: BunPlugin = {
  name: "Custom loader",
  setup(build) {
    // implementation
  },
};

plugin(myPlugin);
```

---

title: Rendering React Components with Bun
description: Illustrates how Bun supports JSX and TSX files out of the box, converting JSX syntax into vanilla JavaScript for execution. This allows developers to write React components directly within Bun projects without additional configuration.
source: docs/runtime/jsx.md#_snippet_0

language: tsx
code:
```
function Component(props: {message: string}) {
  return (
    <body>
      <h1 style={{color: 'red'}}>{props.message}</h1>
    </body>
  );
}

console.log(<Component message="Hello world!" />);
```

---

title: Requiring Node-API Modules
description: Demonstrates how to import a `.node` file (Node-API module) directly using `require`. This is the standard way to load native addons in both Node.js and Bun.
source: docs/api/node-api.md#_snippet_0

language: js
code:
```
const napi = require("./my-node-module.node");
```

---

title: Scanning Directory - TypeScript
description: Demonstrates how to use the `Glob` class to scan a directory and its subdirectories recursively for files matching a specified pattern. The code iterates through the matching files and prints their names to the console.
source: docs/api/glob.md#_snippet_0

language: typescript
code:
```
import { Glob } from "bun";

const glob = new Glob("**/*.ts");

// Scans the current working directory and each of its sub-directories recursively
for await (const file of glob.scan(".")) {
  console.log(file); // => "index.ts"
}
```

---

title: Matching String - TypeScript
description: Illustrates how to use the `Glob` class to match a string against a glob pattern. The code creates a new `Glob` object with the pattern `*.ts` and then uses the `match` method to test whether the strings `index.ts` and `index.js` match the pattern.
source: docs/api/glob.md#_snippet_1

language: typescript
code:
```
import { Glob } from "bun";

const glob = new Glob("*.ts");

glob.match("index.ts"); // => true
glob.match("index.js"); // => false
```

---

title: Managing Connection Pool for Bun SQL
description: Illustrates how Bun's SQL client manages a connection pool. The pool is lazily started upon the first query, reuses connections when available, and supports running concurrent queries. It also demonstrates how to explicitly close the pool, with optional timeouts.
source: docs/api/sql.md#_snippet_0

language: typescript
code:
```
const sql = Bun.sql(); // no connection are created

await sql`...`; // pool is started until max is reached (if possible), first available connection is used
await sql`...`; // previous connection is reused

// two connections are used now at the same time
await Promise.all([
  sql`INSERT INTO users ${sql({ name: "Alice" })}`,
  sql`UPDATE users SET name = ${user.name} WHERE id = ${user.id}`,
]);

await sql.close(); // await all queries to finish and close all connections from the pool
await sql.close({ timeout: 5 }); // wait 5 seconds and close all connections from the pool
await sql.close({ timeout: 0 }); // close all connections from the pool immediately
```

---

title: Converting to `number[]` - Response and Bun
description: Demonstrates converting a `ReadableStream` to a `number[]` using both the `Response` API and the `Bun.readableStreamToArrayBuffer` function.  The `Response` API uses `bytes()` and `Array.from()`. The Bun function uses `Uint8Array` to parse the stream into an array buffer.
source: docs/api/binary-data.md#_snippet_0

language: typescript
code:
```
// with Response
const arr = await new Response(stream).bytes();
Array.from(arr);

// with Bun function
Array.from(new Uint8Array(Bun.readableStreamToArrayBuffer(stream)));
```

---

title: Using Color Macro in Client-Side Bundles
description: Demonstrates how to use the `Bun.color` macro to perform color formatting at bundle time for client-side JavaScript builds. The `import` statement imports the `color` function from the `bun` module with the `type: "macro"` attribute, enabling bundle-time evaluation.  The `console.log` statement shows an example that formats the color `"#f00"` to `"red"` during the bundling process.
source: docs/api/color.md#_snippet_0

language: typescript
code:
```
import { color } from "bun" with { type: "macro" };

console.log(color("#f00", "css"));
```

---

title: Starting a WebSocket Server
description: Demonstrates a simple WebSocket server built with `Bun.serve`, where incoming requests are upgraded to WebSocket connections within the `fetch` handler. The example shows how to define the `fetch` handler for upgrading requests and specifies an empty `websocket` object to initialize the handlers.
source: docs/api/websockets.md#_snippet_0

language: typescript
code:
```
Bun.serve({
  fetch(req, server) {
    // upgrade the request to a WebSocket
    if (server.upgrade(req)) {
      return; // do not return a Response
    }
    return new Response("Upgrade failed", { status: 500 });
  },
  websocket: {}, // handlers
});
```

---

title: Connecting to the Server with WebSocket
description: Illustrates how to connect to a WebSocket server from the browser using the `WebSocket` constructor. This example initializes a new WebSocket connection to a specified URL.
source: docs/api/websockets.md#_snippet_5

language: typescript
code:
```
const socket = new WebSocket("ws://localhost:3000/chat");

socket.addEventListener("message", event => {
  console.log(event.data);
})
```

---

title: Creating Cookie Instances
description: Demonstrates how to create instances of the `Cookie` class using different constructor signatures.  It showcases initializing a cookie with a name and value, using a cookie string, and using a cookie object with optional properties.
source: docs/api/cookie.md#_snippet_0

language: ts
code:
```
class Cookie {
  constructor(name: string, value: string, options?: CookieInit);
  constructor(cookieString: string);
  constructor(cookieObject?: CookieInit);

  readonly name: string;
  value: string;
  domain?: string;
  path: string;
  expires?: Date;
  secure: boolean;
  sameSite: CookieSameSite;
  partitioned: boolean;
  maxAge?: number;
  httpOnly: boolean;

  isExpired(): boolean;

  serialize(): string;
  toString(): string;
  toJSON(): CookieInit;

  static parse(cookieString: string): Cookie;
  static from(name: string, value: string, options?: CookieInit): Cookie;
}
```

---

title: Measuring String Width with Bun
description: Demonstrates how to measure the width of a string in a terminal using `Bun.stringWidth`. This function is designed to match the `string-width` package, allowing easy porting of existing code to Bun.
source: docs/api/utils.md#_snippet_0

language: ts
code:
```
namespace Bun {
  export function stringWidth(
    /**
     * The string to measure
     */
    input: string,
    options?: {
      /**
       * If `true`, count ANSI escape codes as part of the string width. If `false`, ANSI escape codes are ignored when calculating the string width.
       *
       * @default false
       */
      countAnsiEscapeCodes?: boolean;
      /**
       * When it's ambiugous and `true`, count emoji as 1 characters wide. If `false`, emoji are counted as 2 character wide.
       *
       * @default true
       */
      ambiguousIsNarrow?: boolean;
    },
  ): number;
}
```

---

title: Creating and Accessing Uint8Array Elements
description: Illustrates creating a `Uint8Array` from an `ArrayBuffer` and assigning values to its elements. This demonstrates the array-like interface provided by TypedArrays for manipulating binary data, and shows how out-of-bounds assignments are ignored.
source: docs/api/binary-data.md#_snippet_5

language: typescript
code:
```
const buffer = new ArrayBuffer(3);
const arr = new Uint8Array(buffer);

// contents are initialized to zero
console.log(arr); // Uint8Array(3) [0, 0, 0]

// assign values like an array
arr[0] = 0;
arr[1] = 10;
arr[2] = 255;
arr[3] = 255; // no-op, out of bounds
```

---

title: Creating a Simple ReadableStream - TypeScript
description: Demonstrates how to create a basic `ReadableStream` in Bun. The `start` method enqueues two string chunks, `hello` and `world`, before closing the stream. This stream can then be consumed chunk-by-chunk.
source: docs/api/streams.md#_snippet_0

language: ts
code:
```
const stream = new ReadableStream({
  start(controller) {
    controller.enqueue(
```

---

title: Reading a ReadableStream Chunk-by-Chunk - TypeScript
description: Illustrates how to read the contents of a `ReadableStream` using a `for await` loop. Each chunk of data is logged to the console, demonstrating how to process data as it becomes available from the stream.
source: docs/api/streams.md#_snippet_1

language: ts
code:
```
for await (const chunk of stream) {
  console.log(chunk);
  // => "hello"
  // => "world"
}
```

---

title: Creating a BunFile Instance
description: Demonstrates how to create a `BunFile` instance using `Bun.file(path)`. The example shows how to get the `size` (number of bytes) and `type` (MIME type) of the file.
source: docs/api/file-io.md#_snippet_0

language: typescript
code:
```
const foo = Bun.file("foo.txt"); // relative to cwd
foo.size; // number of bytes
foo.type; // MIME type
```

---

title: Reading File Contents - TypeScript
description: Illustrates how to read the contents of a `BunFile` in different formats. The `BunFile` reference conforms to the `Blob` interface, which allows reading the file as a string using `.text()`, as a stream using `.stream()`, as an `ArrayBuffer` using `.arrayBuffer()`, or as a `Uint8Array` using `.bytes()`.
source: docs/api/file-io.md#_snippet_1

language: typescript
code:
```
const foo = Bun.file("foo.txt");

await foo.text(); // contents as a string
await foo.stream(); // contents as ReadableStream
await foo.arrayBuffer(); // contents as ArrayBuffer
await foo.bytes(); // contents as Uint8Array
```

---

title: Accessing Module Metadata - TypeScript
description: Demonstrates how to access module metadata using `import.meta` in Bun. It illustrates the usage of properties like `import.meta.dir`, `import.meta.file`, `import.meta.path`, `import.meta.url`, and `import.meta.main` to retrieve information about the current module's location and execution context.
source: docs/api/import-meta.md#_snippet_0

language: typescript
code:
```
import.meta.dir;   // => "/path/to/project"
import.meta.file;  // => "file.ts"
import.meta.path;  // => "/path/to/project/file.ts"
import.meta.url;   // => "file:///path/to/project/file.ts"

import.meta.main;  // `true` if this file is directly executed by `bun run`
                   // `false` otherwise
```

---

title: Using Response as Stdin - JavaScript
description: Demonstrates how to use a `Response` object as standard input (`stdin`) for a shell command using Bun Shell.  It fetches content from a URL and then pipes it to `wc -c` to count the number of bytes.
source: docs/runtime/shell.md#_snippet_0

language: js
code:
```
import { $ } from "bun";

const response = await fetch("https://example.com");

// Use Response as stdin.
await $`cat < ${response} | wc -c`; // 1256
```

---

title: Printing Output with Echo - JavaScript
description: Illustrates the simplest shell command, `echo`, in Bun Shell, demonstrating how to execute it using the `$` template literal tag. The command prints "Hello World!" to the standard output.
source: docs/runtime/shell.md#_snippet_1

language: js
code:
```
import { $ } from "bun";

await $`echo "Hello World!"`; // Hello World!
```

---

title: Receiving UDP Datagrams with Bun - TypeScript
description: Demonstrates how to receive UDP datagrams by defining a `data` callback when creating the socket.  The callback function receives the socket, buffer, port, and address of the sender.  A client socket sends a message to the server socket to trigger the callback.
source: docs/api/udp.md#_snippet_2

language: typescript
code:
```
const server = await Bun.udpSocket({
  socket: {
    data(socket, buf, port, addr) {
      console.log(`message from ${addr}:${port}:`);
      console.log(buf.toString());
    },
  },
});

const client = await Bun.udpSocket({});
client.send(
```

---

title: Using Gunzipping Algorithm
description: Demonstrates using `Bun.gunzipSync` to decompress a `Uint8Array` compressed with the GUNZIP algorithm. The example compresses a string, then decompresses it, and decodes the result using `TextDecoder`.
source: docs/api/utils.md#_snippet_0

language: ts
code:
```
const buf = Buffer.from(
```

---

title: Using Deflate Compression
description: Illustrates how to compress a `Uint8Array` using `Bun.deflateSync` with zlib's DEFLATE algorithm. The example shows compressing a buffer and inspecting both the original and compressed data.
source: docs/api/utils.md#_snippet_1

language: ts
code:
```
const buf = Buffer.from(
```

---

title: Using Inflate Decompression
description: Shows how to decompress a `Uint8Array` using `Bun.inflateSync` with zlib's INFLATE algorithm. This involves compressing a string, decompressing it, and then decoding it using `TextDecoder`.
source: docs/api/utils.md#_snippet_2

language: ts
code:
```
const buf = Buffer.from(
```

---

title: Querying Data with Tagged Template Literals - TypeScript
description: Demonstrates how to use tagged template literals with Bun's SQL client to select data from a PostgreSQL database. It illustrates the use of placeholders for dynamic values in the `WHERE` clause and `LIMIT` clause to prevent SQL injection vulnerabilities. This approach provides a safe and readable way to construct SQL queries.
source: docs/api/sql.md#_snippet_0

language: ts
code:
```
import { sql } from "bun";

const users = await sql`
  SELECT * FROM users
  WHERE active = ${true}
  LIMIT ${10}
`;

// Select with multiple conditions
const activeUsers = await sql`
  SELECT *
  FROM users
  WHERE active = ${true}
  AND age >= ${18}
`;
```

---

title: Creating Typed Array from ArrayBuffer
description: Demonstrates how to create a `Uint8Array` from an existing `ArrayBuffer` instance, initializing some elements and logging the resulting array. This is useful when you need to work with a specific region of memory represented by an `ArrayBuffer`.
source: docs/api/binary-data.md#_snippet_0

language: ts
code:
```
// create typed array from ArrayBuffer
const buf = new ArrayBuffer(10);
const arr = new Uint8Array(buf);

arr[0] = 30;
arr[1] = 60;

// all elements are initialized to zero
console.log(arr); // => Uint8Array(10) [ 30, 60, 0, 0, 0, 0, 0, 0, 0, 0 ];
```

---

title: Creating Cookie Maps
description: Demonstrates creating `Bun.CookieMap` instances using different methods: empty constructor, from a cookie string, from an object, and from an array of name-value pairs.  This offers flexibility when initializing cookie collections.
source: docs/api/cookie.md#_snippet_0

language: typescript
code:
```
// Empty cookie map
const cookies = new Bun.CookieMap();

// From a cookie string
const cookies1 = new Bun.CookieMap("name=value; foo=bar");

// From an object
const cookies2 = new Bun.CookieMap({
  session: "abc123",
  theme: "dark",
});

// From an array of name/value pairs
const cookies3 = new Bun.CookieMap([
  ["session", "abc123"],
  ["theme", "dark"],
]);
```

---

title: Accessing Cookies in HTTP Servers
description: Illustrates accessing and modifying cookies within a Bun HTTP server route using `req.cookies`, an instance of `Bun.CookieMap`.  It shows how to retrieve a cookie, check for its existence, and set a new cookie, which will be automatically applied to the response.
source: docs/api/cookie.md#_snippet_1

language: typescript
code:
```
const server = Bun.serve({
  routes: {
    "/": req => {
      // Access request cookies
      const cookies = req.cookies;

      // Get a specific cookie
      const sessionCookie = cookies.get("session");
      if (sessionCookie != null) {
        console.log(sessionCookie);
      }

      // Check if a cookie exists
      if (cookies.has("theme")) {
        // ...
      }

      // Set a cookie, it will be automatically applied to the response
      cookies.set("visited", "true");

      return new Response("Hello");
    },
  },
});

console.log("Server listening at: " + server.url);
```

---

title: Creating Cookie Instances
description: Demonstrates creating `Bun.Cookie` instances using different constructors: with just a name and value, with options to specify attributes like domain, path, and expiration, from a cookie string, and from an options object (`CookieInit`). This offers flexibility in constructing cookies with varying levels of configuration.
source: docs/api/cookie.md#_snippet_10

language: typescript
code:
```
import { Cookie } from "bun";

// Create a basic cookie
const cookie = new Bun.Cookie("name", "value");

// Create a cookie with options
const secureSessionCookie = new Bun.Cookie("session", "abc123", {
  domain: "example.com",
  path: "/admin",
  expires: new Date(Date.now() + 86400000), // 1 day
  httpOnly: true,
  secure: true,
  sameSite: "strict",
});

// Parse from a cookie string
const parsedCookie = new Bun.Cookie("name=value; Path=/; HttpOnly");

// Create from an options object
const objCookie = new Bun.Cookie({
  name: "theme",
  value: "dark",
  maxAge: 3600,
  secure: true,
});
```

---

title: Generating Uuid V7 - Typescript
description: Illustrates how to generate a UUID v7 using `Bun.randomUUIDv7()`, which is monotonic and suitable for sorting and databases. The import statement imports the function directly from 'bun'.
source: docs/api/utils.md#_snippet_8

language: typescript
code:
```
import { randomUUIDv7 } from "bun";

const id = randomUUIDv7();
// => "0192ce11-26d5-7dc3-9305-1426de888c5a"
```

---

title: Converting TypedArray To a Pointer - Bun:ffi
description: Demonstrates how to convert a `TypedArray` to a pointer using the `ptr` function from `bun:ffi`. This allows you to pass the underlying memory buffer of the `TypedArray` to FFI functions.
source: docs/api/ffi.md#_snippet_0

language: typescript
code:
```
import { ptr } from "bun:ffi";
let myTypedArray = new Uint8Array(32);
const myPtr = ptr(myTypedArray);
```

---

title: Converting Pointer to ArrayBuffer - Bun:ffi
description: Illustrates how to convert a pointer back to an `ArrayBuffer` using the `toArrayBuffer` function from `bun:ffi`.  It accepts a `byteOffset` and `byteLength`. The example initializes a `TypedArray`, gets a pointer to it, and then creates a new `TypedArray` from the pointer.
source: docs/api/ffi.md#_snippet_1

language: typescript
code:
```
import { ptr, toArrayBuffer } from "bun:ffi";
let myTypedArray = new Uint8Array(32);
const myPtr = ptr(myTypedArray);

// toArrayBuffer accepts a `byteOffset` and `byteLength`
// if `byteLength` is not provided, it is assumed to be a null-terminated pointer
myTypedArray = new Uint8Array(toArrayBuffer(myPtr, 0, 32), 0, 32);
```

---

title: Creating a TCP Connection with Bun Connect
description: Illustrates how to create a connection to a TCP server using `Bun.connect` with specified hostname, port, and socket event handlers. It also shows how to define client-specific handlers for events like connection errors, server-initiated closure, and timeouts.
source: docs/api/tcp.md#_snippet_5

language: typescript
code:
```
// The client
const socket = await Bun.connect({
  hostname: "localhost",
  port: 8080,

  socket: {
    data(socket, data) {},
    open(socket) {},
    close(socket, error) {},
    drain(socket) {},
    error(socket, error) {},

    // client-specific handlers
    connectError(socket, error) {}, // connection failed
    end(socket) {}, // connection closed by server
    timeout(socket) {}, // connection timed out
  },
});
```

---

title: Writing Data to S3 Bucket - TypeScript
description: Demonstrates using `S3Client.write` to write data to an S3 bucket. It shows how to write a string, JSON data with a specified type, data from a `fetch` response, and data with an ACL.
source: docs/api/s3.md#_snippet_0

language: typescript
code:
```
import { S3Client } from "bun";

const credentials = {
  accessKeyId: "your-access-key",
  secretAccessKey: "your-secret-key",
  bucket: "my-bucket",
  // endpoint: "https://s3.us-east-1.amazonaws.com",
  // endpoint: "https://<account-id>.r2.cloudflarestorage.com", // Cloudflare R2
};

// Write string
await S3Client.write("my-file.txt", "Hello World");

// Write JSON with type
await S3Client.write("data.json", JSON.stringify({ hello: "world" }), {
  ...credentials,
  type: "application/json",
});

// Write from fetch
const res = await fetch("https://example.com/data");
await S3Client.write("data.bin", res, credentials);

// Write with ACL
await S3Client.write("public.html", html, {
  ...credentials,
  acl: "public-read",
  type: "text/html",
});
```

---

title: Generating Presigned URLs for S3 Files - TypeScript
description: Illustrates how to generate a presigned URL for an S3 file using `S3Client.presign`. The presigned URL allows temporary access to the file with specified credentials and expiration time.
source: docs/api/s3.md#_snippet_1

language: typescript
code:
```
import { S3Client } from "bun";

const credentials = {
  accessKeyId: "your-access-key",
  secretAccessKey: "your-secret-key",
  bucket: "my-bucket",
  // endpoint: "https://s3.us-east-1.amazonaws.com",
  // endpoint: "https://<account-id>.r2.cloudflarestorage.com", // Cloudflare R2
};

const url = S3Client.presign("my-file.txt", {
  ...credentials,
  expiresIn: 3600,
});
```

---

title: Mapping Query Results - With Class Instances
description: Demonstrates how to map query results to instances of a class using `.as(Class)`. This allows attaching methods and getters/setters to the results, providing a more object-oriented way to interact with database data. Note that the class constructor is not called for performance reasons.
source: docs/api/sqlite.md#_snippet_0

language: typescript
code:
```
class Movie {
  title: string;
  year: number;

  get isMarvel() {
    return this.title.includes("Marvel");
  }
}

const query = db.query("SELECT title, year FROM movies").as(Movie);
const movies = query.all();
const first = query.get();
console.log(movies[0].isMarvel); // => true
console.log(first.isMarvel); // => true
```

---

title: Querying With Named Parameters
description: Shows how to execute queries with named parameters using the `$param` syntax. Binding values to these parameters allows for safer and more readable queries by preventing SQL injection and improving code maintainability.
source: docs/api/sqlite.md#_snippet_5

language: typescript
code:
```
const query = db.query("SELECT * FROM foo WHERE bar = $bar");
const results = query.all({
  $bar: "bar",
});
```

language: json
code:
```
[
  { "$bar": "bar" }
]
```

---

title: Serving a Basic Webpage with Bun
description: Demonstrates how to create a simple HTTP server using `Bun.serve`. The server listens on port 8080 and responds with "Bun!" for every request, showcasing Bun's efficiency in handling web requests.
source: docs/api/http.md#_snippet_0

language: javascript
code:
```
require("http")
  .createServer((req, res) => res.end("Bun!"))
  .listen(8080);
```

---

title: Importing and Querying with Bun SQLite
description: Demonstrates how to import the `bun:sqlite` module and execute a basic SQL query.  The example initializes a database in memory and retrieves a simple message using `db.query()` and `query.get()`. This showcases the basic synchronous API for interacting with SQLite databases in Bun.
source: docs/api/sqlite.md#_snippet_0

language: ts
code:
```
import { Database } from "bun:sqlite";

const db = new Database(":memory:");
const query = db.query("select 'Hello world' as message;");
query.get(); // => { message: "Hello world" }
```

---

title: Interacting with S3 Using Bun's API
description: Demonstrates how to interact with S3-compatible object storage services using Bun's native bindings, showcasing reading, uploading, and deleting files, as well as presigning URLs. It uses `Bun.s3` to read environment variables for credentials and perform various operations on an S3 file.
source: docs/api/s3.md#_snippet_0

language: typescript
code:
```
import { s3, write, S3Client } from "bun";

// Bun.s3 reads environment variables for credentials
// file() returns a lazy reference to a file on S3
const metadata = s3.file("123.json");

// Download from S3 as JSON
const data = await metadata.json();

// Upload to S3
await write(metadata, JSON.stringify({ name: "John", age: 30 }));

// Presign a URL (synchronous - no network request needed)
const url = metadata.presign({
  acl: "public-read",
  expiresIn: 60 * 60 * 24, // 1 day
});

// Delete the file
await metadata.delete();
```

---

title: Benchmarking Synchronous Process Spawning - Bash
description: Illustrates the performance difference between `bun spawnSync` and Node.js's `child_process` module using a simple benchmark. The benchmark executes `echo hi` using both runtimes and compares the average execution time.
source: docs/api/spawn.md#_snippet_0

language: bash
code:
```
$ bun spawn.mjs
cpu: Apple M1 Max
runtime: bun 1.x (arm64-darwin)

benchmark              time (avg)             (min ... max)       p75       p99      p995
--------------------------------------------------------- -----------------------------
spawnSync echo hi  888.14 Âµs/iter    (821.83 Âµs ... 1.2 ms) 905.92 Âµs      1 ms   1.03 ms
$ node spawn.node.mjs
cpu: Apple M1 Max
runtime: node v18.9.1 (arm64-darwin)

benchmark              time (avg)             (min ... max)       p75       p99      p995
--------------------------------------------------------- -----------------------------
spawnSync echo hi    1.47 ms/iter     (1.14 ms ... 2.64 ms)   1.57 ms   2.37 ms   2.52 ms
```

---

title: Creating a Worker From The Main Thread
description: Demonstrates how to create a new `Worker` instance from the main thread. The main thread posts a message to the worker and listens for a response.
source: docs/api/workers.md#_snippet_0

language: js
code:
```
const worker = new Worker("./worker.ts");

worker.postMessage("hello");
worker.onmessage = event => {
  console.log(event.data);
};
```

---

title: Handling Messages in a Worker Thread - TypeScript
description: Illustrates how to handle messages within a worker thread using TypeScript.  It defines `self` to prevent TypeScript errors, listens for messages using `self.onmessage`, and posts a message back to the main thread.
source: docs/api/workers.md#_snippet_1

language: ts
code:
```
// prevents TS errors
declare var self: Worker;

self.onmessage = (event: MessageEvent) => {
  console.log(event.data);
  postMessage(
```

---

title: Displaying Vulnerability Report - CLI
description: Shows the format of the vulnerability report that `bun audit` displays when vulnerabilities are detected. The report lists each affected package, along with the severity, a short description, and a link to the advisory, ending with a summary and hints for updating.
source: docs/install/audit.md#_snippet_2

language: text
code:
```
3 vulnerabilities (1 high, 2 moderate)
To update all dependencies to the latest compatible versions:
  bun update
To update all dependencies to the latest versions (including breaking changes):
  bun update --latest
```

---

title: Declaring Workspace Dependencies
description: Illustrates how to declare dependencies between packages within a monorepo using the `workspace:` protocol in a `package.json` file. This allows packages to reference each other using their local paths, enabling seamless development and testing of interconnected modules.
source: docs/install/workspaces.md#_snippet_1

language: json
code:
```
{
  "name": "pkg-a",
  "version": "1.0.0",
  "dependencies": {
    "pkg-b": "workspace:*"
  }
}
```

---

title: Defining Project Dependencies- package.json
description: Illustrates the basic structure of a `package.json` file, defining a project named `my-app` with a single dependency, `foo` at version `^2.0.0`. This example sets the stage for understanding how overrides are later applied to manage metadependencies.
source: docs/install/overrides.md#_snippet_1

language: json
code:
```
{
  "name": "my-app",
  "dependencies": {
    "foo": "^2.0.0"
  }
}
```

---

title: Connecting and Interacting with Redis - Bun
description: Demonstrates basic Redis operations using the `bun` library, including setting and retrieving a key, incrementing a counter, checking key existence, and deleting a key. This provides a quickstart for interacting with a Redis database in a Bun environment.
source: docs/api/redis.md#_snippet_0

language: ts
code:
```
import { redis } from "bun";

// Set a key
await redis.set("greeting", "Hello from Bun!");

// Get a key
const greeting = await redis.get("greeting");
console.log(greeting); // "Hello from Bun!"

// Increment a counter
await redis.set("counter", 0);
await redis.incr("counter");

// Check if a key exists
const exists = await redis.exists("greeting");

// Delete a key
await redis.del("greeting");
```

---

title: Using dlopen with bun:ffi
description: Demonstrates how to use `dlopen` from the `bun:ffi` module to load a native library and call a function within it. It imports the necessary modules, defines the path to the `sqlite3` library, and calls the `sqlite3_libversion` function to print the SQLite version.
source: docs/api/ffi.md#_snippet_0

language: typescript
code:
```
import { dlopen, FFIType, suffix } from "bun:ffi";

// `suffix` is either "dylib", "so", or "dll" depending on the platform
// you don't have to use "suffix", it's just there for convenience
const path = `libsqlite3.${suffix}`;

const {
  symbols: {
    sqlite3_libversion, // the function to call
  },
} = dlopen(
  path, // a library name or file path
  {
    sqlite3_libversion: {
      // no arguments, returns a string
      args: [],
      returns: FFIType.cstring,
    },
  },
);

console.log(`SQLite 3 version: ${sqlite3_libversion()}`);
```

---

title: Hashing and Verifying Passwords with Argon2 and Bcrypt
description: Demonstrates how to hash a password using `Bun.password.hash` with default settings, resulting in an Argon2-encoded hash. Also, illustrates how to verify the password against the generated hash using `Bun.password.verify`, which automatically detects the algorithm.
source: docs/api/hashing.md#_snippet_0

language: typescript
code:
```
const password = "super-secure-pa$$word";

const hash = await Bun.password.hash(password);
// => $argon2id$v=19$m=65536,t=2,p=1$tFq+9AVr1bfPxQdh6E8DQRhEXg/M+SqYCNu6gVdRRNs$GzJ8PuBi+K+BVojzPfS5mjnC8OpLGtv8KJqF99eP6a4

const isMatch = await Bun.password.verify(password, hash);
// => true
```

---

title: Building with CLI - Bash
description: Demonstrates the basic command-line usage for bundling an entrypoint with both `esbuild` and `bun`. The `bun build` command simplifies the process by automatically bundling, unlike `esbuild` which requires the `--bundle` flag.
source: docs/bundler/vs-esbuild.md#_snippet_0

language: bash
code:
```
$ esbuild <entrypoint> --outdir=out --bundle
$ bun build <entrypoint> --outdir=out
```

---

title: Creating a Basic Server with Elysia
description: Demonstrates the basic setup of an Elysia server. It imports the `Elysia` class, creates a new instance, defines a route that returns 'Hello Elysia' on the root path, and starts the server on port 8080.
source: docs/ecosystem/elysia.md#_snippet_0

language: typescript
code:
```
import { Elysia } from 'elysia'

const app = new Elysia()
	.get('/', () => 'Hello Elysia')
	.listen(8080)

console.log(`[U+1F98A] Elysia is running at on port ${app.server.port}...`)
```

---

title: Initializing Hono Application
description: Demonstrates how to import the `Hono` class from the `hono` package, create a new `Hono` application instance, define a route that returns a simple text response, and export the application instance.
source: docs/ecosystem/hono.md#_snippet_0

language: ts
code:
```
import { Hono } from "hono";
const app = new Hono();

app.get("/", c => c.text("Hono!"));

export default app;
```

---

title: Running a Simple Express App
description: Demonstrates a basic Express application setup. It imports the `express` library, defines a route that sends 'Hello World!' as a response, and starts the server on port 8080.
source: docs/ecosystem/express.md#_snippet_0

language: ts
code:
```
import express from "express";

const app = express();
const port = 8080;

app.get("/", (req, res) => {
  res.send("Hello World!");
});

app.listen(port, () => {
  console.log(`Listening on port ${port}...`);
});
```

---

title: Creating a Basic Route - Typescript
description: Demonstrates creating a simple route using Stric's `Router`. The code imports the `Router` class, creates a new router instance, and defines a GET route for the root path ('/') that returns a `Response` object with the text 'Hi'. This example illustrates the basic structure for handling HTTP requests with Stric.
source: docs/ecosystem/stric.md#_snippet_0

language: ts
code:
```
import { Router } from '@stricjs/router';

// Export the fetch handler and serve with Bun
export default new Router()
  // Return 'Hi' on every request
  .get('/', () => new Response('Hi'));
```

---

title: Serving a PageRouter - Typescript
description: Demonstrates how to create and serve a `PageRouter` using `@stricjs/arrow`. It initializes a new `PageRouter` instance and then calls the `serve()` method. This sets up the router to handle and serve pages directly within a Stric application.
source: docs/ecosystem/stric.md#_snippet_2

language: ts
code:
```
import { PageRouter } from '@stricjs/arrow';

// Create a page router, build and serve directly
new PageRouter().serve();
```

---

title: Rewriting HTML with HTMLRewriter - TS
description: Demonstrates how to use `HTMLRewriter` to modify an HTML document. The example replaces all `<img>` tags with a Rick Astley thumbnail and wraps them in a link to the Rickroll video on YouTube, showing the basic usage of the `on` and `transform` methods.
source: docs/api/html-rewriter.md#_snippet_0

language: ts
code:
```
// Replace all images with a rickroll
const rewriter = new HTMLRewriter().on("img", {
  element(img) {
    // Famous rickroll video thumbnail
    img.setAttribute(
      "src",
      "https://img.youtube.com/vi/dQw4w9WgXcQ/maxresdefault.jpg",
    );

    // Wrap the image in a link to the video
    img.before(
      '<a href="https://www.youtube.com/watch?v=dQw4w9WgXcQ" target="_blank">',
      { html: true },
    );
    img.after("</a>", { html: true });

    // Add some fun alt text
    img.setAttribute("alt", "Definitely not a rickroll");
  },
});

// An example HTML document
const html = `
<html>
<body>
  <img src="/cat.jpg">
  <img src="dog.png">
  <img src="https://example.com/bird.webp">
</body>
</html>
`;

const result = rewriter.transform(html);
console.log(result);

```

---

title: Rendering React Component with JSX - TSX
description: Demonstrates how to define and render a simple React component using JSX syntax in a `.tsx` file. The component accepts a `message` prop and displays it within an `h1` tag. The `console.log` statement renders the component to the console.
source: docs/ecosystem/react.md#_snippet_0

language: tsx
code:
```
function Component(props: {message: string}) {
  return (
    <body>
      <h1 style={{color: 'red'}}>{props.message}</h1>
    </body>
  );
}

console.log(<Component message="Hello world!" />);
```

---

title: Creating a BunFile
description: Demonstrates creating a `BunFile` instance using `Bun.file()`. This method lazily loads the file, providing access to file metadata without loading the entire file into memory.
source: docs/api/binary-data.md#_snippet_0

language: typescript
code:
```
const file = Bun.file("index.txt");
// => BunFile
```

---

title: Creating a File Instance
description: Illustrates creating a `File` instance with content, a file name, and type options. This is useful for simulating file uploads or creating file-like objects in memory.
source: docs/api/binary-data.md#_snippet_1

language: typescript
code:
```
const file = new File(["<html>Hello</html>"], "index.html", {
  type: "text/html",
});
```

---

title: Referencing Catalog Versions in Workspace Packages
description: Illustrates how to reference dependency versions defined in the root `package.json` catalog within workspace packages using the `catalog:` protocol. This ensures that all packages within the monorepo use the same versions of specified dependencies, promoting consistency and simplifying version management.
source: docs/install/catalogs.md#_snippet_1

language: json
code:
```
{
  "name": "app",
  "dependencies": {
    "react": "catalog:",
    "react-dom": "catalog:",
    "jest": "catalog:testing"
  }
}
```

language: json
code:
```
{
  "name": "ui",
  "dependencies": {
    "react": "catalog:",
    "react-dom": "catalog:"
  },
  "devDependencies": {
    "jest": "catalog:testing",
    "testing-library": "catalog:testing"
  }
}
```

---

title: Importing and Using ECMAScript Modules
description: Demonstrates how to import and use ECMAScript modules (ESM) in a browser environment. It illustrates the use of `import` and `export` statements to create modular JavaScript code, allowing for better organization and reusability. The `sayHello` function is imported from `hello.js` and then invoked.
source: docs/bundler/intro.md#_snippet_0

language: html
code:
```
<html>
  <head>
    <script type="module" src="/index.js" ></script>
  </head>
</html>
```

language: javascript
code:
```
import {sayHello} from "./hello.js";

sayHello();
```

language: javascript
code:
```
export function sayHello() {
  console.log("Hello, world!");
}
```

---

title: Specifying Isolated Installs via Command Line
description: Demonstrates how to use the `--linker` flag with `bun install` to specify either isolated or hoisted installation strategies.  This allows users to control dependency resolution behavior from the command line. Using `isolated` creates a non-hoisted dependency structure, while `hoisted` uses the traditional flattened structure.
source: docs/install/isolated.md#_snippet_0

language: bash
code:
```
# Use isolated installs
$ bun install --linker isolated

# Use traditional hoisted installs
$ bun install --linker hoisted
```

---

title: Processing Script Tags with Bundler
description: Demonstrates how Bun's bundler transpiles TypeScript, JSX, and TSX within `<script>` tags, bundles imported dependencies, generates sourcemaps for debugging, and minifies the code when `development` is not set to `true` in `Bun.serve()`. This enables efficient handling of modern JavaScript syntax and dependencies within HTML files.
source: docs/bundler/fullstack.md#_snippet_0

language: html
code:
```
<script type="module" src="./counter.tsx"></script>
```

---

title: Processing Link Tags for CSS with Bundler
description: Illustrates how Bun's bundler processes CSS imports and `<link>` tags, concatenates CSS files, and rewrites `url` and asset paths to include content-addressable hashes in URLs. This optimization ensures efficient CSS delivery and cache management.
source: docs/bundler/fullstack.md#_snippet_1

language: html
code:
```
<link rel="stylesheet" href="./styles.css" />
```

---

title: Getting Started with CSS Modules
description: Demonstrates how to import and use CSS modules in a TSX file. The `styles` object contains class names as keys and unique identifiers as values, preventing class name collisions.
source: docs/bundler/css_modules.md#_snippet_0

language: css
code:
```
/* styles.module.css */
.button {
  color: red;
}

/* other-styles.module.css */
.button {
  color: blue;
}
```

language: tsx
code:
```
import styles from "./styles.module.css";
import otherStyles from "./other-styles.module.css";

export default function App() {
  return (
    <>
      <button className={styles.button}>Red button!</button>
      <button className={otherStyles.button}>Blue button!</button>
    </>
  );
}
```

---

title: Sending an HTTP Request with Fetch
description: Demonstrates a basic HTTP request using `fetch` in Bun. The code sends a GET request to a specified URL and logs the response status code, then reads and processes the response body as text.
source: docs/api/fetch.md#_snippet_0

language: typescript
code:
```
const response = await fetch("http://example.com");

console.log(response.status); // => 200

const text = await response.text(); // or response.json(), response.formData(), etc.
```

---

title: Building a Project - Bun
description: Demonstrates the usage of the `bun build` command to build a project. The `bun build` command is used to bundle and optimize code for deployment, improving performance and reducing file sizes.
source: docs/bundler/index.md#_snippet_0

language: shell
code:
```
bun build
```

---

title: Spawning a Process Using `Bun.spawn()`
description: Demonstrates how to spawn a subprocess using `Bun.spawn()` with a command specified as an array of strings. The example retrieves the Bun version and prints the exit code.
source: docs/api/spawn.md#_snippet_0

language: typescript
code:
```
const proc = Bun.spawn(["bun", "--version"]);
console.log(await proc.exited); // 0
```

---

title: Serving with Bun Serve
description: Demonstrates using `Bun.serve` to start a high-performance HTTP server. This example showcases various routing options, including static routes, dynamic routes, per-HTTP method handlers, wildcard routes, and redirects.
source: docs/api/http.md#_snippet_0

language: typescript
code:
```
Bun.serve({
  // `routes` requires Bun v1.2.3+
  routes: {
    // Static routes
    "/api/status": new Response("OK"),

    // Dynamic routes
    "/users/:id": req => {
      return new Response(`Hello User ${req.params.id}!`);
    },

    // Per-HTTP method handlers
    "/api/posts": {
      GET: () => new Response("List posts"),
      POST: async req => {
        const body = await req.json();
        return Response.json({ created: true, ...body });
      },
    },

    // Wildcard route for all routes that start with "/api/" and aren't otherwise matched
    "/api/*": Response.json({ message: "Not found" }, { status: 404 }),

    // Redirect from /blog/hello to /blog/hello/world
    "/blog/hello": Response.redirect("/blog/hello/world"),

    // Serve a file by buffering it in memory
    "/favicon.ico": new Response(await Bun.file("./favicon.ico").bytes(), {
      headers: {
        "Content-Type": "image/x-icon",
      },
    }),
  },

  // (optional) fallback for unmatched routes:
  // Required if Bun's version < 1.2.3
  fetch(req) {
    return new Response("Not Found", { status: 404 });
  },
});
```

---

title: Implementing onBeforeParse Hook in Rust
description: Demonstrates the implementation of the `onBeforeParse` hook in a native Bun plugin using Rust. This code defines a plugin that replaces all occurrences of `foo` with `bar` in the input source code, showcasing how to modify files before they are parsed by Bun.
source: docs/bundler/plugins.md#_snippet_2

language: rs
code:
```
use bun_native_plugin::{define_bun_plugin, OnBeforeParse, bun, Result, anyhow, BunLoader};
use napi_derive::napi;

/// Define the plugin and its name
define_bun_plugin!("replace-foo-with-bar");

/// Here we'll implement `onBeforeParse` with code that replaces all occurrences of
/// `foo` with `bar`.
///
/// We use the #[bun] macro to generate some of the boilerplate code.
///
/// The argument of the function (`handle: &mut OnBeforeParse`) tells
/// the macro that this function implements the `onBeforeParse` hook.
#[bun]
pub fn replace_foo_with_bar(handle: &mut OnBeforeParse) -> Result<()> {
  // Fetch the input source code.
  let input_source_code = handle.input_source_code()?;

  // Get the Loader for the file
  let loader = handle.output_loader();


  let output_source_code = input_source_code.replace("foo", "bar");

  handle.set_output_source_code(output_source_code, BunLoader::BUN_LOADER_JSX);

  Ok(())
}
```

---

title: Bundling with the JavaScript API and CLI
description: Demonstrates how to use the `Bun.build()` JavaScript API and the `bun build` CLI command to bundle code. This shows the two primary ways to invoke Bun's bundler, allowing developers to choose the method that best fits their workflow.
source: docs/bundler/index.md#_snippet_0

language: ts
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './build',
});
```

language: sh
code:
```
$ bun build ./index.tsx --outdir ./build
```

---

title: Building a React App
description: Demonstrates a basic React application setup with `index.tsx` and `Component.tsx`. The `index.tsx` file imports `ReactDOM` and the `Component` to render a simple message to the `root` element.  This example showcases a common use case for bundling TypeScript and JSX code.
source: docs/bundler/index.md#_snippet_1

language: tsx
code:
```
import * as ReactDOM from 'react-dom/client';
import {Component} from "./Component"

const root = ReactDOM.createRoot(document.getElementById('root')!);
root.render(<Component message="Sup!" />)
```

language: tsx
code:
```
export function Component(props: {message: string}) {
  return <p>{props.message}</p>
}
```

---

title: Bundling a React App with JavaScript API and CLI
description: Illustrates bundling a React application using both the JavaScript API and the CLI. The code shows how to define entry points and output directories for the bundling process, resulting in a single bundled JavaScript file.
source: docs/bundler/index.md#_snippet_2

language: ts
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
})
```

language: bash
code:
```
$ bun build ./index.tsx --outdir ./out
```

---

title: Installing Production Dependencies
description: Illustrates how to use the `--production` flag with `bun install` to install only production dependencies, excluding those listed in `devDependencies`.  This is useful for deploying applications to production environments where development tools are not needed.
source: docs/install/index.md#_snippet_1

language: bash
code:
```
$ bun install --production
```

---

title: Freezing Lockfile During Installation
description: Shows how to use the `--frozen-lockfile` flag with `bun install` to prevent any changes to the `bun.lock` file during installation. This ensures that the exact versions of dependencies specified in the lockfile are installed, which is important for consistent builds in CI/CD environments.
source: docs/install/index.md#_snippet_2

language: bash
code:
```
$ bun install --frozen-lockfile
```

---

title: Serving HTML - HTML
description: Demonstrates a basic HTML structure with links to a stylesheet (`./styles.css`) and a JavaScript module (`./app.ts`), along with an image reference (`./logo.png`). This setup showcases how Bun's bundler can automatically handle and serve HTML files, JavaScript, CSS, and assets without any configuration.
source: docs/bundler/html.md#_snippet_0

language: html
code:
```
<!doctype html>
<html>
  <head>
    <link rel="stylesheet" href="./styles.css" />
    <script src="./app.ts" type="module"></script>
  </head>
  <body>
    <img src="./logo.png" />
  </body>
</html>
```

---

title: Defining a Single Page App - HTML
description: Illustrates the basic structure of an HTML file for a Single Page Application (SPA) that loads a TypeScript/JSX module (`app.tsx`).  The `div` with id `root` acts as the mounting point for the SPA. This setup shows how Bun uses the HTML as a fallback route for all paths, enabling client-side routing without additional server configuration.
source: docs/bundler/html.md#_snippet_1

language: html
code:
```
<!doctype html>
<html>
  <head>
    <title>My SPA</title>
    <script src="./app.tsx
```

---

title: Converting JSON to JavaScript Module
description: Illustrates how a `.json` file is converted to a `.js` module with a default export when used as an entrypoint. This allows the JSON data to be used in JavaScript files via import statements.
source: docs/bundler/loaders.md#_snippet_1

language: json
code:
```
{
  "name": "John Doe",
  "age": 35,
  "email": "johndoe@example.com"
}
```

language: js
code:
```
export default {
  name: "John Doe",
  age: 35,
  email: "johndoe@example.com"
}
```

---

title: Converting TOML to JavaScript Module
description: Illustrates how a `.toml` file is converted to a `.js` module with a default export when used as an entrypoint. This allows the TOML configuration to be imported and used in JavaScript files.
source: docs/bundler/loaders.md#_snippet_3

language: toml
code:
```
name = "John Doe"
age = 35
email = "johndoe@example.com"
```

language: js
code:
```
export default {
  name: "John Doe",
  age: 35,
  email: "johndoe@example.com"
}
```

---

title: Converting Text File to JavaScript Module
description: Illustrates how a `.txt` file is converted to a `.js` module with a default export when used as an entrypoint. This converts the text file to a JavaScript string.
source: docs/bundler/loaders.md#_snippet_5

language: txt
code:
```
Hello, world!
```

language: js
code:
```
export default "Hello, world!";
```

---

title: Serving a Basic REST API with Bun SQLite
description: Demonstrates how to create a simple REST API using Bun's built-in router and `bun:sqlite`. The example includes defining a database schema, handling GET and POST requests for posts, and retrieving a post by ID. It shows how to use `Bun.serve` to define routes and interact with a SQLite database.
source: docs/api/http.md#_snippet_0

language: typescript
code:
```
import type { Post } from "./types.ts";
import { Database } from "bun:sqlite";

const db = new Database("posts.db");
db.exec(`
  CREATE TABLE IF NOT EXISTS posts (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT NOT NULL,
    created_at TEXT NOT NULL
  )
`);

Bun.serve({
  routes: {
    // List posts
    "/api/posts": {
      GET: () => {
        const posts = db.query("SELECT * FROM posts").all();
        return Response.json(posts);
      },

      // Create post
      POST: async req => {
        const post: Omit<Post, "id" | "created_at"> = await req.json();
        const id = crypto.randomUUID();

        db.query(
          `INSERT INTO posts (id, title, content, created_at)
           VALUES (?, ?, ?, ?)`,
        ).run(id, post.title, post.content, new Date().toISOString());

        return Response.json({ id, ...post }, { status: 201 });
      },
    },

    // Get post by ID
    "/api/posts/:id": req => {
      const post = db
        .query("SELECT * FROM posts WHERE id = ?")
        .get(req.params.id);

      if (!post) {
        return new Response("Not Found", { status: 404 });
      }

      return Response.json(post);
    },
  },

  error(error) {
    console.error(error);
    return new Response("Internal Server Error", { status: 500 });
  },
});
```

language: typescript
code:
```
export interface Post {
  id: string;
  title: string;
  content: string;
  created_at: string;
}
```

---

title: Decrypting an Encrypted TLS Key with a Passphrase
description: Demonstrates how to provide a passphrase to decrypt an encrypted TLS private key when configuring TLS in `Bun.serve`. Providing the `passphrase` option allows the server to properly decrypt and use the key for secure communication.
source: docs/api/http.md#_snippet_14

language: typescript
code:
```
Bun.serve({
    fetch(req) {
      return new Response("Hello!!!");
    },

    tls: {
      key: Bun.file("./key.pem"),
      cert: Bun.file("./cert.pem"),
      passphrase: "my-secret-passphrase",
    }
  });
```

---

title: Checking for HMR Availability
description: Demonstrates how to check if Hot Module Replacement (HMR) APIs are available using `import.meta.hot`. It shows the basic conditional check and explains that this check is often not needed as Bun can dead-code eliminate HMR API calls in production builds.
source: docs/bundler/hmr.md#_snippet_0

language: ts
code:
```
if (import.meta.hot) {
  // HMR APIs are available.
}
```

---

title: Defining a Plugin with Setup Function - Typescript
description: Defines a basic Bun plugin with a `name` and a `setup` function. The `setup` function provides access to the build context, allowing the plugin to register lifecycle hooks and modify the build process. This is the foundational structure for creating custom plugins in Bun.
source: docs/bundler/plugins.md#_snippet_0

language: tsx
code:
```
import type { BunPlugin } from "bun";

const myPlugin: BunPlugin = {
  name: "Custom loader",
  setup(build) {
    // implementation
  },
};

```

---

title: Registering a Plugin with Bun Build - Typescript
description: Illustrates how to register a defined plugin (`myPlugin`) with the `Bun.build` function.  The plugin is passed in the `plugins` array within the build configuration object. This activates the plugin during the build process, enabling its custom logic to be executed.
source: docs/bundler/plugins.md#_snippet_1

language: ts
code:
```
await Bun.build({
  entrypoints: ["./app.ts"],
  outdir: "./out",
  plugins: [myPlugin],
});
```

---

title: Streaming Files with Bun File
description: Shows how to stream a file by returning a `Response` object with a `Bun.file` object as the body. Bun automatically uses `sendfile(2)` for zero-copy file transfers when possible.
source: docs/api/http.md#_snippet_2

language: typescript
code:
```
Bun.serve({
  fetch(req) {
    return new Response(Bun.file("./hello.txt"));
  },
});
```

---

title: Hot Reloading Server Handlers with Reload
description: Demonstrates updating a Bun server's handlers without restarting the process using `server.reload()`. This is useful for development and hot reloading, allowing updates to `fetch`, `error`, and `routes`.
source: docs/api/http.md#_snippet_6

language: typescript
code:
```
const server = Bun.serve({
  routes: {
    "/api/version": Response.json({ version: "v1" }),
  },
  fetch(req) {
    return new Response("v1");
  },
});

// Update to new handler
server.reload({
  routes: {
    "/api/version": Response.json({ version: "v2" }),
  },
  fetch(req) {
    return new Response("v2");
  },
});
```

---

title: Building with ES Module Format
description: Demonstrates building with the ES module format using both the JavaScript API and the CLI. Setting `format` to `esm` allows usage of ES Module syntax such as top-level `await` and `import.meta`. This is the default format for Bun.
source: docs/bundler/index.md#_snippet_0

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  format: "esm",
})
```

language: CLI
code:
```
$ bun build ./index.tsx --outdir ./out --format esm
```

---

title: Getting JavaScript Heap Statistics - TypeScript
description: Demonstrates how to import the `heapStats` function from the `bun:jsc` module. This allows you to access detailed memory usage statistics for the JavaScript heap, including heap size, capacity, object counts, and object type counts.
source: docs/project/benchmarking.md#_snippet_0

language: typescript
code:
```
import { heapStats } from "bun:jsc";
console.log(heapStats());
```

---

title: Enabling Minification with Bun Build
description: Demonstrates how to enable minification using the `Bun.build` method and the command-line interface. It illustrates enabling full minification and granular control over whitespace, identifiers, and syntax minification.
source: docs/bundler/index.md#_snippet_0

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  minify: true, // default false
})
```

language: bash
code:
```
$ bun build ./index.tsx --outdir ./out --minify
```

---

title: Creating an App Instance - C++
description: Explains how to create an instance of `uWS::App` to start building a WebSocket application. The constructor takes a struct holding SSL options, or defaults to a regular TCP-only App. Interfaces for both app types are identical.
source: packages/bun-uws/misc/READMORE.md#_snippet_0

language: cpp
code:
```
uWS::App().get("/hello", [](auto *res, auto *req) {
    res->end("Hello World!");
});
```

---

title: Deploying to Production with Minification, Sourcemaps, and Bytecode
description: Demonstrates best practices for deploying Bun applications to production, including the use of `--minify`, `--sourcemap`, and `--bytecode` flags.  These flags optimize code size, provide debugging information, and improve startup time, respectively.
source: docs/bundler/executables.md#_snippet_3

language: sh
code:
```
bun build --compile --minify --sourcemap ./path/to/my/app.ts --outfile myapp
```

language: sh
code:
```
bun build --compile --minify --sourcemap --bytecode ./path/to/my/app.ts --outfile myapp
```

---

title: Using MDX Plugin with Bun Build
description: Demonstrates how to use the `mdx` plugin with `Bun.build()` to process MDX files. It imports the `build` function from `bun`, the `mdx` plugin from `./index.js`, and the prebuilt native addon from `./target/release/libmdx_bun.dylib`. The `build` function is then configured to use the `mdx` plugin, minify the output, and define the `process.env.NODE_ENV` variable.
source: packages/bun-build-mdx-rs/README.md#_snippet_1

language: js
code:
```
import { build } from "bun";
import mdx from "./index.js";

// TODO: This needs to be prebuilt for the current platform
// Probably use a napi-rs template for this
import addon from "./target/release/libmdx_bun.dylib" with { type: "file" };

const results = await build({
  entrypoints: ["./hello.jsx"],
  plugins: [mdx({ addon })],
  minify: true,
  outdir: "./dist",
  define: {
    "process.env.NODE_ENV": JSON.stringify("production"),
  },
});

console.log(results);
```

---

title: Running npm Release Script
description: Demonstrates how to execute the `npm` release script using `bun`. The script can be run to build assets for the latest release or a specified release, with options for dry runs or publishing to npm.
source: packages/bun-release/README.md#_snippet_0

language: sh
code:
```
bun run npm # build assets for the latest release
bun run npm -- <release> # build assets for the provided release
bun run npm -- <release> [dry-run|publish] # build and publish assets to npm
```

---

title: Importing and Using Bun Module Types
description: Illustrates how to import and use the types and functions defined in the `bun` module.  It demonstrates importing `MyInterface`, `MyType`, and `myFunction` from the `'bun'` module and then using them in type annotations and function calls.
source: packages/bun-types/authoring.md#_snippet_1

language: typescript
code:
```
import { type MyInterface, type MyType, myFunction } from "bun";

const myInterface: MyInterface = {};
const myType: MyType = "cool";
myFunction();
```

---

title: Using Global Bun Object
description: Shows how to access and use the types and functions defined in the `bun` module through the global `Bun` object. This provides an alternative to importing the module directly, allowing access to types like `Bun.MyInterface` and functions like `Bun.myFunction`.
source: packages/bun-types/authoring.md#_snippet_2

language: typescript
code:
```
const myInterface: Bun.MyInterface = {};
const myType: Bun.MyType = "cool";
Bun.myFunction();
```

---

title: Importing Macro Functions
description: Demonstrates how to import a function as a macro using the `with { type: 'macro' }` syntax. This syntax indicates that the function should be executed at bundle time rather than runtime, allowing its return value to be inlined directly into the bundle.
source: docs/bundler/macros.md#_snippet_0

language: typescript
code:
```
import { random } from './random.ts' with { type: 'macro' };

console.log(`Your random number is ${random()}`);
```

---

title: Defining an HTTP Event Handler - TypeScript
description: Illustrates how to create a Bun Lambda function that handles HTTP events. The example shows how to access request headers and return a response with a specified status and headers. This approach allows testing the Lambda function locally using `bun run` without code modifications.
source: packages/bun-lambda/README.md#_snippet_1

language: ts
code:
```
export default {
  async fetch(request: Request): Promise<Response> {
    console.log(request.headers.get("x-amzn-function-arn"));
    // ...
    return new Response("Hello from Lambda!", {
      status: 200,
      headers: {
        "Content-Type": "text/plain",
      },
    });
  },
};
```

---

title: Implementing Color Schemes with CSS Variables
description: Demonstrates how to implement light and dark color schemes using CSS variables and media queries. It shows how Bun's CSS bundler converts the `color-scheme` property into CSS variables with proper fallbacks for browsers that don't support it natively, ensuring compatibility across different browsers.
source: docs/bundler/css.md#_snippet_0

language: css
code:
```
:root {
  --lightningcss-light: initial;
  --lightningcss-dark: ;
  color-scheme: light dark;
}

@media (prefers-color-scheme: dark) {
  :root {
    --lightningcss-light: ;
    --lightningcss-dark: initial;
  }
}

.light-theme {
  --lightningcss-light: initial;
  --lightningcss-dark: ;
  color-scheme: light;
}

.dark-theme {
  --lightningcss-light: ;
  --lightningcss-dark: initial;
  color-scheme: dark;
}

.themed-component {
  background-color: var(--lightningcss-light, #ffffff)
    var(--lightningcss-dark, #121212);
  color: var(--lightningcss-light, #333333) var(--lightningcss-dark, #eeeeee);
  border-color: var(--lightningcss-light, #dddddd)
    var(--lightningcss-dark, #555555);
}
```

---

title: Configuring Svelte Plugin in Bunfig Toml
description: Demonstrates how to register `bun-plugin-svelte` within the `bunfig.toml` file. This configuration enables the plugin to be used by Bun's fullstack dev server, providing HMR for Svelte app development.
source: packages/bun-plugin-svelte/README.md#_snippet_1

language: toml
code:
```
[serve.static]
plugins = ["bun-plugin-svelte"]
```

---

title: Starting Development Server With Bun
description: Illustrates how to start the Bun development server using the `bun` command. This command serves the specified `index.html` file and utilizes the configured `bun-plugin-svelte` for HMR.
source: packages/bun-plugin-svelte/README.md#_snippet_2

language: shell
code:
```
$ bun index.html
```

---

title: Handling WebSocket Routes with Callbacks - C++
description: Illustrates the registration of WebSocket routes in uWebSockets using the `uWS::App().ws` method. It demonstrates how to define handlers for various WebSocket events, including `.upgrade`, `.open`, `.message`, `.drain`, `.ping`, `.pong`, and `.close`.  These callbacks enable custom logic for managing WebSocket connections and message processing.
source: packages/bun-uws/misc/READMORE.md#_snippet_1

language: c++
code:
```
uWS::App().ws<PerSocketData>("/*", {
    /* Settings */
    .compression = uWS::SHARED_COMPRESSOR,
    .maxPayloadLength = 16 * 1024,
    .idleTimeout = 10,
    /* Handlers */
    .upgrade = [](auto *res, auto *req, auto *context) {
        /* You may read from req only here, and COPY whatever you need into your PerSocketData.
         * See UpgradeSync and UpgradeAsync examples. */
    },
    .open = [](auto *ws) {

    },
    .message = [](auto *ws, std::string_view message, uWS::OpCode opCode) {
        ws->send(message, opCode);
    },
    .drain = [](auto *ws) {
        /* Check getBufferedAmount here */
    },
    .ping = [](auto *ws) {

    },
    .pong = [](auto *ws) {

    },
    .close = [](auto *ws, int code, std::string_view message) {

    }
});
```

---

title: Referencing Worker in Bun
description: Demonstrates how to reference a worker in Bun using different methods. It illustrates the usage of relative paths and `URL` constructor with `import.meta.url` to create a new `Worker` instance.
source: docs/bundler/executables.md#_snippet_0

language: typescript
code:
```
console.log("Hello from Bun!");

// Any of these will work:
new Worker("./my-worker.ts");
new Worker(new URL("./my-worker.ts", import.meta.url));
new Worker(new URL("./my-worker.ts", import.meta.url).href);
```

---

title: Running the Application and Handling Fallthrough
description: Explains the use of `App.run` to start the event loop, which blocks until no more async work is scheduled. It emphasizes that the event loop should not be stopped explicitly; instead, it should be allowed to fall through by closing sockets, stopping the listen socket, and removing timers.
source: packages/bun-uws/misc/READMORE.md#_snippet_2

language: c++
code:
```
App.run
```

---

title: Creating a Basic HTTP Server
description: Demonstrates a minimal HTTP server setup using uWebSockets. It defines a route that responds with "Hello World!" on all GET requests and listens on port 9001, printing a message to the console upon successful listening. The example shows how to handle basic requests and start the event loop with `App.run`.
source: packages/bun-uws/misc/READMORE.md#_snippet_3

language: c++
code:
```
int main() {
    uWS::App().get("/*", [](auto *res, auto *req) {
        res->end("Hello World!");
    }).listen(9001, [](auto *listenSocket) {
        if (listenSocket) {
            std::cout <<
```

language: c++
code:
```
"Listening for connections..." << std::endl;
        }
    }).run();

    std::cout << "Shoot! We failed to listen and the App fell through, exiting now!" << std::endl;
}
```

---

title: Serving HTML Files with Bun
description: Demonstrates how to import HTML files and pass them to the `routes` option in `Bun.serve()` to serve HTML content. It shows how Bun automatically bundles and serves the associated `<script>` and `<link>` tags.
source: docs/bundler/fullstack.md#_snippet_0

language: typescript
code:
```
import { sql, serve } from "bun";
import dashboard from "./dashboard.html";
import homepage from "./index.html";

const server = serve({
  routes: {
    // ** HTML imports **
    // Bundle & route index.html to "/". This uses HTMLRewriter to scan the HTML for `<script>` and `<link>` tags, run's Bun's JavaScript & CSS bundler on them, transpiles any TypeScript, JSX, and TSX, downlevels CSS with Bun's CSS parser and serves the result.
    "/": homepage,
    // Bundle & route dashboard.html to "/dashboard"
    "/dashboard": dashboard,

    // ** API endpoints ** (Bun v1.2.3+ required)
    "/api/users": {
      async GET(req) {
        const users = await sql`SELECT * FROM users`;
        return Response.json(users);
      },
      async POST(req) {
        const { name, email } = await req.json();
        const [user] =
          await sql`INSERT INTO users (name, email) VALUES (${name}, ${email})`;
        return Response.json(user);
      },
    },
    "/api/users/:id": async req => {
      const { id } = req.params;
      const [user] = await sql`SELECT * FROM users WHERE id = ${id}`;
      return Response.json(user);
    },
  },

  // Enable development mode for:
  // - Detailed error messages
  // - Hot reloading (Bun v1.2.3+ required)
  development: true,

  // Prior to v1.2.3, the `fetch` option was used to handle all API requests. It is now optional.
  // async fetch(req) {
  //   // Return 404 for unmatched routes
  //   return new Response("Not Found", { status: 404 });
  // },
});

console.log(`Listening on ${server.url}`);
```

language: bash
code:
```
$ bun run app.ts
```

---

title: Importing HTML Files as Routes
description: Demonstrates how to import HTML files in JavaScript/TypeScript code to define routes in a Bun application. It illustrates the usage of these imports within the `Bun.serve()` configuration to map URLs to specific HTML files, enabling Bun to handle the bundling of associated assets.
source: docs/bundler/fullstack.md#_snippet_1

language: typescript
code:
```
import dashboard from "./dashboard.html";
import homepage from "./index.html";
```

language: typescript
code:
```
Bun.serve({
  routes: {
    "/": homepage,
    "/dashboard": dashboard,
  }

  fetch(req) {
    // ... api requests
  },
});
```

---

title: Running Bun Scripts
description: Illustrates how to execute Bun scripts for various functionalities such as `ffi`, `log`, `gzip`, `async`, and `sqlite` using the `bun run` command. This command is used to execute the scripts and perform specific actions.
source: bench/README.md#_snippet_0

language: bash
code:
```
bun run ffi
bun run log
bun run gzip
bun run async
bun run sqlite
```

---

title: Running Build - PowerShell
description: Demonstrates running the build process using `bun run build` and subsequent builds using ninja, once bun has setup the environment. `ninja -Cbuild/debug` command compiles the project in the debug configuration.
source: docs/project/building-windows.md#_snippet_7

language: ps1
code:
```
> bun run build

# after the initial `bun run build` you can use the following to build
> ninja -Cbuild/debug
```

---

title: Checking Build Revision - PowerShell
description: Illustrates how to run the built `bun-debug.exe` executable and check its revision. This verifies that the build process completed successfully and produces a functional executable.
source: docs/project/building-windows.md#_snippet_8

language: ps1
code:
```
> .\build\debug\bun-debug.exe --revision
```

---

title: Running Benchmark Scripts
description: Illustrates how to execute the benchmark script using Bun, Node.js, and Deno. It shows the commands to install dependencies with `bun install` and run the `index.mjs` script in each environment. This enables the user to easily run the benchmark in their preferred JavaScript runtime.
source: bench/postgres/README.md#_snippet_0

language: bash
code:
```
bun install
```

language: bash
code:
```
bun ./index.mjs
```

language: bash
code:
```
node index.mjs
```

---

title: Executing Benchmark in Deno
description: Demonstrates the command needed to execute the benchmark script using Deno with full permissions. The `deno run -A index.mjs` command grants all permissions required by the `index.mjs` script to access system resources, such as network and file system, necessary to run the benchmark.
source: bench/postgres/README.md#_snippet_1

language: bash
code:
```
deno run -A index.mjs
```

---

title: Generating Upload File
description: Demonstrates a shell command that generates a file named `hello.txt`. This file will be used in subsequent steps to benchmark file uploads to a web server.
source: bench/stream-file-upload-client/README.md#_snippet_0

language: bash
code:
```
bun generate-file.js
```

---

title: Running HTTP Server (Node.js)
description: Illustrates how to start a web server using Node.js. This server is designed to receive file uploads, and the script `server-node.mjs` handles the incoming request and file processing.
source: bench/stream-file-upload-client/README.md#_snippet_1

language: bash
code:
```
node server-node.mjs
```

---

title: Benchmarking Upload in Bun
description: Demonstrates how to benchmark file uploads using Bun. The `stream-file-bun.js` script simulates uploading a file to a server and measures the time it takes to complete the operation.
source: bench/stream-file-upload-client/README.md#_snippet_2

language: bash
code:
```
bun stream-file-bun.js
```

---

title: Benchmarking Upload in Node.js
description: Illustrates how to benchmark file uploads using Node.js. The `stream-file-node.mjs` script is used to upload a file to a server and measure the performance.
source: bench/stream-file-upload-client/README.md#_snippet_3

language: bash
code:
```
node stream-file-node.mjs
```

---

title: Benchmarking Upload in Deno
description: Demonstrates how to benchmark file uploads using Deno. The `stream-file-deno.js` script simulates uploading a file to a server and measures the upload performance. The `-A` flag grants all permissions to the script.
source: bench/stream-file-upload-client/README.md#_snippet_4

language: bash
code:
```
deno run -A stream-file-deno.js
```

---

title: Importing and Using Yaml Data
description: Shows how to import a `.yaml` file in a TypeScript module after configuring the bundler plugin. The imported `data` object contains the parsed YAML content, which can be accessed directly within components, demonstrating how YAML data can be used within a React component.
source: packages/bun-plugin-yaml/README.md#_snippet_2

language: typescript
code:
```
import data from "./data.yaml";

export function Component() {
  return <div>{data.name}</div>;
}
```

---

title: Running Tests in Bun
description: Illustrates how to execute tests within the Bun runtime environment using `bun test expect-to-equal.test.js`. This specifies the test file to be executed by the Bun test runner.
source: bench/expect-to-equal/README.md#_snippet_1

language: bash
code:
```
# so it doesn't run the vitest one
bun test expect-to-equal.test.js
```

---

title: Running Tests in Jest
description: Demonstrates how to run tests using Jest with the experimental modules flag. `NODE_OPTIONS="--experimental-vm-modules" ./node_modules/.bin/jest expect-to-equal.test.js` ensures that Jest can handle ES modules within the test file.
source: bench/expect-to-equal/README.md#_snippet_2

language: bash
code:
```
# If you remove the import the performance doesn't change much
NODE_OPTIONS="--experimental-vm-modules" ./node_modules/.bin/jest expect-to-equal.test.js
```

---

title: Running Tests in Vitest
description: Illustrates how to execute tests specifically within the Vitest environment. Using `./node_modules/.bin/vitest --run expect-to-equal.vitest.test.js` ensures that the Vitest test runner is used and that tests are executed in run mode.
source: bench/expect-to-equal/README.md#_snippet_3

language: bash
code:
```
./node_modules/.bin/vitest --run expect-to-equal.vitest.test.js
```

---

title: Running Development Servers - Shell
description: Demonstrates how to start a development server using different package managers. It shows the commands `bun run dev`, `npm run dev`, `yarn dev`, and `pnpm dev` to start the application, making it accessible at `http://localhost:3000`.
source: bench/install/README.md#_snippet_3

language: sh
code:
```
$ bun run dev
$ npm run dev
$ yarn dev
$ pnpm dev
```

---

title: Running Chat Server - Bun
description: Illustrates how to start the chat server using Bun. The command `bun ./chat-server.bun.js` executes the server script, which waits for 32 clients by default.
source: bench/websocket-server/README.md#_snippet_0

language: bash
code:
```
bun ./chat-server.bun.js
```

---

title: Running Chat Server - Node
description: Demonstrates how to start the chat server using Node.js with the `ws` package. The command `node ./chat-server.node.mjs` executes the server script.
source: bench/websocket-server/README.md#_snippet_1

language: bash
code:
```
node ./chat-server.node.mjs
```

---

title: Running Chat Server - Deno
description: Demonstrates how to start the chat server using Deno. The command `deno run -A ./chat-server.deno.mjs` executes the server script with all permissions granted (`-A`).
source: bench/websocket-server/README.md#_snippet_2

language: bash
code:
```
deno run -A ./chat-server.deno.mjs
```

---

title: Running Chat Client
description: Shows how to run the client script that connects to the websocket server. The command `node ./chat-client.mjs` executes the client script, which connects 32 clients by default and sends messages.
source: bench/websocket-server/README.md#_snippet_3

language: bash
code:
```
node ./chat-client.mjs
```

---

title: Running Express in Bun
description: Illustrates how to execute the Express application using the Bun runtime. The command `bun ./express.mjs` starts the server using Bun's JavaScript runtime.
source: bench/express/README.md#_snippet_1

language: sh
code:
```
bun ./express.mjs
```

---

title: Running Express in Node
description: Illustrates how to execute the Express application using the Node.js runtime. The command `node ./express.mjs` starts the server using Node.js.
source: bench/express/README.md#_snippet_2

language: sh
code:
```
node ./express.mjs
```

---

title: Running Express in Deno
description: Demonstrates how to run the Express application using the Deno runtime with full permissions. `deno run -A ./express.mjs` starts the server in Deno, granting all permissions necessary for the application to function correctly.
source: bench/express/README.md#_snippet_3

language: sh
code:
```
deno run -A ./express.mjs
```

---

title: Creating JS Functions in Zig
description: Demonstrates how to define a simple function `add` in Zig that takes two 32-bit integers as input and returns their sum, while also handling potential overflow errors using `global.throwPretty`. The `gen` constant is assigned the namespace `bun.gen.math` based on the filename.
source: docs/project/bindgen.md#_snippet_0

language: zig
code:
```
pub fn add(global: *jsc.JSGlobalObject, a: i32, b: i32) !i32 {
    return std.math.add(i32, a, b) catch {
        // Binding functions can return `error.OutOfMemory` and `error.JSError`.
        // Others like `error.Overflow` from `std.math.add` must be converted.
        // Remember to be descriptive.
        return global.throwPretty("Integer overflow while adding", .{});
    };
}

const gen = bun.gen.math; // "math" being this file's basename

const std = @import("std");
const bun = @import("bun");
const jsc = bun.jsc;
```

---

title: Defining API Schema with Bindgen - Typescript
description: Illustrates how to define the API schema for the `add` function using a `.bind.ts` file with the `bindgen` library. This defines the types for the input arguments (`global`, `a`, `b`) and the return type (`i32`) of the Zig function, providing type safety and documentation for the JavaScript interface.
source: docs/project/bindgen.md#_snippet_1

language: typescript
code:
```
import { t, fn } from 'bindgen';

export const add = fn({
  args: {
    global: t.globalObject,
    a: t.i32,
    b: t.i32.default(1),
  },
  ret: t.i32,
});
```

---

title: Compiling the NAPI Module
description: Shows how to compile the NAPI module using `napi-rs` after implementing the native plugin.  It generates a `.node` file that can be used in JavaScript to register the plugin.
source: packages/bun-native-plugin-rs/README.md#_snippet_2

language: bash
code:
```
bun run build
```

---

title: Registering the Plugin in JavaScript
description: Demonstrates how to register the compiled NAPI module as a Bun plugin in JavaScript using the `Bun.build` API. It configures the `onBeforeParse` hook to run on `.ts` files, utilizing the function implemented in the Rust code.
source: packages/bun-native-plugin-rs/README.md#_snippet_3

language: js
code:
```
const result = await Bun.build({
  entrypoints: ["index.ts"],
  plugins: [
    {
      name: "replace-foo-with-bar",
      setup(build) {
        const napiModule = require("path/to/napi_module.node");

        // Register the `onBeforeParse` hook to run on all `.ts` files.
        // We tell it to use function we implemented inside of our `lib.rs` code.
        build.onBeforeParse(
          { filter: /\.ts/ },
          { napiModule, symbol: "replace_foo_with_bar" },
        );
      },
    },
  ],
});
```

---

title: Connecting via WebSocket - Bun Inspector
description: Demonstrates how to connect to the Bun inspector via WebSocket using the `WebSocketInspector` class. The code establishes a connection, enables the `Runtime` domain, evaluates a simple expression, and closes the connection.  The `import` statement is coupled with the usage of the imported module.
source: packages/bun-inspector-protocol/README.md#_snippet_2

language: typescript
code:
```
import { WebSocketInspector } from "bun-inspector-protocol";

// Create a new inspector client
const inspector = new WebSocketInspector("ws://localhost:9229/ws");

// Listen for connection events
inspector.on("Inspector.connected", () => {
  console.log("Connected to debugger!");
});

inspector.on("Inspector.error", error => {
  console.error("Inspector error:", error);
});

// Connect to the debugger
await inspector.start();

// Enable the Runtime domain
await inspector.send("Runtime.enable");

// Execute some code in the target context
const result = await inspector.send("Runtime.evaluate", {
  expression: "2 + 2",
  returnByValue: true,
});

console.log("Evaluation result:", result.result.value); // 4

// Close the connection
inspector.close();
```

---

title: Importing Modules - ESM
description: Demonstrates importing the `node:url` module using ES Modules (ESM) syntax. This import statement makes the URL API available for use in the current module.
source: test/js/node/test/fixtures/document_with_esm_and_cjs_code_snippet.md#_snippet_0

language: javascript
code:
```
import 'node:url';
```

---

title: Requiring Modules - CJS
description: Illustrates how to import the `path` module using CommonJS (CJS) syntax with `require()`. This makes the path manipulation API accessible in the current module.
source: test/js/node/test/fixtures/document_with_esm_and_cjs_code_snippet.md#_snippet_1

language: javascript
code:
```
require('path');
```

---

title: Requiring Path Module - CJS
description: Demonstrates the use of `require` to import the `path` module in CommonJS (CJS) environment. This allows access to path manipulation utilities.
source: test/js/node/test/fixtures/document_with_cjs_and_esm_code_snippet.md#_snippet_0

language: cjs
code:
```
require('path');
```

---

title: Importing URL Module - ESM
description: Illustrates how to import the `node:url` module using ES modules (ESM) syntax. This provides utilities for URL parsing and construction.
source: test/js/node/test/fixtures/document_with_cjs_and_esm_code_snippet.md#_snippet_1

language: mjs
code:
```
import 'node:url';
```

---

title: Running a Production Server with Bun
description: Shows how to run the application for production using the `bun start` command. This command starts the application in a production environment, typically optimized for performance and stability.
source: src/cli/init/README2.default.md#_snippet_2

language: bash
code:
```
bun start
```

---

title: Creating Certificate Using Script
description: Demonstrates how to execute the `createCert.js` script using `node`. This script utilizes the previously installed `asn1.js` and `asn1.js-rfc5280` libraries to create a certificate.
source: test/js/node/test/fixtures/0-dns/README.md#_snippet_3

language: console
code:
```
$ node ./createCert.js
```

---

title: Spawning a Process Using Pwd Command
description: Illustrates how to use `common.pwdCommand` with `child_process.spawn` to execute the `pwd` command in a platform-normalized way. This is useful for ensuring consistent behavior across different operating systems.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_1

language: javascript
code:
```
const common = require('../common');
const { spawn } = require('node:child_process');

spawn(...common.pwdCommand, { stdio: ['pipe'] });
```

---

title: Escaping Values for POSIX Shell
description: Demonstrates how to escape values in a string template literal for use as environment variables, especially paths that might contain special characters. This is essential for safely passing paths to shell commands executed via `child_process` on POSIX systems. On Windows, the function performs minimal escaping, assuming paths generally do not contain characters requiring escaping.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_0

language: js
code:
```
const { escapePOSIXShell } = require('../common');
const fixtures = require('../common/fixtures');
const { execSync } = require('node:child_process');
const origin = fixtures.path('origin');
const destination = fixtures.path('destination');

execSync(...escapePOSIXShell`cp "${origin}" "${destination}"`);

// When you need to specify specific options, and/or additional env variables:
const [cmd, opts] = escapePOSIXShell`cp "${origin}" "${destination}"`;
console.log(typeof cmd === 'string'); // true
console.log(opts === undefined || typeof opts.env === 'object'); // true
execSync(cmd, { ...opts, stdio: 'ignore' });
execSync(cmd, { stdio: 'ignore', env: { ...opts?.env, KEY: 'value' } });
```

---

title: Validating Callback-Based Errors
description: Illustrates how to use `expectsError` to validate errors thrown by callback functions.  This is useful in asynchronous tests to ensure that specific errors are raised with the expected properties or types. It uses `assert.throws` internally and tracks the number of times the returned function is called to prevent false positives.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_1

language: js
code:
```
const { expectWarning } = require('../common');

expectWarning('Warning', 'Foobar is really bad');

expectWarning('DeprecationWarning', 'Foobar is deprecated', 'DEP0XXX');

expectWarning('DeprecationWarning', [
  'Foobar is deprecated', 'DEP0XXX',
]);

expectWarning('DeprecationWarning', [
  ['Foobar is deprecated', 'DEP0XXX'],
  ['Baz is also deprecated', 'DEP0XX2'],
]);

expectWarning('DeprecationWarning', {
  DEP0XXX: 'Foobar is deprecated',
  DEP0XX2: 'Baz is also deprecated',
});

expectWarning({
  DeprecationWarning: {
    DEP0XXX: 'Foobar is deprecated',
    DEP0XX1: 'Baz is also deprecated',
  },
  Warning: [
    ['Multiple array entries are fine', 'SpecialWarningCode'],
    ['No code is also fine'],
  ],
  SingleEntry: ['This will also work', 'WarningCode'],
  SingleString: 'Single string entries without code will also work',
});
```

---

title: Hijacking Stdout Using hijackstdio
description: Demonstrates how to use `hijackStdout` and `restoreStdout` from the `hijackstdio` module to temporarily redirect `stdout`.  This allows you to intercept and process data being written to the console, which is useful for testing and debugging purposes.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_1

language: js
code:
```
const { hijackStdout, restoreStdout } = require('../common/hijackstdio');

hijackStdout((data) => {
  /* Do something with data */
  restoreStdout();
});

console.log('this is sent to the hijacked listener');
```

---

title: Creating Temporary Directories with Files - TypeScript
description: Demonstrates how to use `tempDirWithFiles` from the `harness` to create temporary directories with specified files. This is a useful utility for setting up test environments with predefined file structures and content.
source: test/AGENTS.md#_snippet_3

language: typescript
code:
```
import { tempDirWithFiles } from "harness";
import path from "node:path";

test("creates a temporary directory with files", () => {
  const dir = tempDirWithFiles("my-test-prefix", {
    "file.txt": "Hello, world!",
  });

  expect(await Bun.file(path.join(dir.path, "file.txt")).text()).toBe(
    "Hello, world!",
  );
});
```

---

title: Spawning Bun Processes in Tests - TypeScript
description: Demonstrates how to spawn Bun processes within tests using `bunExe` and `bunEnv` from the `harness` module.  This ensures that the correct Bun build is used and that debug logging is handled appropriately.  The example also shows how to capture the stdout, stderr, and exit code of the spawned process.
source: test/CLAUDE.md#_snippet_2

language: typescript
code:
```
import { bunEnv, bunExe } from "harness";
import { test, expect } from "bun:test";

test("spawns a Bun process", async () => {
  const dir = tempDirWithFiles("my-test-prefix", {
    "my.fixture.ts": `
      console.log("Hello, world!");
    `,
  });

  await using proc = Bun.spawn({
    cmd: [bunExe(), "my.fixture.ts"],
    env: bunEnv,
    cwd: dir,
  });

  const [stdout, stderr, exitCode] = await Promise.all([

    // ReadableStream in Bun supports:
    //  - `await stream.text()`
    //  - `await stream.json()`
    //  - `await stream.bytes()`
    //  - `await stream.blob()`
    proc.stdout.text(),
    proc.stderr.text(),

    proc.exitCode,
  ]);

  expect(stdout).toBe("Hello, world!");
  expect(stderr).toBe("");
  expect(exitCode).toBe(0);
```

---

title: Building and Testing Updates - Bash
description: Illustrates the build and test commands used to verify the Node.js version update in Bun. The `bun bd` command builds Bun, and the following commands execute tests for the V8 and N-API interfaces.
source: .claude/commands/upgrade-nodejs.md#_snippet_1

language: bash
code:
```
bun bd
bun bd -e "console.log(process.version)"
bun bd -e "console.log(process.versions.v8)"
bun bd test test/v8/v8.test.ts
bun bd test test/napi/napi.test.ts
```

---

title: Loading Builtin Modules with Require
description: Illustrates how to load a builtin module using `require` with a string literal, which gets replaced with `$getInternalField($internalModuleRegistry, <number>)` during the build process. This directly loads the module by its numerical ID, skipping the resolver for inter-internal modules, optimizing internal module references.
source: src/js/README.md#_snippet_1

language: ts
code:
```
const fs = require("fs"); // load another builtin module

export default {
  hello: 2,
  world: 3,
};
```

---

title: Running Tests - Single Test File
description: Illustrates how to run a specific test file using the debug build of Bun. This ensures that any local changes are included in the test execution, which is crucial for development and debugging.
source: AGENTS.md#_snippet_0

language: shell
code:
```
bun bd test test/js/bun/http/serve.test.ts
```

---

title: Running Tests - Fuzzy Matching
description: Demonstrates how to run a test file using a fuzzy match on the filename with the debug build. This is useful when you don't want to type the full path to the test file, especially during rapid iteration and testing.
source: AGENTS.md#_snippet_1

language: shell
code:
```
bun bd test http/serve.test.ts
```

---

title: Running Tests - With Filter
description: Shows how to run a specific test within a file by filtering with a string. This allows you to target a single test case when working on a specific piece of functionality, improving efficiency.
source: AGENTS.md#_snippet_2

language: shell
code:
```
bun bd test test/js/bun/http/serve.test.ts -t "should handle"
```

---

title: Extracting Import/Export Statements - JavaScript
description: Illustrates extracting `import` and `export` statements to the top level of the output file when a module requires wrapping, ensuring that ES module syntax requirements are met.  The module's actual code is placed inside a wrapper function (`__esm`).
source: src/bundler/linker_context/README.md#_snippet_1

language: javascript
code:
```
// Input module that needs wrapping:
import * as utils from "./utils.js";
export const data = utils.process();

// Output with wrapper:
import * as utils from "./utils.js"; // â† extracted to outside_wrapper_prefix
var init_module = __esm(() => {
  // â† wrapper function
  const data = utils.process(); // â† inside wrapper
});
```

---

title: Transforming a Complex Module - JavaScript
description: Demonstrates the transformation of a complex module with mixed `import` and `export` statements, showing how they are reorganized around a wrapper function.  Imports and re-exports are moved to the top level, and the module body is placed inside the `__esm` wrapper.
source: src/bundler/linker_context/README.md#_snippet_4

language: javascript
code:
```
// demo.js
import * as utils from "./utils.js";
export * from "./constants.js";
export const greeting = "hello";
export default function () {
  return utils.format(greeting);
}

// When utils namespace is accessed dynamically elsewhere:
const prop = "format";
utils[prop]("test"); // Forces namespace preservation
```

language: javascript
code:
```
// outside_wrapper_prefix (top-level):
import * as utils from './utils.js';
import * as ns_constants from './constants.js';

// inside_wrapper_prefix (start of wrapper):
__reExport(exports, ns_constants);

// inside_wrapper_suffix (main module body in wrapper):
var init_demo = __esm(() => {
  const greeting = 'hello';
  function default() { return utils.format(greeting); }
  // exports object setup...
});
```

---

title: Tracking Cross-Chunk Imports - JavaScript
description: Illustrates how cross-chunk imports are tracked during the chunking process. The example shows how `utilityFunction` is exported from `chunk-a` and imported in `chunk-b`, with this dependency being tracked as a cross-chunk import for dependency resolution and optimization.
source: src/bundler/linker_context/README.md#_snippet_0

language: javascript
code:
```
// Chunk A exports:
export const utilityFunction = () => { ... };

// Chunk B imports and uses:
import { utilityFunction } from './chunk-a';  // â† Tracked as cross-chunk import
```

---

title: Generating Code for Lazy Exports - JavaScript
description: Demonstrates how `generateCodeForLazyExport` converts expression-style loaders, such as JSON files, into proper module exports. The example shows how a JSON file is transformed into either an ESM default export or a CJS module export, depending on the target module format, during the linking phase.
source: src/bundler/linker_context/README.md#_snippet_6

language: javascript
code:
```
// For ESM output:
var data_default = { name: "example" };

// For CJS output:
module.exports = { name: "example" };
```

---

title: Testing Module Exports with Runtime Files
description: Tests the exports of a module using `runtimeFiles`. `/entry.js` exports a constant and re-exports everything from itself. `runtimeFiles` defines `/test.js`, which imports the bundled output and stringifies the imported module to check if the exported value matches the expected JSON string.
source: test/bundler/expectBundled.md#_snippet_2

language: typescript
code:
```
itBundled("importstar/ExportSelfES6", {
  files: {
    "/entry.js": /* js */ `
      export const foo = 123
      export * from './entry'
    `,
  },
  format: "esm",
  // `runtimeFiles` are only available after the bundle is created, which lets you
  // keep some files secret, like preventing externals from being bundled, etc.
  // It can also be used to provide a runtime entry point.
  runtimeFiles: {
    "/test.js": /* js */ `
      import * as foo from './out.js'
      // Try avoiding relying on Bun's object formatter, instead use JSON.stringify when possible
      // This will avoid any changes to how these objects are formatted.
      console.log(JSON.stringify(foo));
    `,
  },
  run: {
    file: "/test.js",
    // console.log is a great way to assert the proper values exist, but when needed you
    // can also reach for `import \"assert\"` and run that in the test.
    stdout: '{"foo":123}',
  },
});
```

---

title: Analyzing Module Classification
description: Demonstrates how to analyze import patterns to determine CommonJS module classification. This step involves examining import records, marking modules as CommonJS, and setting up wrapper flags.
source: src/bundler/linker_context/README.md#_snippet_3

language: javascript
code:
```
// Import star or default import from a module with no ES6 exports
// forces that module to be treated as CommonJS
import * as ns from "./empty-file"; // Forces './empty-file' to be CJS
import defaultValue from "./empty-file"; // Forces './empty-file' to be CJS

// Regular named imports don't force CommonJS treatment
import { namedExport } from "./empty-file"; // './empty-file' stays ES6 compatible
```

---

title: Propagating Dependency Wrappers
description: Demonstrates how the dependency wrapper propagation algorithm ensures that any module importing a CommonJS module is properly set up to handle wrapper functions.  This recursively marks and wraps modules in the dependency tree.
source: src/bundler/linker_context/README.md#_snippet_5

language: javascript
code:
```
// For each module that needs wrapping:
function wrap(sourceIndex) {
  if (alreadyWrapped[sourceIndex]) return;

  // Mark this module as wrapped
  flags[sourceIndex].wrap = (isCommonJS ? .cjs : .esm);

  // Recursively wrap all modules that import this one
  for (importRecord in allImportsOfThisModule) {
    wrap(importRecord.sourceIndex);
  }
}
```

---

title: Resolving Export Star Statements
description: Demonstrates how to resolve export star statements by collecting all the exports from target modules and making them available. It also addresses export star conflicts.
source: src/bundler/linker_context/README.md#_snippet_7

language: javascript
code:
```
// For: export * from './moduleA'; export * from './moduleB';
function resolveExportStars(currentModule) {
  for (exportStarTarget in currentModule.exportStars) {
    // Skip if target is CommonJS (exports not statically known)
    if (exportStarTarget.isCommonJS) continue;

    // Add all named exports from target, except 'default'
    for (exportName in exportStarTarget.namedExports) {
      if (exportName === "default") continue; // export * never re-exports default

      if (!currentModule.resolvedExports[exportName]) {
        currentModule.resolvedExports[exportName] =
          exportStarTarget.exports[exportName];
      } else {
        // Mark as potentially ambiguous - multiple sources for same name
        currentModule.resolvedExports[exportName].potentiallyAmbiguous = true;
      }
    }

    // Recursively resolve nested export stars
    resolveExportStars(exportStarTarget);
  }
}
```

---

title: Buffering HTTP Responses - Zig
description: Illustrates how the `HTTPServerWritable` (instantiated as `HTTPSResponseSink`) in `streams.zig` uses intelligent write buffering to improve HTTP server performance. It describes how the `write` method appends data to an internal buffer instead of immediately issuing a syscall, and how the `send` method handles backpressure using `res.write()` and `onWritable` callbacks.
source: src/bun.js/STREAMS.md#_snippet_2

language: zig
code:
```
- **Intelligent Write Buffering:** The `write` method (`writeBytes`, `writeLatin1`, etc.) does not immediately issue a `write` syscall. It appends the incoming `streams.Result` slice to its internal `buffer: bun.ByteList`. This coalesces multiple small, high-frequency writes (common in streaming LLM responses or SSE) into a single, larger, more efficient syscall.

- **Backpressure Logic (`send` method):** The `send` method attempts to write the buffer to the underlying `uWebSockets` socket.
  - It uses the optimized `res.tryEnd()` for the final chunk.
  - If `res.write()` or `res.tryEnd()` returns a "backpressure" signal, the sink immediately sets `this.has_backpressure = true` and registers an `onWritable` callback.
  - The `onWritable` callback is triggered by the OS/`uWebSockets` when the socket can accept more data. It clears the backpressure flag, attempts to send the rest of the buffered data, and then signals `ready()` back to the source stream via its `streams.Signal`. This creates a tight, efficient, native backpressure loop.
```

---

title: Implementing Auto-Flushing - Zig
description: Explains the auto-flusher mechanism within the `HTTPServerWritable` which balances throughput and latency. It details how `registerAutoFlusher` queues a task to run after JavaScript microtasks complete, allowing multiple `writer.write()` calls to batch into one syscall while ensuring low latency for real-time applications.
source: src/bun.js/STREAMS.md#_snippet_3

language: zig
code:
```
- **The Auto-Flusher (`onAutoFlush`):** This mechanism provides a perfect balance between throughput and latency.
  - **Mechanism:** When `write` is called but the `highWaterMark` is not reached, `registerAutoFlusher` queues a task that runs AFTER all JavaScript microtasks are completed.
  - **Execution:** The `onAutoFlush` method is executed by the event loop at the very end of the current tick, after all JavaScript microtasks are completed. It checks `!this.hasBackpressure()` and, if the buffer is not empty, calls `sendWithoutAutoFlusher` to flush the buffered data.
  - **Architectural Impact:** This allows multiple `writer.write()` calls within a single synchronous block of JS code to be batched into one syscall, but guarantees that the data is sent immediately after the current JS task completes, ensuring low, predictable latency for real-time applications.
```

---

title: Converting Statements for Chunking- Zig
description: Illustrates the statement processing algorithm used during chunking. It details the handling of import, export, and regular statements, along with re-export calls and special cases like default exports and circular dependencies in `convertStmtsForChunkForDevServer.zig`.
source: src/bundler/linker_context/README.md#_snippet_0

language: text
code:
```
**Statement processing algorithm**:

1. **Analyze context**: Determine if wrapping is needed and if exports should be stripped
2. **Process each statement**:
   - Import statements â†’ Extract to `outside_wrapper_prefix` if wrapping
   - Export statements â†’ Transform or remove based on bundling context
   - Regular statements â†’ Place in `inside_wrapper_suffix`
   - Re-export calls â†’ Generate runtime code in `inside_wrapper_prefix`
3. **Handle special cases**: Default exports, re-exports, CommonJS compatibility

**Critical edge cases handled**:

- **Export star from external modules**: Converted to import + runtime re-export call
- **Dynamic namespace access**: Preserves namespace objects when static analysis can't determine access patterns
- **Mixed module formats**: Handles ESM â†’ CJS conversion while preserving semantics
- **Circular dependencies**: Ensures proper initialization order through wrapper placement

This function is essential for maintaining JavaScript module semantics across different output formats while enabling optimal bundling strategies.

#### `convertStmtsForChunkForDevServer.zig`

**Purpose**: Special statement conversion for development server (HMR).

**Key functions**:

- HMR-specific code generation
- Development-time optimizations
- Live reload integration
```

---

title: Describing Data Flow
description: Illustrates the data flow during the bundling process, outlining the progression from parsed AST to writing output files to disk. It covers phases like analysis, optimization, chunking, generation, and post-processing.
source: src/bundler/linker_context/README.md#_snippet_6

language: text
code:
```
## Data Flow

1. **Input**: Parsed AST from all source files
2. **Load Phase**: Initialize graph and runtime symbols
3. **Analysis Phase**: Scan imports/exports, determine module relationships
4. **Optimization Phase**: Tree shaking, code splitting, symbol renaming
5. **Chunk Phase**: Compute final chunk structure and dependencies
6. **Generation Phase**: Generate code for each chunk in parallel
7. **Post-processing Phase**: Finalize chunks with cross-chunk code
8. **Output Phase**: Write files to disk or return in-memory
```

---

title: Running a Script from Package.json - Bun
description: Demonstrates how to define and run a script from the `package.json` file using `bun run`. The example adds a `start` script that executes `bun run index.ts`, enabling a convenient way to start the server. The example showcases the performance benefits of `bun run` compared to `npm run`.
source: docs/quickstart.md#_snippet_3

language: json-diff
code:
```
  {
    "name": "quickstart",
    "module": "index.ts",
    "type": "module",
+   "scripts": {
+     "start": "bun run index.ts"
+   },
    "devDependencies": {
      "@types/bun": "latest"
    }
  }
```

language: bash
code:
```
$ bun run start
  $ bun run index.ts
  Listening on http://localhost:3000 ...
```

---

title: Skipping a Test Using the Bun Test Runner - TypeScript
description: Demonstrates how to skip a test using `test.skip` in Bun's test runner. This prevents the test from being executed and marks it as skipped in the output. This is useful for temporarily disabling tests for unimplemented features or known issues.
source: docs/guides/test/skip-tests.md#_snippet_0

language: typescript
code:
```
import { test } from "bun:test";

test.skip("unimplemented feature", () => {
  expect(Bun.isAwesome()).toBe(true);
});
```

---

title: Cloning Cat Utility
description: Illustrates a `cat` clone implemented using Bun.js, demonstrating file system interaction. The script imports `resolve`, `write`, `stdout`, `file`, and `argv` from the `bun` module.  It then reads a file specified as a command-line argument and writes its contents to standard output, leveraging Bun's optimized file reading and writing capabilities.
source: docs/benchmarks.md#_snippet_1

language: javascript
code:
```
import { resolve } from "path";
import { write, stdout, file, argv } from "bun";

const path = resolve(argv.at(-1));

await write(
  // stdout is a Blob
  stdout,
  // file(path) returns a Blob - https://developer.mozilla.org/en-US/docs/Web/API/Blob
  file(path),
);
```

---

title: Rendering React Server-Side
description: Illustrates server-side rendering (SSR) with React in Bun.js. The code imports `renderToReadableStream` from `react-dom/server` and defines a server endpoint that renders a React component to a readable stream, returning it as the response. This improves initial load times and SEO by sending pre-rendered HTML to the client.
source: docs/benchmarks.md#_snippet_3

language: javascript
code:
```
import { renderToReadableStream } from "react-dom/server";

const dt = new Intl.DateTimeFormat();

export default {
  port: 3000,
  async fetch(request: Request) {
    return new Response(
      await renderToReadableStream(
        <html>
          <head>
            <title>Hello World</title>
          </head>
          <body>
            <h1>Hello from React!</h1>
            <p>The date is {dt.format(new Date())}</p>
          </body>
        </html>,
      ),
    );
  },
};
```

---

title: Re-running Tests Multiple Times - Bun
description: Demonstrates how to use the `--rerun-each` flag with the Bun test runner to re-run each test multiple times. This is useful for identifying flaky tests.
source: docs/guides/test/rerun-each.md#_snippet_0

language: shell
code:
```
# re-run each test 10 times
$ bun test --rerun-each 10
```

---

title: Watching Directory for Changes
description: Demonstrates how to use `fs.watch` to listen for file system changes in the current directory. This operation is shallow by default, meaning that changes in subdirectories are not detected.
source: docs/guides/read-file/watch.md#_snippet_0

language: ts
code:
```
import { watch } from "fs";

const watcher = watch(import.meta.dir, (event, filename) => {
  console.log(`Detected ${event} in ${filename}`);
});
```

---

title: Watching Directory for Changes Recursively
description: Illustrates how to use the `recursive: true` option with `fs.watch` to listen for file system changes in the current directory and its subdirectories. This ensures that changes in nested folders are also detected.
source: docs/guides/read-file/watch.md#_snippet_1

language: ts
code:
```
import { watch } from "fs";

const watcher = watch(
  import.meta.dir,
  { recursive: true },
  (event, filename) => {
    console.log(`Detected ${event} in ${filename}`);
  },
);
```

---

title: Watching Directory for Changes Using Async Iteration
description: Demonstrates how to use `fs/promises` and `for await...of` to listen for file system changes asynchronously. This approach allows processing events using async iteration instead of a callback function, providing a cleaner syntax for asynchronous operations.
source: docs/guides/read-file/watch.md#_snippet_2

language: ts
code:
```
import { watch } from "fs/promises";

const watcher = watch(import.meta.dir);
for await (const event of watcher) {
  console.log(`Detected ${event.eventType} in ${event.filename}`);
}
```

---

title: Matching Imports With Exports - Javascript
description: Illustrates the `matchImport` function, which resolves import statements to their corresponding export definitions. It traces re-exports, establishes dependencies between files, and handles CommonJS compatibility by identifying unbound symbols for special handling, ensuring correct module linking during code generation.
source: src/bundler/linker_context/README.md#_snippet_0

language: javascript
code:
```
// For: import { helper } from './utils.js';
function matchImport(importRef, importSourceIndex) {
  let targetModule = importSourceIndex;
  let targetRef = importRef;

  // If this import is actually a re-export, follow the chain
  while (importsToBindMap[targetModule][targetRef]) {
    const reExportData = importsToBindMap[targetModule][targetRef];
    targetModule = reExportData.sourceIndex;
    targetRef = reExportData.importRef;
  }

  // Add dependency from importing part to all parts that declare the symbol
  const declaringParts = symbolToPartsMap[targetModule][targetRef];
  for (partIndex of declaringParts) {
    importingPart.dependencies.add({
      sourceIndex: targetModule,
      partIndex: partIndex,
    });
  }
}
```

---

title: Generating Namespace Object - Javascript
description: Illustrates the generation of a namespace object for the `utils.js` module, which exports `helper`, `version`, and a default value.  It shows how these exports are accessed through the `utils` namespace when imported with `import * as utils from "./utils.js";`.
source: src/bundler/linker_context/README.md#_snippet_4

language: javascript
code:
```
// utils.js
export const helper = () => "help";
export const version = "1.0";
export default "DEFAULT_VALUE";

// app.js
import * as utils from "./utils.js";
console.log(utils.helper()); // Accesses namespace object

// Generated namespace object for utils.js:
var utils_exports = {
  helper: helper,
  version: version,
  default: "DEFAULT_VALUE",
  __esModule: true,
};
```

---

title: Bailing After a Failure Threshold with Bun Test
description: Illustrates how to specify a failure threshold using the `--bail` flag followed by a number with the `bun test` command. The test run will halt after the specified number of failures is reached.
source: docs/guides/test/bail.md#_snippet_1

language: shell
code:
```
# bail after 10 failures
$ bun test --bail=10
```

---

title: Running a Test with an Existing Snapshot
description: Demonstrates the output when running a test where a snapshot already exists.  Bun reads the snapshot file and compares it to the current value.  If they are identical, the test passes.
source: docs/guides/test/snapshot.md#_snippet_3

language: sh
code:
```
$ bun test
bun test v$BUN_LATEST_VERSION (9c68abdb)

test/snap.test.ts:
âœ“ snapshot [1.05ms]

 1 pass
 0 fail
 1 snapshots, 1 expect() calls
Ran 1 tests across 1 files. [101.00ms]
```

---

title: Converting ReadableStream to Buffer - TypeScript
description: Demonstrates how to convert a `ReadableStream` to an `ArrayBuffer` using `Bun.readableStreamToArrayBuffer()`, then creates a Node.js `Buffer` from the `ArrayBuffer`. This is useful when you need to work with streams in a format compatible with Node.js APIs.
source: docs/guides/streams/to-buffer.md#_snippet_0

language: typescript
code:
```
const stream = new ReadableStream();
const arrBuf = await Bun.readableStreamToArrayBuffer(stream);
const nodeBuf = Buffer.from(arrBuf);
```

---

title: Enabling Default Code Coverage in Bunfigtoml
description: Illustrates how to configure code coverage to be always enabled by default in `bun test` by adding `coverage = true` to the `bunfig.toml` file under the `[test]` section. This eliminates the need to manually specify the `--coverage` flag for each test run.
source: docs/guides/test/coverage.md#_snippet_1

language: toml
code:
```
[test]
coverage = true # always enable coverage
```

---

title: Switching Test Imports - TypeScript
description: Demonstrates how to switch from `@jest/globals` to `bun:test` for test imports in TypeScript. This involves changing the import statement to use Bun's testing library directly.
source: docs/guides/test/migrate-from-jest.md#_snippet_1

language: ts-diff
code:
```
- import {test, expect} from "@jest/globals";
+ import {test, expect} from "bun:test";
```

---

title: Listening for SIGINT Event - Node.js
description: Demonstrates how to listen for the `SIGINT` signal, which is triggered when the user presses Ctrl+C. The example shows how to intercept the signal, log a message to the console, and then explicitly exit the process using `process.exit()`. This is useful for gracefully handling Ctrl+C interrupts and performing cleanup tasks before exiting.
source: docs/guides/process/ctrl-c.md#_snippet_0

language: ts
code:
```
process.on("SIGINT", () => {
  console.log("Ctrl-C was pressed");
  process.exit();
});
```

---

title: Executing Specific Test Files with Bun Test
description: Illustrates how to target specific test files by providing a positional argument to the `bun test` command. This allows developers to focus on a subset of tests, reducing execution time when working on specific features or bug fixes.
source: docs/guides/test/run-tests.md#_snippet_1

language: sh
code:
```
$ bun test test3
```

---

title: Upgrading Bun to the Latest Version
description: Demonstrates how to upgrade Bun to the latest stable version using the `bun upgrade` command. This command updates the installed Bun binary to the newest release.
source: docs/installation.md#_snippet_12

language: sh
code:
```
$ bun upgrade
```

---

title: Configuring Bun Test Preload Scripts (bunfigtoml)
description: Demonstrates how to configure Bun's test runner to use the Happy DOM and Testing Library preload scripts. By adding the scripts to the `preload` array in `bunfig.toml`, the specified setup will run before each test suite.
source: docs/guides/test/testing-library.md#_snippet_4

language: toml
code:
```
[test]
preload = ["./happydom.ts", "./testing-library.ts"]
```

---

title: Parsing Arguments with `util.parseArgs` - Bun
description: Illustrates how to use `util.parseArgs` to parse command-line arguments in a Bun script. It defines options for `--flag1` (boolean) and `--flag2` (string), then parses `Bun.argv` to extract values and positional arguments. This is useful for accessing the flags from the command line.
source: docs/guides/process/argv.md#_snippet_1

language: typescript
code:
```
import { parseArgs } from "util";

const { values, positionals } = parseArgs({
  args: Bun.argv,
  options: {
    flag1: {
      type: 'boolean',
    },
    flag2: {
      type: 'string',
    },
  },
  strict: true,
  allowPositionals: true,
});

console.log(values);
console.log(positionals);
```

---

title: Listening to SIGINT Signal - TypeScript
description: Demonstrates how to listen for the `SIGINT` signal using `process.on()`. This is useful for gracefully handling interrupt signals, such as when a user presses Ctrl+C in the terminal, allowing the program to perform cleanup actions before exiting.
source: docs/guides/process/os-signals.md#_snippet_0

language: typescript
code:
```
process.on("SIGINT", () => {
  console.log(
```

---

title: Spying on Methods in Bun Test (TypeScript)
description: Shows how to use `Bun.spy` to create spies on methods within your tests. This allows you to track method calls and verify that they are being executed as expected.
source: README.md#_snippet_13

language: typescript
code:
```
import { describe, expect, it, spyOn } from 'bun:test';

class Calculator {
  add(a: number, b: number) {
    return a + b;
  }
}

describe('Calculator', () => {
  it('should call add with correct arguments', () => {
    const calculator = new Calculator();
    const addSpy = spyOn(calculator, 'add');

    calculator.add(1, 2);

    expect(addSpy).toHaveBeenCalledWith(1, 2);
  });
});
```

---

title: Mocking Functions in Bun Test (TypeScript)
description: Illustrates how to use `Bun.mock` to mock functions in `bun test`. This technique replaces the original function with a mock implementation, enabling controlled testing scenarios.
source: README.md#_snippet_14

language: typescript
code:
```
import { describe, expect, it, mock } from 'bun:test';

function fetchUserData(userId: number) {
  // In real code, this would fetch data from an API
  return `User data for ID: ${userId}`;
}

describe('fetchUserData', () => {
  it('should return mocked user data', () => {
    mock(() => fetchUserData, () => 'Mocked user data');

    const data = fetchUserData(123);

    expect(data).toBe('Mocked user data');
  });
});
```

---

title: Hashing a Password (TypeScript)
description: Demonstrates how to hash a password using `Bun.password.hash`.  Password hashing is crucial for storing passwords securely by transforming them into a non-reversible format.
source: README.md#_snippet_16

language: typescript
code:
```
const password = "my-secret-password";
const hashedPassword = await Bun.password.hash(password);

console.log("Hashed password:", hashedPassword);
```

---

title: Spawning Bun Processes to Utilize Reuseport - TS
description: Illustrates how to spawn multiple `bun` processes, each running the server code from `server.ts`. It utilizes `navigator.hardwareConcurrency` to determine the number of CPU cores and creates a corresponding number of Bun instances, leveraging the `reusePort` functionality to share the same port across all instances.
source: docs/guides/http/cluster.md#_snippet_1

language: typescript
code:
```
import { spawn } from "bun";

const cpus = navigator.hardwareConcurrency; // Number of CPU cores
const buns = new Array(cpus);

for (let i = 0; i < cpus; i++) {
  buns[i] = spawn({
    cmd: ["bun", "./server.ts"],
    stdout: "inherit",
    stderr: "inherit",
    stdin: "inherit",
  });
}

function kill() {
  for (const bun of buns) {
    bun.kill();
  }
}

process.on("SIGINT", kill);
process.on("exit", kill);
```

---

title: Configuring Svelte Plugin for Bun
description: Illustrates how to create a Bun plugin (`svelte-loader.js`) to handle Svelte component compilation during testing. The plugin uses `svelte/compiler` to transform `.svelte` files into JavaScript modules and registers happy-dom for a DOM environment.
source: docs/guides/test/svelte-test.md#_snippet_1

language: typescript
code:
```
import { plugin } from "bun";
import { compile } from "svelte/compiler";
import { readFileSync } from "fs";
import { beforeEach, afterEach } from "bun:test";
import { GlobalRegistrator } from "@happy-dom/global-registrator";

beforeEach(async () => {
  await GlobalRegistrator.register();
});

afterEach(async () => {
  await GlobalRegistrator.unregister();
});

plugin({
  name: "svelte loader",
  setup(builder) {
    builder.onLoad({ filter: /\.svelte(\?[^.]+)?$/ }, ({ path }) => {
      try {
        const source = readFileSync(
          path.substring(
            0,
            path.includes("?") ? path.indexOf("?") : path.length
          ),
          "utf-8"
        );

        const result = compile(source, {
          filename: path,
          generate: "client",
          dev: false,
        });

        return {
          contents: result.js.code,
          loader: "js",
        };
      } catch (err) {
        throw new Error(`Failed to compile Svelte component: ${err.message}`);
      }
    });
  },
});

```

---

title: Parsing Form Data and Saving Blob (index.ts)
description: Extends the HTTP server to handle `POST` requests to the `/action` endpoint. It parses the incoming request's `FormData`, extracts the `name` (string) and `profilePicture` (Blob) fields, and writes the `profilePicture` Blob to disk as `profilePicture.png` using `Bun.write()`. It throws an error if no profile picture is uploaded.
source: docs/guides/http/file-uploads.md#_snippet_2

language: typescript
code:
```
const server = Bun.serve({
  port: 4000,
  async fetch(req) {
    const url = new URL(req.url);

    // return index.html for root path
    if (url.pathname === "/")
      return new Response(Bun.file("index.html"), {
        headers: {
          "Content-Type": "text/html",
        },
      });

+   // parse formdata at /action
+   if (url.pathname === '/action') {
+     const formdata = await req.formData();
+     const name = formdata.get('name');
+     const profilePicture = formdata.get('profilePicture');
+     if (!profilePicture) throw new Error('Must upload a profile picture.');
+     // write profilePicture to disk
+     await Bun.write('profilePicture.png', profilePicture);
+     return new Response("Success");
+   }

    return new Response("Not Found", { status: 404 });
  },
});
```

---

title: Remapping Imports-TypeScript
description: Illustrates how the `paths` configuration in `tsconfig.json` remaps import paths. The example shows that importing `my-custom-name` resolves to `zod`, and `@components/Button` resolves to `./src/components/Button`, simplifying import statements.
source: docs/guides/runtime/tsconfig-paths.md#_snippet_1

language: typescript
code:
```
import { z } from "my-custom-name"; // imports from "zod"
import { Button } from "@components/Button"; // imports from "./src/components/Button"
```

---

title: Configuring Compiler Options for a Bun Project (tsconfigjson)
description: Illustrates the recommended `compilerOptions` for a Bun project in `tsconfig.json`. This configuration enables features like top-level await, extensioned or extensionless imports, and JSX, while also enforcing best practices such as strict type checking and module syntax.
source: docs/guides/runtime/typescript.md#_snippet_1

language: jsonc
code:
```
{
  "compilerOptions": {
    // Environment setup & latest features
    "lib": ["ESNext"],
    "target": "ESNext",
    "module": "Preserve",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,

    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true,

    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false,
  },
}
```

---

title: Appending Data Asynchronously with Promises - TypeScript
description: Demonstrates how to asynchronously append data to a file using `fs.appendFile` from the `node:fs/promises` module. This creates the file if it doesn't exist. The content passed to `appendFile` is a string that represents the data to be appended to the file.
source: docs/guides/write-file/append.md#_snippet_0

language: typescript
code:
```
import { appendFile } from "node:fs/promises";

await appendFile("message.txt", "data to append");
```

---

title: Defining Environment Variables (dotenv)
description: Illustrates how to define environment variables in a `.env` file. Bun automatically reads environment variables from `.env` files, including environment-specific files like `.env.production` and local overrides in `.env.local`. The order determines precedence, with later files overriding earlier ones.
source: docs/guides/runtime/set-env.md#_snippet_1

language: txt
code:
```
FOO=hello
BAR=world
```

---

title: Getting Hours With Time Zone
description: Shows how setting the `TZ` environment variable affects the value returned by `new Date().getHours()`. It demonstrates the difference in the returned hour before and after setting the `TZ` variable, highlighting the importance of timezone configuration.
source: docs/guides/runtime/timezone.md#_snippet_2

language: typescript
code:
```
new Date().getHours(); // => 18

process.env.TZ = "America/New_York";

new Date().getHours(); // => 21
```

---

title: Writing Strings and Binary Data - TypeScript
description: Illustrates the flexibility of the `write` method, which accepts both strings and binary data such as `Buffer` and `Uint8Array`.  Shows how to write different data types to the `FileSink` and then flush the buffer to persist the changes.
source: docs/guides/write-file/filesink.md#_snippet_1

language: typescript
code:
```
w.write("hello");
w.write(Buffer.from("there"));
w.write(new Uint8Array([0, 255, 128]));
writer.flush();
```

---

title: Ending File Writing with End - TypeScript
description: Illustrates how to properly finalize writing to a file by calling the `.end()` method on the `FileSink`. This ensures that any remaining data in the buffer is flushed to disk and the file is closed, preventing data loss.
source: docs/guides/write-file/filesink.md#_snippet_3

language: typescript
code:
```
writer.end();
```

---

title: Writing a String to a File Using BunFile - TS
description: Demonstrates writing a string to a file using a `BunFile` object with `Bun.write()`. This approach associates the data with a specific path defined by the `BunFile`.
source: docs/guides/write-file/basic.md#_snippet_2

language: ts
code:
```
const path = Bun.file("./file.txt");
await Bun.write(path, "Lorem ipsum");
```

---

title: Specifying Bun Version in GitHub Actions
description: Illustrates how to specify a specific version of Bun to install using the `bun-version` input of the `oven-sh/setup-bun` GitHub Action. This allows you to control the Bun version used in your workflow, ensuring compatibility and reproducibility.
source: docs/guides/runtime/cicd.md#_snippet_1

language: yaml-diff
code:
```
name: my-workflow
jobs:
  my-job:
    name: my-job
    runs-on: ubuntu-latest
    steps:
      # ...
      - uses: oven-sh/setup-bun@v2
+       with:
+         bun-version: 1.2.0 # or "latest", "canary", <sha>
```

---

title: Accessing Environment Variables - TypeScript
description: Demonstrates accessing environment variables using `process.env` in Bun. This method retrieves the value of the `API_TOKEN` environment variable, which is commonly used to store sensitive information such as API keys.
source: docs/guides/runtime/read-env.md#_snippet_0

language: ts
code:
```
process.env.API_TOKEN; // => "secret"
```

---

title: Accessing Environment Variables Using BunEnv - TypeScript
description: Illustrates accessing environment variables using `Bun.env` as an alias for `process.env`.  This simplifies accessing the `API_TOKEN` environment variable within Bun's runtime environment.
source: docs/guides/runtime/read-env.md#_snippet_1

language: ts
code:
```
Bun.env.API_TOKEN; // => "secret"
```

---

title: Configuring Artifactory Registry - TOML
description: Illustrates configuring the JFrog Artifactory registry using a `bunfig.toml` file. The `url` field specifies the Artifactory endpoint and authentication token, enabling `bun install` to resolve packages from the private registry.
source: docs/guides/install/jfrog-artifactory.md#_snippet_0

language: toml
code:
```
[install.registry]
url = "https://MY_SUBDOMAIN.jfrog.io/artifactory/api/npm/npm/_auth=MY_TOKEN"
# Bun v1.0.3+ supports using an environment variable here
# url = "$NPM_CONFIG_REGISTRY"
```

---

title: Signing and Verifying the Executable - macOS
description: Signs the executable using the `codesign` command with specified entitlements and verifies the signature.  The `entitlements.plist` file grants the necessary permissions, while the signing identity ensures the application's authenticity, preventing Gatekeeper warnings.
source: docs/guides/runtime/codesign-macos-executable.md#_snippet_3

language: bash
code:
```
$ codesign --entitlements entitlements.plist -vvvv --deep --sign "XXXXXXXXXX" ./myapp --force
$ codesign -vvv --verify ./myapp
```

---

title: Enabling Per-Message Deflate Compression - Bun
description: Demonstrates how to enable per-message compression using the `perMessageDeflate` option in the `Bun.serve` configuration. This configuration ensures that all WebSocket messages are compressed using the permessage-deflate extension.
source: docs/guides/websocket/compression.md#_snippet_0

language: ts
code:
```
Bun.serve({
  // ...
  websocket: {
    // enable compression
    perMessageDeflate: true,
  },
});
```

---

title: Sending Compressed Messages Individually - Bun
description: Illustrates how to send individual compressed messages using `ws.send()` within a Bun WebSocket server. Passing `true` as the second parameter to `ws.send()` enables compression for that specific message.
source: docs/guides/websocket/compression.md#_snippet_1

language: ts
code:
```
Bun.serve({
  // ...
  websocket: {
    async message(ws, message) {
      // send a compressed message
      ws.send(message, true);
    },
  },
});
```

---

title: Updating Package.json with Tarball Dependency (JSON)
description: Illustrates the `package.json` update after adding a tarball dependency with Bun. It shows the addition of the dependency with the tarball URL in the `dependencies` section.
source: docs/guides/install/add-tarball.md#_snippet_1

language: json-diff
code:
```
{
  "dependencies": {
+   "zod": "https://registry.npmjs.org/zod/-/zod-3.21.4.tgz"
  }
}
```

---

title: Configuring Trusted Dependencies
description: Demonstrates how to add a package to the `trustedDependencies` list in `package.json`. This allows Bun to execute lifecycle scripts for the specified package, which is necessary for packages that rely on `postinstall` scripts.
source: docs/guides/install/trusted.md#_snippet_0

language: json-diff
code:
```
  {
    "name": "my-app",
    "version": "1.0.0",
+   "trustedDependencies": ["my-trusted-package"]
  }
```

---

title: Running a Fresh Install After Configuring Trusted Dependencies
description: Illustrates the commands needed to perform a fresh installation after updating the `trustedDependencies` list. This ensures that Bun re-installs the dependencies and executes the necessary lifecycle scripts for the trusted packages.
source: docs/guides/install/trusted.md#_snippet_1

language: sh
code:
```
$ rm -rf node_modules
$ rm bun.lock
$ bun install
```

---

title: Configuring Local Git to Diff Lockb Files
description: Configures the local Git repository to use `bun` as the text converter for diffing `.lockb` files and specifies that `.lockb` files should be treated as binary. This allows Git to generate human-readable diffs for binary lockfiles by using the `bun` command for conversion before comparison.
source: docs/guides/install/git-diff-bun-lockfile.md#_snippet_1

language: sh
code:
```
$ git config diff.lockb.textconv bun
$ git config diff.lockb.binary true
```

---

title: Configuring Registry Scopes - TOML
description: Defines how to configure private registries for different npm scopes within a `bunfig.toml` file. Illustrates the use of strings, objects with username/password, and objects with tokens for registry authentication.
source: docs/guides/install/registry-scope.md#_snippet_0

language: toml
code:
```
[install.scopes]
# as a string
"@myorg1" = "https://username:password@registry.myorg.com/"

# as an object with username/password
# you can reference environment variables
"@myorg2" = {
  username = "myusername",
  password = "$npm_pass",
  url = "https://registry.myorg.com/"
}

# as an object with token
"@myorg3" = { token = "$npm_token", url = "https://registry.myorg.com/" }
```

---

title: Replacing Code with Statically-Known Values
description: Illustrates how Bun replaces `process.env.NODE_ENV` with a statically-known value during transpilation, enabling dead code elimination and other optimizations.
source: docs/guides/runtime/define-constant.md#_snippet_1

language: ts
code:
```
if (process.env.NODE_ENV === "production") {
  console.log(
```

language: ts-diff
code:
```
+ if (
```

---

title: Constant Folding with Optimizing Transpiler
description: Explains how Bun's optimizing transpiler performs constant folding, replacing expressions with their computed values at compile time, which optimizes the code by simplifying conditions.
source: docs/guides/runtime/define-constant.md#_snippet_2

language: ts-diff
code:
```
+ if (true) {
    console.log(
```

---

title: Eliminating Unreachable Code with Optimizing Transpiler
description: Demonstrates how Bun's optimizing transpiler detects and eliminates unreachable code branches, resulting in a more concise and efficient final output.
source: docs/guides/runtime/define-constant.md#_snippet_3

language: ts
code:
```
console.log(
```

---

title: Configuring Default Registry - Bunfig TOML
description: Defines how to override the default npm registry in `bunfig.toml` using string, token, or username/password formats. Demonstrates setting the `registry` key under the `install` section of the configuration file. This allows specifying an alternative registry for package installations.
source: docs/guides/install/custom-registry.md#_snippet_0

language: toml
code:
```
[install]
# set default registry as a string
registry = "https://registry.npmjs.org"

# if needed, set a token
registry = { url = "https://registry.npmjs.org", token = "123456" }

# if needed, set a username/password
registry = "https://username:password@registry.npmjs.org"
```

---

title: Reading Cookies and Headers for Client Identification - TypeScript
description: Illustrates how to read cookies and headers from an incoming request to identify a connecting client and associate the data with the WebSocket. The example uses `parseCookies` to extract the token, retrieves user information, and then includes the `createdAt`, `token`, and `userId` in the `data` object passed to `server.upgrade()`. This data is then used to save messages to a database along with the `userId` from the websocket's data.
source: docs/guides/websocket/context.md#_snippet_1

language: typescript
code:
```
type WebSocketData = {
  createdAt: number;
  token: string;
  userId: string;
};

// TypeScript: specify the type of `data`
Bun.serve<WebSocketData>({
  async fetch(req, server) {
    // use a library to parse cookies
    const cookies = parseCookies(req.headers.get("Cookie"));
    const token = cookies["X-Token"];
    const user = await getUserFromToken(token);

    const upgraded = server.upgrade(req, {
      data: {
        createdAt: Date.now(),
        token: cookies["X-Token"],
        userId: user.id,
      },
    });

    if (upgraded) return undefined;
  },
  websocket: {
    async message(ws, message) {
      // save the message to a database
      await saveMessageToDatabase({
        message: String(message),
        userId: ws.data.userId,
      });
    },
  },
});
```

---

title: Specifying Bun Version in GitHub Actions
description: Illustrates how to specify a particular version of Bun to install using the `oven-sh/setup-bun` GitHub Action. By setting the `version` input, you can control which Bun version is used in your workflow, such as `latest` or `canary`.
source: docs/guides/install/cicd.md#_snippet_1

language: yaml-diff
code:
```
name: my-workflow
jobs:
  my-job:
    name: my-job
    runs-on: ubuntu-latest
    steps:
      # ...
      - uses: oven-sh/setup-bun@v2
+       with:
+         version: "latest" # or "canary"
```

---

title: Compressing and Decompressing Data With Gzip - Typescript
description: Demonstrates how to compress a `Uint8Array` using `Bun.gzipSync()` and decompress it using `Bun.gunzipSync()`. This is useful for reducing the size of data for storage or transmission.
source: docs/guides/util/gzip.md#_snippet_0

language: typescript
code:
```
const data = Buffer.from("Hello, world!");
const compressed = Bun.gzipSync(data);
// => Uint8Array

const decompressed = Bun.gunzipSync(compressed);
// => Uint8Array
```

---

title: Compressing and Decompressing Data with DEFLATE
description: Demonstrates how to compress a `Uint8Array` using `Bun.deflateSync()` and decompress the result using `Bun.inflateSync()`. This allows for efficient data compression and decompression within Bun.
source: docs/guides/util/deflate.md#_snippet_0

language: ts
code:
```
const data = Buffer.from("Hello, world!");
const compressed = Bun.deflateSync("Hello, world!");
// => Uint8Array

const decompressed = Bun.inflateSync(compressed);
// => Uint8Array
```

---

title: Converting File URL to Absolute Path
description: Demonstrates how to convert a `file://` URL to an absolute path using `Bun.fileURLToPath()`. This function is useful for resolving file paths from URLs, particularly when working with file system operations.
source: docs/guides/util/file-url-to-path.md#_snippet_0

language: typescript
code:
```
Bun.fileURLToPath("file:///path/to/file.txt");
// => "/path/to/file.txt"
```

---

title: Converting Absolute Path to File URL - TypeScript
description: Demonstrates how to convert an absolute path to a `file://` URL using `Bun.pathToFileURL()`. This utility is useful for creating file URLs from file paths, which can be necessary when working with APIs or libraries that expect URLs instead of paths.
source: docs/guides/util/path-to-file-url.md#_snippet_0

language: typescript
code:
```
Bun.pathToFileURL("/path/to/file.txt");
// => "file:///path/to/file.txt"
```

---

title: Configuring Azure Artifacts Registry with bunfigtoml
description: Illustrates how to configure `bun install` to use an Azure Artifacts npm registry by creating a `bunfig.toml` file. This configuration specifies the registry URL, username, and password (sourced from an environment variable) for authenticating with Azure Artifacts.
source: docs/guides/install/azure-artifacts.md#_snippet_0

language: toml
code:
```
[install.registry]
url = "https://pkgs.dev.azure.com/my-azure-artifacts-user/_packaging/my-azure-artifacts-user/npm/registry"
username = "my-azure-artifacts-user"
# Bun v1.0.3+ supports using an environment variable here
password = "$NPM_PASSWORD"
```

---

title: Setting NPM Password Environment Variable
description: Demonstrates how to set the `NPM_PASSWORD` environment variable with your Azure Personal Access Token. This allows `bun install` to authenticate with the Azure Artifacts registry using the credentials specified in `bunfig.toml`. Bun automatically reads `.env` files, so there's no need to manually load the variable.
source: docs/guides/install/azure-artifacts.md#_snippet_1

language: txt
code:
```
NPM_PASSWORD=<paste token here>
```

---

title: Organizing Packages in a Monorepo
description: Illustrates the common directory structure for a monorepo using workspaces. All packages are placed in the `packages` directory, and the `workspaces` field in `package.json` uses the `packages/*` glob pattern to identify each subdirectory as a separate package.
source: docs/guides/install/workspaces.md#_snippet_1

language: txt
code:
```
.
â”œâ”€â”€ package.json
â”œâ”€â”€ node_modules
â””â”€â”€ packages
    â”œâ”€â”€ stuff-a
    â”‚   â””â”€â”€ package.json
    â””â”€â”€ stuff-b
        â””â”€â”€ package.json
```

---

title: Installing Dependencies for All Workspaces
description: Shows how to install dependencies for all workspaces by running `bun install` from the project root. Bun automatically detects and hoists dependencies, optimizing the installation process across all workspaces.
source: docs/guides/install/workspaces.md#_snippet_3

language: sh
code:
```
$ bun install
```

---

title: Adding npm Dependencies to a Workspace
description: Illustrates how to add npm dependencies to a specific workspace. By navigating to the workspace directory and running `bun add <package>`, Bun automatically detects the workspace context and hoists the dependency as needed.
source: docs/guides/install/workspaces.md#_snippet_4

language: sh
code:
```
$ cd packages/stuff-a
$ bun add zod
```

---

title: Escaping HTML String - TypeScript
description: Demonstrates how to use `Bun.escapeHTML()` to escape HTML characters in a string. This function replaces characters such as `<`, `>`, `&`, `"`, and `'` with their corresponding HTML entities. It is optimized for large inputs and converts non-string types to strings before escaping.
source: docs/guides/util/escape-html.md#_snippet_0

language: typescript
code:
```
Bun.escapeHTML("<script>alert('Hello World!')</script>");
// &lt;script&gt;alert(&#x27;Hello World!&#x27;)&lt;&#x2F;script&gt;
```

---

title: Using extractSocialMetadata Function - TypeScript
description: Illustrates the usage of the `extractSocialMetadata` function by calling it with a URL and logging the resulting metadata. This snippet demonstrates how to fetch and display social metadata for a given webpage, utilizing the function defined in the previous snippet.
source: docs/guides/html-rewriter/extract-social-meta.md#_snippet_1

language: typescript
code:
```
// Example usage
const metadata = await extractSocialMetadata("https://bun.com");
console.log(metadata);
// {
//   title: "Bun - A fast all-in-one JavaScript runtime",
//   description: "Bundle, transpile, install and run JavaScript & TypeScript projects - all in Bun. Bun is a fast all-in-one JavaScript runtime & toolkit designed for speed, complete with a bundler, test runner, and Node.js-compatible package manager.",
//   image: "https://bun.com/share.jpg",
//   type: "website",
//   ...
// }
```

---

title: Verifying a Password Hash
description: Demonstrates how to verify a password against a hash using `Bun.password.verify()`. This function takes the password and the hash as arguments and returns a boolean indicating whether the password matches the hash.  The algorithm and parameters are extracted from the hash itself.
source: docs/guides/util/hash-a-password.md#_snippet_3

language: typescript
code:
```
const password = "super-secure-pa$$word";
const hash = await Bun.password.hash(password);

const isMatch = await Bun.password.verify(password, hash);
// => true
```

---

title: Rendering a React Component to a Readable Stream - Typescript
description: Illustrates how to render a React component into an HTML stream on the server using `renderToReadableStream` from `react-dom/server`. This is useful for server-side rendering (SSR) to improve performance and SEO.
source: docs/guides/ecosystem/ssr-react.md#_snippet_1

language: tsx
code:
```
import { renderToReadableStream } from "react-dom/server";

function Component(props: { message: string }) {
  return (
    <body>
      <h1>{props.message}</h1>
    </body>
  );
}

const stream = await renderToReadableStream(
  <Component message="Hello from server!" />,
);
```

---

title: Serving a React Component with Bun Serve - Typescript
description: Demonstrates integrating `renderToReadableStream` with `Bun.serve()` to create a basic SSR HTTP server. The `fetch` function renders the `Component` to a stream and returns it in a `Response` with `text/html` as the content type.
source: docs/guides/ecosystem/ssr-react.md#_snippet_2

language: tsx
code:
```
Bun.serve({
  async fetch() {
    const stream = await renderToReadableStream(
      <Component message="Hello from server!" />,
    );
    return new Response(stream, {
      headers: { "Content-Type": "text/html" },
    });
  },
});
```

---

title: Configuring PM2 With Configuration File
description: Illustrates how to configure `pm2` using a configuration file. The configuration specifies the application's name, entry point (`index.ts`), and interpreter (`bun`). It also modifies the `PATH` environment variable to include Bun's binary directory, allowing `pm2` to properly execute the Bun runtime.
source: docs/guides/ecosystem/pm2.md#_snippet_1

language: javascript
code:
```
module.exports = {
  name: "app", // Name of your application
  script: "index.ts", // Entry point of your application
  interpreter: "bun", // Bun interpreter
  env: {
    PATH: `${process.env.HOME}/.bun/bin:${process.env.PATH}`, // Add "~/.bun/bin/bun" to PATH
  },
};
```

---

title: Running the Dev Server with Bun
description: Shows how to start the Next.js development server using Bun. Executing `bun --bun run dev` from the project root will launch the server.
source: docs/guides/ecosystem/nextjs.md#_snippet_2

language: sh
code:
```
$ cd my-app
$ bun --bun run dev
```

---

title: Running the Server in Watch Mode
description: Illustrates how to start the StricJS development server using `bun --watch run index.ts`. This command runs the `index.ts` file and automatically restarts the server whenever changes are made to the file. This enhances the development process.
source: docs/guides/ecosystem/stric.md#_snippet_3

language: bash
code:
```
$ bun --watch run index.ts
```

---

title: Starting the Server on Localhost
description: Starts the server defined in `server.ts` using the `bun` command. This will execute the TypeScript file and initiate the Express application, making it accessible on `localhost`.
source: docs/guides/ecosystem/express.md#_snippet_2

language: shell
code:
```
$ bun server.ts
```

---

title: Accessing Version Information at Build Time - TypeScript and Shell
description: Illustrates how to embed version and build metadata directly into an executable. The TypeScript code declares constants that are replaced at build time with values provided by the `bun build` command, which uses the `--define` flag.
source: docs/guides/runtime/build-time-constants.md#_snippet_3

language: ts
code:
```
// These constants are replaced at build time
declare const BUILD_VERSION: string;
declare const BUILD_TIME: string;
declare const GIT_COMMIT: string;

export function getVersion() {
  return {
    version: BUILD_VERSION,
    buildTime: BUILD_TIME,
    commit: GIT_COMMIT,
  };
}
```

language: sh
code:
```
$ bun build --compile \
  --define BUILD_VERSION='"1.2.3"' \
  --define BUILD_TIME='"2024-01-15T10:30:00Z"' \
  --define GIT_COMMIT='"abc123"' \
  src/cli.ts --outfile mycli
```

---

title: Enabling Feature Flags at Build Time - TypeScript
description: Demonstrates how to use build-time constants to enable or disable features in an application. The TypeScript code declares boolean constants `ENABLE_ANALYTICS` and `ENABLE_DEBUG`, which are replaced at build time, allowing for dead code elimination of unused branches.
source: docs/guides/runtime/build-time-constants.md#_snippet_4

language: ts
code:
```
// Replaced at build time
declare const ENABLE_ANALYTICS: boolean;
declare const ENABLE_DEBUG: boolean;

function trackEvent(event: string) {
  if (ENABLE_ANALYTICS) {
    // This entire block is removed if ENABLE_ANALYTICS is false
    console.log("Tracking:", event);
  }
}

if (ENABLE_DEBUG) {
  console.log("Debug mode enabled");
}
```

---

title: Building with Feature Flags Configured - Shell
description: Illustrates the commands to build the application with different configurations for feature flags. The first command builds for production with analytics enabled and debug disabled, while the second builds for development with both enabled.
source: docs/guides/runtime/build-time-constants.md#_snippet_5

language: sh
code:
```
# Production build - analytics enabled, debug disabled
$ bun build --compile --define ENABLE_ANALYTICS=true --define ENABLE_DEBUG=false src/app.ts --outfile app-prod

# Development build - both enabled
$ bun build --compile --define ENABLE_ANALYTICS=false --define ENABLE_DEBUG=true src/app.ts --outfile app-dev
```

---

title: Defining a User Model -Prisma
description: Illustrates how to define a simple `User` model in the `prisma/schema.prisma` file. The model includes fields for `id` (as an auto-incrementing integer primary key), `email` (as a unique string), and `name` (as an optional string). This defines the structure of the `User` table in the database.
source: docs/guides/ecosystem/prisma.md#_snippet_3

language: prisma
code:
```
generator client {
  provider = "prisma-client-js"
  output = "../generated/prisma"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}
```

---

title: Generating and Running Initial Migration -Bash
description: Demonstrates how to generate and run the initial migration using the Prisma CLI.  The command `bunx prisma migrate dev --name init` generates a `.sql` migration file, creates a SQLite database instance, and applies the migration to the database, synchronizing the database schema with the Prisma schema.
source: docs/guides/ecosystem/prisma.md#_snippet_4

language: bash
code:
```
$ bunx prisma migrate dev --name init
```

---

title: Converting Buffer to ArrayBuffer - TypeScript
description: Demonstrates how to obtain the underlying `ArrayBuffer` of a Node.js `Buffer` instance using the `buffer` property. This allows direct access and manipulation of the binary data.
source: docs/guides/binary/buffer-to-arraybuffer.md#_snippet_0

language: typescript
code:
```
const nodeBuf = Buffer.alloc(64);
const arrBuf = nodeBuf.buffer;
```

---

title: Defining Animal Model Using Mongoose (schema.ts)
description: Defines a Mongoose schema for an `Animal` model using TypeScript. It specifies the `name` and `sound` properties, both required strings, and includes a `speak` method on the schema's methods property. Exports both the type and the model for use in other modules.
source: docs/guides/ecosystem/mongoose.md#_snippet_0

language: typescript
code:
```
import * as mongoose from 'mongoose';

const animalSchema = new mongoose.Schema(
  {
    name: {type: String, required: true},
    sound: {type: String, required: true},
  },
  {
    methods: {
      speak() {
        console.log(`${this.sound}!`);
      },
    },
  }
);

export type Animal = mongoose.InferSchemaType<typeof animalSchema>;
export const Animal = mongoose.model('Animal', animalSchema);
```

---

title: Querying Postgres Version with Neon - Typescript
description: Demonstrates how to import the `neon` function from the `@neondatabase/serverless` package and use it to execute a SQL query.  It retrieves the Postgres version and prints it to the console, using the `DATABASE_URL` environment variable automatically loaded by Bun.
source: docs/guides/ecosystem/neon-serverless-postgres.md#_snippet_2

language: typescript
code:
```
import { neon } from "@neondatabase/serverless";

// Bun automatically loads the DATABASE_URL from .env.local
// Refer to: https://bun.com/docs/runtime/env for more information
const sql = neon(process.env.DATABASE_URL);

const rows = await sql`SELECT version()`;

console.log(rows[0].version);
```

---

title: Creating Uint8Array from ArrayBuffer - TypeScript
description: Demonstrates how to create a `Uint8Array` from an `ArrayBuffer` in TypeScript. This allows accessing and manipulating the buffer's contents as an array of 8-bit unsigned integers. The example shows initializing an `ArrayBuffer` and accessing its properties through the `Uint8Array`.
source: docs/guides/binary/arraybuffer-to-array.md#_snippet_0

language: ts
code:
```
const buf = new ArrayBuffer(64);
const arr = new Uint8Array(buf);
arr.length; // 64
arr[0]; // 0 (instantiated with all zeros)
```

---

title: Running the Development Server with Bun
description: Demonstrates starting the Qwik development server using `bun run dev`. This command initiates the Vite build process in SSR mode, making the application accessible at `http://localhost:5173/`.
source: docs/guides/ecosystem/qwik.md#_snippet_1

language: sh
code:
```
$ bun run dev
  $ vite--mode ssr

  VITE v4.4.7  ready in 1190 ms

  âžœ  Local:   http://localhost:5173/
  âžœ  Network: use --host to expose
  âžœ  press h to show help
```

---

title: Decoding a DataView to String - JavaScript
description: Demonstrates how to convert a `DataView` containing ASCII-encoded text into a JavaScript string using the `TextDecoder` class. This is useful when processing binary data that represents text.
source: docs/guides/binary/dataview-to-string.md#_snippet_0

language: typescript
code:
```
const dv: DataView = ...;
const decoder = new TextDecoder();
const str = decoder.decode(dv);
```

---

title: Converting Buffer to Blob - TypeScript
description: Demonstrates how to convert a `Buffer` object to a `Blob` object in TypeScript. This is useful when you need to represent binary data as a `Blob`, which is often required for web APIs.
source: docs/guides/binary/buffer-to-blob.md#_snippet_0

language: typescript
code:
```
const buf = Buffer.from("hello");
const blob = new Blob([buf]);
```

---

title: Building Docker Image for Bun App
description: Demonstrates building a Docker image from a `Dockerfile` using the `docker build` command. The `-t` flag is used to tag the image with a name, and the `--pull` flag ensures that the latest version of the base image is used. This command packages the Bun application and its dependencies into a Docker image.
source: docs/guides/ecosystem/docker.md#_snippet_2

language: bash
code:
```
$ docker build --pull -t bun-hello-world .
[+] Building 0.9s (21/21) FINISHED
 => [internal] load build definition from Dockerfile                                                                                     0.0s
 => => transferring dockerfile: 37B                                                                                                      0.0s
 => [internal] load .dockerignore                                                                                                        0.0s
 => => transferring context: 35B                                                                                                         0.0s
 => [internal] load metadata for docker.io/oven/bun:1                                                                                    0.8s
 => [auth] oven/bun:pull token for registry-1.docker.io                                                                                  0.0s
 => [base 1/2] FROM docker.io/oven/bun:1@sha256:373265748d3cd3624cb3f3ee6004f45b1fc3edbd07a622aeeec17566d2756997                         0.0s
 => [internal] load build context                                                                                                        0.0s
 => => transferring context: 155B                                                                                                        0.0s
 # ...lots of commands...
 => exporting to image                                                                                                                   0.0s
 => => exporting layers                                                                                                                  0.0s
 => => writing image sha256:360663f7fdcd6f11e8e94761d5592e2e4dfc8d167f034f15cd5a863d5dc093c4                                             0.0s
 => => naming to docker.io/library/bun-hello-world                                                                                       0.0s
```

---

title: Querying the Database with Drizzle and Bun
description: Demonstrates a basic query to the SQLite database using Drizzle's `sql` template literal. It fetches a simple 'hello world' string and logs the result to the console, verifying the connection to the database.
source: docs/guides/ecosystem/drizzle.md#_snippet_2

language: ts
code:
```
import { db } from "./db";
import { sql } from "drizzle-orm";

const query = sql`select "hello world" as text`;
const result = db.get<{ text: string }>(query);
console.log(result);
```

---

title: Running a Basic Query with Bun
description: Illustrates how to execute a TypeScript file using Bun, automatically creating the `sqlite.db` file and running the SQL query. This snippet shows Bun's ability to execute and manage SQLite databases directly.
source: docs/guides/ecosystem/drizzle.md#_snippet_3

language: sh
code:
```
$ bun run index.ts
{
  text: "hello world"
}
```

---

title: Applying Migrations with Drizzle's Migrator
description: Demonstrates how to apply database migrations using Drizzle's migrator.  The `migrate` function from `drizzle-orm/bun-sqlite/migrator` is used to execute all unexecuted migrations in the specified folder.
source: docs/guides/ecosystem/drizzle.md#_snippet_7

language: ts
code:
```
import { migrate } from "drizzle-orm/bun-sqlite/migrator";

import { drizzle } from "drizzle-orm/bun-sqlite";
import { Database } from "bun:sqlite";

const sqlite = new Database("sqlite.db");
const db = drizzle(sqlite);
migrate(db, { migrationsFolder: "./drizzle" });
```

---

title: Seeding Data into the Database
description: Shows how to seed initial data into the database using Drizzle. It imports the database connection and schema, then inserts multiple movie records into the `movies` table using the `db.insert` method.
source: docs/guides/ecosystem/drizzle.md#_snippet_9

language: ts
code:
```
import { db } from "./db";
import * as schema from "./schema";

await db.insert(schema.movies).values([
  {
    title: "The Matrix",
    releaseYear: 1999,
  },
  {
    title: "The Matrix Reloaded",
    releaseYear: 2003,
  },
  {
    title: "The Matrix Revolutions",
    releaseYear: 2003,
  },
]);

console.log(`Seeding complete.`);
```

---

title: Querying Data with Drizzle
description: Illustrates how to query data from the database using Drizzle. It imports the database connection and schema, then selects all records from the `movies` table and logs the results to the console.
source: docs/guides/ecosystem/drizzle.md#_snippet_11

language: ts
code:
```
import * as schema from "./schema";
import { db } from "./db";

const result = await db.select().from(schema.movies);
console.log(result);
```

---

title: Enabling Systemd Service (Bash)
description: Illustrates how to enable a systemd service, ensuring it starts automatically on system boot. The `systemctl enable` command creates the necessary symbolic links for the service to be started during the boot process.
source: docs/guides/ecosystem/systemd.md#_snippet_3

language: bash
code:
```
$ sudo systemctl enable my-app
```

---

title: Starting Systemd Service (Bash)
description: Demonstrates how to manually start a systemd service. This allows you to initiate the service without requiring a system reboot, which is useful for testing and immediate deployment.
source: docs/guides/ecosystem/systemd.md#_snippet_4

language: bash
code:
```
$ sudo systemctl start my-app
```

---

title: Checking Systemd Service Status (Bash)
description: Illustrates how to check the status of a systemd service, providing information on whether the service is active, its PID, and other relevant details. Using `systemctl status` is crucial for monitoring and troubleshooting systemd services.
source: docs/guides/ecosystem/systemd.md#_snippet_5

language: bash
code:
```
$ sudo systemctl status my-app
```

---

title: Creating a Uint8Array From ArrayBuffer
description: Demonstrates how to create a `Uint8Array` from an existing `ArrayBuffer`. This allows viewing the raw bytes of the buffer as unsigned 8-bit integers.
source: docs/guides/binary/arraybuffer-to-typedarray.md#_snippet_0

language: ts
code:
```
const buffer = new ArrayBuffer(64);
const arr = new Uint8Array(buffer);
```

---

title: Streaming Uint8Array Using Blob Stream
description: Illustrates how to stream a `Uint8Array` in smaller chunks by creating a `Blob` instance and using the `Blob.stream()` method. This allows for streaming the data in specified chunk sizes, providing a more efficient approach for large arrays.
source: docs/guides/binary/typedarray-to-readablestream.md#_snippet_1

language: ts
code:
```
const arr = new Uint8Array(64);
const blob = new Blob([arr]);
const stream = blob.stream();
```

---

title: Updating Packages Interactively Using Bun
description: Illustrates the interactive mode of `bun update` using the `--interactive` flag. This allows users to select specific packages for updating through a terminal interface.
source: docs/cli/update.md#_snippet_1

language: shell
code:
```
$ bun update --interactive
$ bun update -i
```

---

title: Running Scripts in Multiple Packages Using Filters
description: Demonstrates how to use the `--filter` flag to run a script in multiple packages at once. The example shows running the `dev` script in both `packages/api` and `packages/frontend` simultaneously.
source: docs/cli/filter.md#_snippet_2

language: bash
code:
```
# in another terminal
cd packages/frontend
bun dev
```

language: bash
code:
```
bun --filter '*' dev
```

---

title: Connecting to EdgeDB with the REPL - Shell
description: Illustrates how to connect to a running EdgeDB instance using the `edgedb` command-line tool. It then executes a simple query `select 1 + 1;` and exits the REPL with `\quit`. This verifies that the database is accessible and functioning.
source: docs/guides/ecosystem/edgedb.md#_snippet_3

language: sh
code:
```
$ edgedb
edgedb> select 1 + 1;
2
edgedb> \quit
```

---

title: Running the Seeding Script - Shell
description: Demonstrates how to execute the `seed.ts` file using Bun.  This populates the EdgeDB database with the movie data defined in the script.
source: docs/guides/ecosystem/edgedb.md#_snippet_8

language: sh
code:
```
$ bun run seed.ts
Seeding complete.
```

---

title: Querying EdgeDB with Generated Query Builder - TypeScript
description: Illustrates how to use the generated EdgeQL query builder to select data from EdgeDB. It imports `createClient` from `edgedb` and `e` from the generated `./dbschema/edgeql-js` directory. The example constructs a query to select all `Movie` objects with their `title` and `releaseYear` properties, then runs the query using the `.run()` method. Type hints are included as a comment after the results.
source: docs/guides/ecosystem/edgedb.md#_snippet_10

language: ts
code:
```
import { createClient } from "edgedb";
import e from "./dbschema/edgeql-js";

const client = createClient();

const query = e.select(e.Movie, () => ({
  title: true,
  releaseYear: true,
}));

const results = await query.run(client);
console.log(results);

results; // { title: string, releaseYear: number | null }[]
```

---

title: Running the Query and Displaying Results - Shell
description: Demonstrates how to execute the `index.ts` file using Bun, which queries the EdgeDB database and prints the results to the console.  This shows the movie data that was previously seeded into the database.
source: docs/guides/ecosystem/edgedb.md#_snippet_11

language: sh
code:
```
$ bun run index.ts
[
  {
    title: "The Matrix",
    releaseYear: 1999
  }, {
    title: "The Matrix Reloaded",
    releaseYear: 2003
  }, {
    title: "The Matrix Revolutions",
    releaseYear: 2003
  }
]
```

---

title: Executing a Raw SQL Query
description: Demonstrates executing a raw SQL query against the Neon database using Drizzle. It imports the database instance `db` and the `sql` template literal tag from Drizzle, executes a simple query, and logs the result rows to the console.
source: docs/guides/ecosystem/neon-drizzle.md#_snippet_3

language: ts
code:
```
import { db } from "./db";
import { sql } from "drizzle-orm";

const query = sql`select 'hello world' as text`;
const result = await db.execute(query);
console.log(result.rows);
```

---

title: Running Raw SQL Query with Bun
description: Shows how to execute the `index.ts` file containing the raw SQL query using `bun run`. The output displays the result of the query.
source: docs/guides/ecosystem/neon-drizzle.md#_snippet_4

language: sh
code:
```
$ bun run index.ts
[
  {
    text: "hello world",
  }
]
```

---

title: Querying Data with Drizzle
description: Illustrates how to query data from the database using Drizzle's query builder API. It imports the schema and database instance, then uses `db.select().from(schema.authors)` to select all rows from the `authors` table.
source: docs/guides/ecosystem/neon-drizzle.md#_snippet_12

language: ts
code:
```
import * as schema from "./schema";
import { db } from "./db";

const result = await db.select().from(schema.authors);
console.log(result);
```

---

title: Running the Query Script
description: Demonstrates executing the `index.ts` script using `bun run`. The output displays the results of querying the `authors` table, showing the data inserted during the seeding process.
source: docs/guides/ecosystem/neon-drizzle.md#_snippet_13

language: sh
code:
```
$ bun run index.ts
[
  {
    id: 1,
    name: "J.R.R. Tolkien",
    bio: "The creator of Middle-earth and author of The Lord of the Rings.",
    createdAt: 2024-05-11T10:28:46.029Z,
  }, {
    id: 2,
    name: "George R.R. Martin",
    bio: "The author of the epic fantasy series A Song of Ice and Fire.",
    createdAt: 2024-05-11T10:28:46.029Z,
  }, {
    id: 3,
    name: "J.K. Rowling",
    bio: "The creator of the Harry Potter series.",
    createdAt: 2024-05-11T10:28:46.029Z,
  }
]
```

---

title: Viewing Specific Package Versions with Bun Info
description: Illustrates how to use `bun info` to retrieve metadata for a specific version of an npm package.  Specifying the version allows developers to inspect historical package configurations, dependencies, and other version-specific metadata using the `@` symbol.
source: docs/cli/info.md#_snippet_1

language: bash
code:
```
$ bun info react@18.0.0
```

---

title: Filtering Tests Using Positional Arguments - Bash
description: Demonstrates how to filter test files using positional arguments with `bun test`. This allows you to run specific tests based on a substring match of the file path. It is useful for targeting tests within a specific directory or matching a naming convention.
source: docs/test/discovery.md#_snippet_0

language: bash
code:
```
$ bun test <filter> <filter> ...
```

language: bash
code:
```
$ bun test utils
```

---

title: Configuring JUnit Reporter (bunfig.toml)
description: Illustrates configuring the JUnit reporter within the `bunfig.toml` file. This involves specifying the output path for the JUnit XML report using the `test.reporter.junit` key.
source: docs/test/reporters.md#_snippet_1

language: toml
code:
```
[test.reporter]
junit = "path/to/junit.xml"  # Output path for JUnit XML report
```

---

title: Scoping Hooks to a Describe Block - Bun
description: Illustrates how to scope `beforeAll` hooks to a `describe` block using the `bun:test` module.  This allows setup logic to be run once before all tests within a specific test group, which is useful for initializing resources needed by that group.
source: docs/test/lifecycle.md#_snippet_1

language: typescript
code:
```
import { describe, beforeAll } from "bun:test";

describe("test group", () => {
  beforeAll(() => {
    // setup
  });

  // tests...
});
```

---

title: Scoping Hooks to a Test File - Bun
description: Illustrates how to scope `beforeAll` hooks to an entire test file using the `bun:test` module. This allows setup logic to be run once before all tests within the file, which is useful for initializing resources needed by the tests in that file.
source: docs/test/lifecycle.md#_snippet_2

language: typescript
code:
```
import { describe, beforeAll } from "bun:test";

beforeAll(() => {
  // setup
});

describe("test group", () => {
  // tests...
});
```

---

title: Simulating Jest's Fake Timers in Bun - TypeScript
description: Illustrates how to use `jest.useFakeTimers` and `jest.useRealTimers` in `bun:test` for compatibility with existing Jest tests. It highlights a key difference: in `bun:test`, the `Date` constructor remains unchanged when using fake timers, unlike Jest. This ensures consistent behavior and avoids potential bugs related to `Date` object comparisons.
source: docs/test/time.md#_snippet_1

language: typescript
code:
```
test("just like in jest", () => {
  jest.useFakeTimers();
  jest.setSystemTime(new Date("2020-01-01T00:00:00.000Z"));
  expect(new Date().getFullYear()).toBe(2020);
  jest.useRealTimers();
  expect(new Date().getFullYear()).toBeGreaterThan(2020);
});

test("unlike in jest", () => {
  const OriginalDate = Date;
  jest.useFakeTimers();
  if (typeof Bun === "undefined") {
    // In Jest, the Date constructor changes
    // That can cause all sorts of bugs because suddenly Date !== Date before the test.
    expect(Date).not.toBe(OriginalDate);
    expect(Date.now).not.toBe(OriginalDate.now);
  } else {
    // In bun:test, Date constructor does not change when you useFakeTimers
    expect(Date).toBe(OriginalDate);
    expect(Date.now).toBe(OriginalDate.now);
  }
});
```

---

title: Mapping Paths Using tsconfigjson
description: Illustrates how Bun resolves module paths using the `compilerOptions.paths` defined in `tsconfig.json`. It demonstrates the use of `baseUrl` and path mappings to resolve imports from specified directories, allowing for cleaner and more organized code structure.
source: docs/runtime/typescript.md#_snippet_0

language: json
code:
```
{
  "compilerOptions": {
    "baseUrl": "./src",
    "paths": {
      "data": ["./data.ts"]
    }
  }
}
```

language: typescript
code:
```
// resolves to ./src/components/Button.tsx
import { Button } from "components/Button.tsx";
```

---

title: Always Enabling Coverage Reporting - Configuration
description: Illustrates how to configure Bun to always enable code coverage reporting by default.  This is achieved by adding `coverage = true` to the `[test]` section of the `bunfig.toml` file, ensuring that coverage reports are generated on every test run.
source: docs/test/coverage.md#_snippet_1

language: toml
code:
```
[test]

# always enable coverage
coverage = true
```

---

title: Using Frozen Lockfile - Bash
description: Demonstrates how to use the `--frozen-lockfile` flag to ensure reproducible installs. This installs the exact versions specified in `bun.lock` and exits with an error if the `package.json` disagrees with the lockfile.
source: docs/cli/install.md#_snippet_9

language: bash
code:
```
$ bun install --frozen-lockfile
```

---

title: Testing Node Alias to Bun
description: Demonstrates commands for testing the aliasing of `node` to `bun`. The commands verify the `node` executable is a symlink to the `bun` executable.
source: docs/runtime/bunfig.md#_snippet_10

language: sh
code:
```
$ bun --bun which node # /path/to/bun
$ bun which node # /path/to/node
```

---

title: Publishing Data to WebSocket Subscribers
description: Illustrates using the `publish()` method of a WebSocket server to send a message to all subscribers of a specific topic. The `publish` method supports various data types, including strings, `ArrayBufferView`, and `ArrayBuffer`, and allows optional compression.
source: docs/api/websockets.md#_snippet_1

language: typescript
code:
```
`publish(topic: string, data: string | ArrayBufferView | ArrayBuffer, compress?: boolean): number;`
```

---

title: Setting Environment Variables Via Command Line - Linux/macOS
description: Demonstrates setting environment variables directly from the command line in Linux and macOS. This method sets the `FOO` environment variable for the duration of the `bun run dev` command.
source: docs/runtime/env.md#_snippet_1

language: sh
code:
```
$ FOO=helloworld bun run dev
```

---

title: Setting Environment Variables Via Command Line - Windows
description: Demonstrates setting environment variables directly from the command line in Windows using both CMD and PowerShell. This method sets the `FOO` environment variable for the duration of the `bun run dev` command.
source: docs/runtime/env.md#_snippet_2

language: sh
code:
```
# Using CMD
$ set FOO=helloworld && bun run dev

# Using PowerShell
$ $env:FOO="helloworld"; bun run dev
```

---

title: Expanding Environment Variables
description: Demonstrates how Bun automatically expands environment variables defined in `.env` files. This allows referencing previously-defined variables to construct compound values like connection strings.
source: docs/runtime/env.md#_snippet_5

language: txt
code:
```
FOO=world
BAR=hello$FOO
```

language: ts
code:
```
process.env.BAR; // => "helloworld"
```

---

title: Constructing a Database URL Using Variable Expansion
description: Demonstrates a practical example of environment variable expansion by constructing a database URL. It defines separate variables for username, password, host, and port and combines them into a complete connection string.
source: docs/runtime/env.md#_snippet_6

language: txt
code:
```
DB_USER=postgres
DB_PASSWORD=secret
DB_HOST=localhost
DB_PORT=5432
DB_URL=postgres://$DB_USER:$DB_PASSWORD@$DB_HOST:$DB_PORT/$DB_NAME
```

---

title: Importing and Using a Local Module with Extension - TypeScript
description: Illustrates importing a function `hello` from a local module using both a path without extension (`./hello`) and with the `.ts` extension (`./hello.ts`). It showcases that Bun supports both extensionless and extensioned imports, enhancing flexibility in module resolution.
source: docs/runtime/modules.md#_snippet_1

language: ts
code:
```
import { hello } from "./hello";
import { hello } from "./hello.ts"; // this works
```

---

title: Checking Version Compatibility with Bun Semver
description: Demonstrates how to use `Bun.semver.satisfies` to check if a version string satisfies a given semver range. This function returns `true` if the version is compatible with the range and `false` otherwise. It is useful for validating dependencies and ensuring compatibility between software versions.
source: docs/api/semver.md#_snippet_0

language: typescript
code:
```
import { semver } from "bun";

semver.satisfies("1.0.0", "^1.0.0"); // true
semver.satisfies("1.0.0", "^1.0.1"); // false
semver.satisfies("1.0.0", "~1.0.0"); // true
semver.satisfies("1.0.0", "~1.0.1"); // false
semver.satisfies("1.0.0", "1.0.0"); // true
semver.satisfies("1.0.0", "1.0.1"); // false
semver.satisfies("1.0.1", "1.0.0"); // false
semver.satisfies("1.0.0", "1.0.x"); // true
semver.satisfies("1.0.0", "1.x.x"); // true
semver.satisfies("1.0.0", "x.x.x"); // true
semver.satisfies("1.0.0", "1.0.0 - 2.0.0"); // true
semver.satisfies("1.0.0", "1.0.0 - 1.0.1"); // true
```

---

title: Grouping Tests with Describe in Bun:test
description: Illustrates how to group related tests into suites using the `describe` function from `bun:test`. It imports `expect`, `test`, and `describe` from `bun:test` and organizes arithmetic tests within a descriptive block.
source: docs/test/writing.md#_snippet_1

language: ts
code:
```
import { expect, test, describe } from "bun:test";

describe("arithmetic", () => {
  test("2 + 2", () => {
    expect(2 + 2).toBe(4);
  });

  test("2 * 2", () => {
    expect(2 * 2).toBe(4);
  });
});
```

---

title: Testing Asynchronous Operations with Bun:test
description: Demonstrates how to test asynchronous operations using `bun:test`.  The example uses `async/await` to resolve a promise and then asserts the result using `expect`. It imports `expect` and `test` from `bun:test`.
source: docs/test/writing.md#_snippet_2

language: ts
code:
```
import { expect, test } from "bun:test";

test("2 * 2", async () => {
  const result = await Promise.resolve(2 * 2);
  expect(result).toEqual(4);
});
```

---

title: Importing and Using Yaml Files
description: Illustrates how to import and use `.yaml` files after registering the custom loader plugin. The `data.yml` file is imported, and its contents are logged to the console.
source: docs/runtime/plugins.md#_snippet_4

language: ts
code:
```
import * as data from "./data.yml"

console.log(data);
```

language: yaml
code:
```
name: Fast X
releaseYear: 2023
```

---

title: Importing and Using Svelte Components
description: Shows how to import and use a Svelte component after registering the Svelte loader plugin.  First the svelte plugin is imported, then the `MySvelteComponent` is imported, and its render method is called.
source: docs/runtime/plugins.md#_snippet_6

language: js
code:
```
import "./sveltePlugin.ts";
import MySvelteComponent from "./component.svelte";

console.log(MySvelteComponent.render());
```

---

title: Logging JSX Component Trees
description: Illustrates Bun's special logging for JSX, which pretty-prints the component tree when a JSX element is logged to the console. This feature enhances debugging by providing a visual representation of the component structure.
source: docs/runtime/jsx.md#_snippet_8

language: tsx
code:
```
import { Stack, UserCard } from "./components";

console.log(
  <Stack>
    <UserCard name="Dom" bio="Street racer and Corona lover" />
    <UserCard name="Jakob" bio="Super spy and Dom's secret brother" />
  </Stack>
);
```

---

title: Resolving DNS Addresses with TTL - Node.js
description: Demonstrates how to resolve IPv4 addresses for a given hostname using the `node:dns` module in Bun, including retrieving the Time-To-Live (TTL) value for the DNS record. The example uses `dns.promises.resolve4` to asynchronously fetch the addresses and their TTLs, logging the results to the console.
source: docs/api/dns.md#_snippet_0

language: ts
code:
```
import * as dns from "node:dns";

const addrs = await dns.promises.resolve4("bun.com", { ttl: true });
console.log(addrs);
// => [{ address: "172.67.161.226", family: 4, ttl: 0 }, ...]
```

---

title: Converting to Array of Chunks - Bun
description: Illustrates converting a `ReadableStream` to an array of its chunks using `Bun.readableStreamToArray()`. Each chunk in the resulting array may be a string, typed array, or `ArrayBuffer`.
source: docs/api/binary-data.md#_snippet_1

language: typescript
code:
```
// with Bun function
Bun.readableStreamToArray(stream);
```

---

title: Handling WebSocket Events
description: Illustrates how to define WebSocket event handlers within the `websocket` parameter of `Bun.serve`. Supported event handlers include `message`, `open`, `close`, and `drain`, which allow you to respond to different stages of a WebSocket connection's lifecycle.
source: docs/api/websockets.md#_snippet_1

language: typescript
code:
```
Bun.serve({
  fetch(req, server) {}, // upgrade logic
  websocket: {
    message(ws, message) {}, // a message is received
    open(ws) {}, // a socket is opened
    close(ws, code, message) {}, // a socket is closed
    drain(ws) {}, // the socket is ready to receive more data
  },
});
```

---

title: Matching Routes With Query Parameters
description: Illustrates how the `FileSystemRouter` parses query parameters from a URL. The `router.match()` method returns a result object that includes a `query` property containing the parsed parameters, allowing for dynamic handling of URL parameters.
source: docs/api/file-system-router.md#_snippet_1

language: ts
code:
```
router.match("/settings?foo=bar");

// =>
{
  filePath: "/Users/colinmcd94/Documents/bun/fun/pages/settings.tsx",
  kind: "dynamic",
  name: "/settings",
  pathname: "/settings?foo=bar",
  src: "https://mydomain.com/_next/static/pages/settings.tsx",
  query: {
    foo: "bar"
  }
}
```

---

title: Matching Routes With URL Parameters
description: Demonstrates how the `FileSystemRouter` parses URL parameters from dynamic routes. The `router.match()` method automatically extracts parameters from the URL path and returns them in the `params` property of the result object.
source: docs/api/file-system-router.md#_snippet_2

language: ts
code:
```
router.match("/blog/my-cool-post");

// =>
{
  filePath: "/Users/colinmcd94/Documents/bun/fun/pages/blog/[slug].tsx",
  kind: "dynamic",
  name: "/blog/[slug]",
  pathname: "/blog/my-cool-post",
  src: "https://mydomain.com/_next/static/pages/blog/[slug].tsx",
  params: {
    slug: "my-cool-post"
  }
}
```

---

title: Writing and Reading Uint8 Values Using DataView
description: Demonstrates how to use a `DataView` to write and read `Uint8` values at a specific byte offset within an `ArrayBuffer`.  `DataView` provides methods like `setUint8()` and `getUint8()` for manipulating the underlying binary data.
source: docs/api/binary-data.md#_snippet_2

language: typescript
code:
```
const buf = new ArrayBuffer(4);
// [0b00000000, 0b00000000, 0b00000000, 0b00000000]

const dv = new DataView(buf);
dv.setUint8(0, 3); // write value 3 at byte offset 0
dv.getUint8(0); // => 3
// [0b00000011, 0b00000000, 0b00000000, 0b00000000]
```

---

title: Writing and Reading Uint16 Values Using DataView
description: Illustrates writing a `Uint16` value to an `ArrayBuffer` using `DataView`'s `setUint16()` method, and reading the value back with `getUint16()`. It also shows how individual bytes can be accessed after writing a larger data type.
source: docs/api/binary-data.md#_snippet_3

language: typescript
code:
```
dv.setUint16(1, 513);
// [0b00000011, 0b00000010, 0b00000001, 0b00000000]

console.log(dv.getUint16(1)); // => 513

console.log(dv.getUint8(1)); // => 2
console.log(dv.getUint8(2)); // => 1
```

---

title: Implementing the Cat Command - TypeScript
description: Presents a simple implementation of the Linux `cat` command using Bun's file APIs. It reads a file specified as a command-line argument and writes its contents to standard output.
source: docs/api/file-io.md#_snippet_17

language: typescript
code:
```
// Usage
// $ bun ./cat.ts ./path-to-file

import { resolve } from "path";

const path = resolve(process.argv.at(-1));
await Bun.write(Bun.stdout, Bun.file(path));
```

---

title: Rate Limiting with Redis
description: Implements a basic rate limiting function using Redis. It increments a counter for each IP address and checks if the limit has been exceeded, returning a boolean and the remaining requests.
source: docs/api/redis.md#_snippet_0

language: typescript
code:
```
async function rateLimit(ip, limit = 100, windowSecs = 3600) {
  const key = `ratelimit:${ip}`;

  // Increment counter
  const count = await redis.incr(key);

  // Set expiry if this is the first request in window
  if (count === 1) {
    await redis.expire(key, windowSecs);
  }

  // Check if limit exceeded
  return {
    limited: count > limit,
    remaining: Math.max(0, limit - count),
  };
}
```

---

title: Sending a UDP Datagram - TypeScript
description: Illustrates how to send a UDP datagram using `socket.send()`. The code specifies the data to send, the destination port, and the destination IP address.  Note that `send` does not perform DNS resolution.
source: docs/api/udp.md#_snippet_1

language: typescript
code:
```
socket.send(
```

---

title: Inserting Data into a Table - TypeScript
description: Illustrates how to insert data into a PostgreSQL table using Bun's SQL client.  The first example demonstrates inserting data with direct values, showcasing how Bun handles escaping to prevent SQL injection. The second example uses an object helper (`sql(userData)`) for a cleaner syntax, demonstrating how Bun expands the object into a SQL `VALUES` clause.
source: docs/api/sql.md#_snippet_1

language: ts
code:
```
import { sql } from "bun";

// Basic insert with direct values
const [user] = await sql`
  INSERT INTO users (name, email)
  VALUES (${name}, ${email})
  RETURNING *
`;

// Using object helper for cleaner syntax
const userData = {
  name: "Alice",
  email: "alice@example.com",
};

const [newUser] = await sql`
  INSERT INTO users ${sql(userData)}
  RETURNING *
`;
// Expands to: INSERT INTO users (name, email) VALUES ('Alice', 'alice@example.com')
```

---

title: Creating Typed Array with Specified Length
description: Demonstrates creating a `Uint8Array` with a specified length directly in the constructor, without needing a pre-existing `ArrayBuffer`. The elements of the typed array are initialized to zero by default.
source: docs/api/binary-data.md#_snippet_3

language: ts
code:
```
const arr2 = new Uint8Array(5);

// all elements are initialized to zero
// => Uint8Array(5) [0, 0, 0, 0, 0]
```

---

title: Creating Typed Arrays from Arrays or Typed Arrays
description: Illustrates how to instantiate typed arrays (`Uint8Array`) directly from regular JavaScript arrays of numbers or from another typed array. This provides convenient ways to populate typed arrays with initial data.
source: docs/api/binary-data.md#_snippet_4

language: ts
code:
```
// from an array of numbers
const arr1 = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7]);
arr1[0]; // => 0;
arr1[7]; // => 7;

// from another typed array
const arr2 = new Uint8Array(arr);
```

---

title: Encoding and Decoding Strings Using TextEncoder and TextDecoder
description: Demonstrates the usage of `TextEncoder` to encode a string into a `Uint8Array` using UTF-8 encoding, and `TextDecoder` to decode a `Uint8Array` back into a string. This showcases the fundamental process of converting between string and binary data.
source: docs/api/binary-data.md#_snippet_7

language: ts
code:
```
const encoder = new TextEncoder();
const bytes = encoder.encode("hello world");
// => Uint8Array(11) [ 104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100 ]

const decoder = new TextDecoder();
const text = decoder.decode(bytes);
// => hello world
```

---

title: Transforming Code Synchronously With The Transpiler - JavaScript
description: Demonstrates using the `transformSync` method to transpile code. It takes code as input and returns vanilla JavaScript.  The module is not resolved or executed.
source: docs/api/transpiler.md#_snippet_1

language: javascript
code:
```
const transpiler = new Bun.Transpiler({
  loader: 'tsx',
});

const code = `
import * as whatever from "./whatever.ts"
export function Home(props: {title: string}){
  return <p>{props.title}</p>;
}`;

const result = transpiler.transformSync(code);
```

language: javascript
code:
```
import { __require as require } from "bun:wrap";
import * as JSX from "react/jsx-dev-runtime";
var jsx = require(JSX).jsxDEV;

export default jsx(
  "div",
  {
    children: "hi!",
  },
  undefined,
  false,
  undefined,
  this,
);
```

---

title: Transforming Code Asynchronously - JavaScript
description: Demonstrates using the asynchronous `transform()` method to transpile code. It returns a `Promise<string>` that resolves with the transpiled JavaScript code.
source: docs/api/transpiler.md#_snippet_3

language: javascript
code:
```
const transpiler = new Bun.Transpiler({ loader: "jsx" });
const result = await transpiler.transform("<div>hi!</div>");
console.log(result);
```

---

title: Determining Script Entrypoint
description: Demonstrates how to check if a script is being executed directly or imported as a module using `Bun.main` and `import.meta.path`.  When `import.meta.path` is equal to `Bun.main`, it indicates the script is the main entry point.
source: docs/api/utils.md#_snippet_2

language: typescript
code:
```
Bun.main;
// /path/to/script.ts
```

language: typescript
code:
```
if (import.meta.path === Bun.main) {
  // this script is being directly executed
} else {
  // this file is being imported from another script
}
```

---

title: Implementing Addition Calculator Interactively - TypeScript
description: Demonstrates reading from stdin using the `console` object within an interactive program. The example creates a simple addition calculator that prompts the user for numbers and displays the running total. It uses an async for-await-of loop to process user input line by line.
source: docs/api/console.md#_snippet_2

language: ts
code:
```
console.log(`Let's add some numbers!`);
console.write(`Count: 0\n> `);

let count = 0;
for await (const line of console) {
  count += Number(line);
  console.write(`Count: ${count}\n> `);
}
```

---

title: Attaching Contextual Data to a Socket
description: Illustrates how to attach contextual data to a socket within the `open` handler. This allows you to associate session-specific information, such as a `sessionId`, with each socket, enabling personalized communication and tracking.
source: docs/api/tcp.md#_snippet_1

language: typescript
code:
```
type SocketData = { sessionId: string };

Bun.listen<SocketData>({
  hostname: "localhost",
  port: 8080,
  socket: {
    data(socket, data) {
      socket.write(`${socket.data.sessionId}: ack`);
    },
    open(socket) {
      socket.data = { sessionId: "abcd" };
    },
  },
});
```

---

title: Enabling TLS for Secure Communication
description: Demonstrates how to enable TLS for secure TCP communication using `Bun.listen`. The `tls` object is configured with the `key` and `cert` fields, which specify the paths to your TLS key and certificate files for establishing encrypted connections.
source: docs/api/tcp.md#_snippet_2

language: typescript
code:
```
Bun.listen({
  hostname: "localhost",
  port: 8080,
  socket: {
    data(socket, data) {},
  },
  tls: {
    // can be string, BunFile, TypedArray, Buffer, or array thereof
    key: Bun.file("./key.pem"),
    cert: Bun.file("./cert.pem"),
  },
});
```

---

title: Using Not Modifier - JavaScript
description: Illustrates the usage of the `.not` modifier to negate a matcher.  It is used to check that a value does not satisfy a specific condition, such as not being equal to another value.
source: docs/test/writing.md#_snippet_0

language: javascript
code:
```
expect(true).not.toBe(false);
```

---

title: Comparing Values Using ToBe - JavaScript
description: Demonstrates the use of the `.toBe()` matcher to perform a strict equality comparison between two values. It checks if the expected value is exactly equal to the actual value.
source: docs/test/writing.md#_snippet_1

language: javascript
code:
```
expect(1).toBe(1);
```

---

title: Testing Deep Equality Using ToEqual - JavaScript
description: Illustrates the `.toEqual()` matcher, which performs a deep equality check. This means it compares the values of all properties (and sub-properties) of objects or arrays to determine if they are equivalent.
source: docs/test/writing.md#_snippet_2

language: javascript
code:
```
expect({ a: 1, b: { c: 2 } }).toEqual({ a: 1, b: { c: 2 } });
```

---

title: Checking for Null Values Using ToBeNull - JavaScript
description: Shows how to use the `.toBeNull()` matcher to assert that a value is `null`. This matcher is specifically for checking against the `null` value.
source: docs/test/writing.md#_snippet_3

language: javascript
code:
```
expect(null).toBeNull();
```

---

title: Verifying Undefined Values Using ToBeUndefined - JavaScript
description: Demonstrates the `.toBeUndefined()` matcher to check if a variable or property is `undefined`.  This is useful for determining if a value has not been assigned.
source: docs/test/writing.md#_snippet_4

language: javascript
code:
```
expect(undefined).toBeUndefined();
```

---

title: Testing for NaN Using ToBeNaN - JavaScript
description: Demonstrates the `.toBeNaN()` matcher. It's used to confirm that a value is `NaN` (Not-a-Number), which is a special value that results from invalid mathematical operations.
source: docs/test/writing.md#_snippet_5

language: javascript
code:
```
expect(NaN).toBeNaN();
```

---

title: Checking for Defined Values Using ToBeDefined - JavaScript
description: Illustrates the use of the `.toBeDefined()` matcher to verify that a value is not `undefined`. This checks that a variable has been assigned a value of some kind.
source: docs/test/writing.md#_snippet_6

language: javascript
code:
```
expect(1).toBeDefined();
```

---

title: Checking for Falsy Values Using ToBeFalsy - JavaScript
description: Demonstrates the `.toBeFalsy()` matcher, which checks if a value is falsy. Falsy values in JavaScript include `false`, `0`, `''`, `null`, `undefined`, and `NaN`.
source: docs/test/writing.md#_snippet_7

language: javascript
code:
```
expect(false).toBeFalsy();
```

---

title: Checking for Truthy Values Using ToBeTruthy - JavaScript
description: Illustrates the `.toBeTruthy()` matcher, which checks if a value is truthy. Any value that is not falsy is considered truthy.
source: docs/test/writing.md#_snippet_8

language: javascript
code:
```
expect(true).toBeTruthy();
```

---

title: Verifying Array Containment Using ToContain - JavaScript
description: Demonstrates how to use the `.toContain()` matcher to check if an array contains a specific item. It performs a shallow comparison to determine if the item is present.
source: docs/test/writing.md#_snippet_9

language: javascript
code:
```
expect([1, 2, 3]).toContain(2);
```

---

title: Verifying Object Keys Using ToContainAllKeys - JavaScript
description: Shows the usage of the `.toContainAllKeys()` matcher to assert that an object contains all of the specified keys. It checks if every key in the provided array exists as a key in the object.
source: docs/test/writing.md#_snippet_10

language: javascript
code:
```
expect({ a: 1, b: 2 }).toContainAllKeys(['a', 'b']);
```

---

title: Verifying Object Values Using ToContainValue - JavaScript
description: Demonstrates the `.toContainValue()` matcher to check if an object contains a specific value. It iterates through the object's values and checks for a shallow equality.
source: docs/test/writing.md#_snippet_11

language: javascript
code:
```
expect({ a: 1, b: 2 }).toContainValue(2);
```

---

title: Verifying Multiple Object Values Using ToContainValues - JavaScript
description: Illustrates the use of `.toContainValues()` matcher, used to assert that an object contains multiple specified values. It verifies the existence of each value in the object.
source: docs/test/writing.md#_snippet_12

language: javascript
code:
```
expect({ a: 1, b: 2, c: 3 }).toContainValues([1, 2]);
```

---

title: Verifying All Object Values Using ToContainAllValues - JavaScript
description: Demonstrates the `.toContainAllValues()` matcher. It asserts that an object contains all values specified in the provided array.  All values in the array must exist as values in the object for the assertion to pass.
source: docs/test/writing.md#_snippet_13

language: javascript
code:
```
expect({ a: 1, b: 2 }).toContainAllValues([1, 2]);
```

---

title: Verifying Any Object Values Using ToContainAnyValues - JavaScript
description: Shows the usage of `.toContainAnyValues()` matcher, which checks if an object contains any of the specified values.  The assertion passes if at least one of the provided values exists as a value in the object.
source: docs/test/writing.md#_snippet_14

language: javascript
code:
```
expect({ a: 1, b: 2 }).toContainAnyValues([2, 3]);
```

---

title: Comparing Deep Equality Using ToStrictEqual - JavaScript
description: Demonstrates the use of `.toStrictEqual()` matcher. It performs a strict deep equality comparison, checking for both value and type equality of all properties, including prototype properties and Symbol properties.
source: docs/test/writing.md#_snippet_15

language: javascript
code:
```
expect({ a: 1, b: { c: 2 } }).toStrictEqual({ a: 1, b: { c: 2 } });
```

---

title: Checking for Exceptions Using ToThrow - JavaScript
description: Illustrates the `.toThrow()` matcher, used to assert that a function throws an error when called. This is useful for testing error handling in your code.
source: docs/test/writing.md#_snippet_16

language: javascript
code:
```
expect(() => { throw new Error('This is an error'); }).toThrow();
```

---

title: Verifying Length Using ToHaveLength - JavaScript
description: Demonstrates the `.toHaveLength()` matcher, which checks if an object has a specific length property. It's commonly used with strings, arrays, and other objects that have a length property.
source: docs/test/writing.md#_snippet_17

language: javascript
code:
```
expect([1, 2, 3]).toHaveLength(3);
```

---

title: Verifying Property Existence Using ToHaveProperty - JavaScript
description: Shows how to use `.toHaveProperty()` matcher to check if an object has a specific property. It allows you to assert the presence of a property and optionally its value.
source: docs/test/writing.md#_snippet_18

language: javascript
code:
```
expect({ a: 1, b: 2 }).toHaveProperty('a');
```

---

title: Matching Anything Using Anything - JavaScript
description: Illustrates the use of `.anything()` matcher, which matches anything other than `null` or `undefined`. It is useful when you want to ensure that a value exists without being specific about what the value is.
source: docs/test/writing.md#_snippet_20

language: javascript
code:
```
expect(1).toEqual(expect.anything());
```

---

title: Matching Constructor Type Using Any - JavaScript
description: Demonstrates the usage of the `.any()` matcher, which checks if a value is of a certain constructor type. It uses `instanceof` internally.
source: docs/test/writing.md#_snippet_21

language: javascript
code:
```
expect(123).toEqual(expect.any(Number));
```

---

title: Matching Array Contents Using ArrayContaining - JavaScript
description: Illustrates the use of the `.arrayContaining()` matcher. This matcher asserts that an array contains at least the elements in the expected array.
source: docs/test/writing.md#_snippet_22

language: javascript
code:
```
expect([1, 2, 3]).toEqual(expect.arrayContaining([2, 1]));
```

---

title: Testing Closeness Of Floating Points Using CloseTo - JavaScript
description: Demonstrates how to use the `.closeTo()` matcher to compare floating point numbers with a certain degree of precision. It is used to avoid issues with floating-point precision errors.
source: docs/test/writing.md#_snippet_24

language: javascript
code:
```
expect(0.1 + 0.2).toBeCloseTo(0.3, 5);
```

---

title: Matching Object Contents Using ObjectContaining - JavaScript
description: Demonstrates the use of the `.objectContaining()` matcher, which asserts that an object contains at least the properties in the expected object.
source: docs/test/writing.md#_snippet_26

language: javascript
code:
```
expect({ a: 1, b: 2, c: 3 }).toEqual(expect.objectContaining({ a: 1, b: 2 }));
```

---

title: Matching String Contents Using StringContaining - JavaScript
description: Shows how to use the `.stringContaining()` matcher, which checks if a string contains a substring.  This is a case-sensitive match.
source: docs/test/writing.md#_snippet_27

language: javascript
code:
```
expect('hello world').toEqual(expect.stringContaining('world'));
```

---

title: Matching String Contents Using StringMatching - JavaScript
description: Demonstrates the `.stringMatching()` matcher, which asserts that a string matches a regular expression or another string. This provides a more flexible way to check string contents.
source: docs/test/writing.md#_snippet_28

language: javascript
code:
```
expect('hello world').toEqual(expect.stringMatching(/world/));
```

---

title: Awaiting Promises Using Resolves - JavaScript
description: Illustrates the use of `.resolves` matcher to assert that a promise resolves with a specific value. It is a convenient way to handle asynchronous tests with promises.
source: docs/test/writing.md#_snippet_29

language: javascript
code:
```
await expect(Promise.resolve('success')).resolves.toBe('success');
```

---

title: Awaiting Promise Rejections Using Rejects - JavaScript
description: Demonstrates using the `.rejects` matcher to assert that a promise rejects with an error. This is helpful for testing error handling in asynchronous operations.
source: docs/test/writing.md#_snippet_30

language: javascript
code:
```
await expect(Promise.reject(new Error('error'))).rejects.toThrow('error');
```

---

title: Verifying Function Calls Using ToHaveBeenCalled - JavaScript
description: Demonstrates the use of `.toHaveBeenCalled()` matcher, which asserts that a mock function has been called. This ensures that a specific function has been executed during the test.
source: docs/test/writing.md#_snippet_31

language: javascript
code:
```
const mockFn = jest.fn();
mockFn();
expect(mockFn).toHaveBeenCalled();
```

---

title: Verifying Call Count Using ToHaveBeenCalledTimes - JavaScript
description: Illustrates the use of `.toHaveBeenCalledTimes()` matcher, which allows you to check how many times a mock function has been called. This helps to verify that a function is called the expected number of times.
source: docs/test/writing.md#_snippet_32

language: javascript
code:
```
const mockFn = jest.fn();
mockFn();
mockFn();
expect(mockFn).toHaveBeenCalledTimes(2);
```

---

title: Verifying Call Arguments Using ToHaveBeenCalledWith - JavaScript
description: Demonstrates the `.toHaveBeenCalledWith()` matcher, used to assert that a mock function was called with specific arguments. This allows you to ensure that the function received the expected input.
source: docs/test/writing.md#_snippet_33

language: javascript
code:
```
const mockFn = jest.fn();
mockFn(1, 2);
expect(mockFn).toHaveBeenCalledWith(1, 2);
```

---

title: Verifying Last Call Arguments Using ToHaveBeenLastCalledWith - JavaScript
description: Illustrates the use of `.toHaveBeenLastCalledWith()` matcher, which checks the arguments of the last call to a mock function.  This is useful when the function is called multiple times and you only care about the last set of arguments.
source: docs/test/writing.md#_snippet_34

language: javascript
code:
```
const mockFn = jest.fn();
mockFn(1);
mockFn(2);
expect(mockFn).toHaveBeenLastCalledWith(2);
```

---

title: Verifying Nth Call Arguments Using ToHaveBeenNthCalledWith - JavaScript
description: Demonstrates the `.toHaveBeenNthCalledWith()` matcher, used to assert that a mock function was called with specific arguments in a specific call order. It provides fine-grained control over testing the arguments of each individual call.
source: docs/test/writing.md#_snippet_35

language: javascript
code:
```
const mockFn = jest.fn();
mockFn(1);
mockFn(2);
expect(mockFn).toHaveBeenNthCalledWith(1, 1);
```

---

title: Verifying Function Returns Using ToHaveReturned - JavaScript
description: Demonstrates the `.toHaveReturned()` matcher, used to assert that a mock function has returned at least once. It checks if the function has been called and returned a value.
source: docs/test/writing.md#_snippet_36

language: javascript
code:
```
const mockFn = jest.fn(() => 'result');
mockFn();
expect(mockFn).toHaveReturned();
```

---

title: Verifying Return Call Count Using ToHaveReturnedTimes - JavaScript
description: Illustrates the use of `.toHaveReturnedTimes()` matcher, which checks how many times a mock function has returned a value. This is useful for verifying that a function returns the expected number of times.
source: docs/test/writing.md#_snippet_37

language: javascript
code:
```
const mockFn = jest.fn(() => 'result');
mockFn();
mockFn();
expect(mockFn).toHaveReturnedTimes(2);
```

---

title: Comparing Closeness Of Numbers Using ToBeCloseTo - JavaScript
description: Demonstrates the `.toBeCloseTo()` matcher, which is used to compare floating point numbers for approximate equality. This is useful because floating point numbers may not be exactly equal due to precision issues.
source: docs/test/writing.md#_snippet_38

language: javascript
code:
```
expect(0.1 + 0.2).toBeCloseTo(0.3, 5);
```

---

title: Comparing Greater Than Using ToBeGreaterThan - JavaScript
description: Demonstrates the use of `.toBeGreaterThan()` matcher, which asserts that a value is greater than another value. It is used for comparing numbers.
source: docs/test/writing.md#_snippet_39

language: javascript
code:
```
expect(2).toBeGreaterThan(1);
```

---

title: Comparing Greater Than Or Equal Using ToBeGreaterThanOrEqual - JavaScript
description: Illustrates using `.toBeGreaterThanOrEqual()` matcher, which checks if a value is greater than or equal to another value. It is used for numerical comparisons.
source: docs/test/writing.md#_snippet_40

language: javascript
code:
```
expect(2).toBeGreaterThanOrEqual(2);
```

---

title: Comparing Less Than Using ToBeLessThan - JavaScript
description: Demonstrates the `.toBeLessThan()` matcher, used to assert that a value is less than another value. This is for numeric comparisons.
source: docs/test/writing.md#_snippet_41

language: javascript
code:
```
expect(1).toBeLessThan(2);
```

---

title: Comparing Less Than Or Equal Using ToBeLessThanOrEqual - JavaScript
description: Illustrates the usage of `.toBeLessThanOrEqual()` matcher, which asserts that a value is less than or equal to another value. It's used for number comparisons.
source: docs/test/writing.md#_snippet_42

language: javascript
code:
```
expect(2).toBeLessThanOrEqual(2);
```

---

title: Checking Instance Type Using ToBeInstanceOf - JavaScript
description: Demonstrates the `.toBeInstanceOf()` matcher, used to assert that a value is an instance of a class. It uses `instanceof` operator internally.
source: docs/test/writing.md#_snippet_43

language: javascript
code:
```
class MyClass {}
const myInstance = new MyClass();
expect(myInstance).toBeInstanceOf(MyClass);
```

---

title: Verifying Array Containment Using ToContainEqual - JavaScript
description: Illustrates how to use the `.toContainEqual()` matcher, which checks if an array contains an item that is deeply equal to a specific value. It performs a deep comparison to determine if the item is present.
source: docs/test/writing.md#_snippet_44

language: javascript
code:
```
expect([{ a: 1 }, { b: 2 }]).toContainEqual({ a: 1 });
```

---

title: Matching String Patterns Using ToMatch - JavaScript
description: Demonstrates the `.toMatch()` matcher, used to assert that a string matches a regular expression. This is useful for verifying that a string conforms to a certain pattern.
source: docs/test/writing.md#_snippet_45

language: javascript
code:
```
expect('hello world').toMatch(/world/);
```

---

title: Matching Object Structures Using ToMatchObject - JavaScript
description: Illustrates the `.toMatchObject()` matcher, which checks if an object matches a subset of properties of another object. It's useful for verifying that an object has certain properties with specific values without checking all properties.
source: docs/test/writing.md#_snippet_46

language: javascript
code:
```
expect({ a: 1, b: 2, c: 3 }).toMatchObject({ a: 1, b: 2 });
```

---

title: Configuring S3Client with Cloudflare R2
description: Demonstrates how to instantiate `S3Client` to connect to Cloudflare R2. It sets the `endpoint` configuration to the R2 endpoint, including the account ID.
source: docs/api/s3.md#_snippet_0

language: typescript
code:
```
import { S3Client } from "bun";

// CloudFlare R2
const r2 = new S3Client({
  accessKeyId: "access-key",
  secretAccessKey: "secret-key",
  bucket: "my-bucket",
  endpoint: "https://<account-id>.r2.cloudflarestorage.com",
});
```

---

title: Configuring S3Client with DigitalOcean Spaces
description: Illustrates how to configure `S3Client` for use with DigitalOcean Spaces. It configures the `endpoint` to the DigitalOcean Spaces endpoint.
source: docs/api/s3.md#_snippet_1

language: typescript
code:
```
import { S3Client } from "bun";

const spaces = new S3Client({
  accessKeyId: "access-key",
  secretAccessKey: "secret-key",
  bucket: "my-bucket",
  // region: "nyc3",
  endpoint: "https://<region>.digitaloceanspaces.com",
});
```

---

title: Configuring S3Client with MinIO
description: Shows how to set up `S3Client` to work with a MinIO instance. It sets the `endpoint` to the URL where MinIO is running.
source: docs/api/s3.md#_snippet_2

language: typescript
code:
```
import { S3Client } from "bun";

const minio = new S3Client({
  accessKeyId: "access-key",
  secretAccessKey: "secret-key",
  bucket: "my-bucket",

  // Make sure to use the correct endpoint URL
  // It might not be localhost in production!
  endpoint: "http://localhost:9000",
});
```

---

title: Configuring S3Client with Supabase
description: Demonstrates the setup of `S3Client` for connecting to Supabase storage. It configures the `endpoint` to include the account ID and `/storage/v1/s3` path, also setting the region.
source: docs/api/s3.md#_snippet_3

language: typescript
code:
```
import { S3Client } from "bun";

const supabase = new S3Client({
  accessKeyId: "access-key",
  secretAccessKey: "secret-key",
  bucket: "my-bucket",
  region: "us-west-1",
  endpoint: "https://<account-id>.supabase.co/storage/v1/s3/storage",
});
```

---

title: Using S3 Virtual Hosted-Style Endpoints
description: Demonstrates how to use S3 Virtual Hosted-Style endpoints with `S3Client`. It shows examples with AWS S3, Cloudflare R2, with and without an explicit `endpoint`.
source: docs/api/s3.md#_snippet_4

language: typescript
code:
```
import { S3Client } from "bun";

// AWS S3 endpoint inferred from region and bucket
const s3 = new S3Client({
  accessKeyId: "access-key",
  secretAccessKey: "secret-key",
  bucket: "my-bucket",
  virtualHostedStyle: true,
  // endpoint:
```

language: typescript
code:
```
// AWS S3
const s3WithEndpoint = new S3Client({
  accessKeyId: "access-key",
  secretAccessKey: "secret-key",
  endpoint: "https://<bucket-name>.s3.<region>.amazonaws.com",
  virtualHostedStyle: true,
});

// Cloudflare R2
const r2WithEndpoint = new S3Client({
  accessKeyId: "access-key",
  secretAccessKey: "secret-key",
  endpoint: "https://<bucket-name>.<account-id>.r2.cloudflarestorage.com",
  virtualHostedStyle: true,
});
```

---

title: Returning a C String to JavaScript with N-API
description: Illustrates how to return a C string to JavaScript using N-API within `bun:ffi`. It imports the `cc` function, defines a C function that creates a N-API string, and then calls this function from JavaScript. The `napi_env` argument and `napi_value` return type are key to interoperability.
source: docs/api/cc.md#_snippet_1

language: typescript
code:
```
import { cc } from "bun:ffi";
import source from "./hello.c" with { type: "file" };

const {
  symbols: { hello },
} = cc({
  source,
  symbols: {
    hello: {
      args: ["napi_env"],
      returns: "napi_value",
    },
  },
});

const result = hello();
```

language: c
code:
```
#include <node/node_api.h>

napi_value hello(napi_env env) {
  napi_value result;
  napi_create_string_utf8(env, "Hello, Napi!", NAPI_AUTO_LENGTH, &result);
  return result;
}
```

---

title: Debugging SQL Queries - Using toString
description: Demonstrates how to use `.toString()` to print the expanded SQL query with bound parameters. This is a helpful debugging technique for inspecting the final SQL statement being executed, especially when dealing with parameterized queries.
source: docs/api/sqlite.md#_snippet_4

language: typescript
code:
```
import { Database } from "bun:sqlite";

// setup
const query = db.query("SELECT $param;");

console.log(query.toString()); // => "SELECT NULL"

query.run(42);
console.log(query.toString()); // => "SELECT 42"

query.run(365);
console.log(query.toString()); // => "SELECT 365"
```

---

title: Executing Atomic Operations - With Transactions
description: Demonstrates how to use transactions to execute multiple queries in an atomic manner. Transactions ensure that either all queries succeed, or none of them do, guaranteeing data consistency.
source: docs/api/sqlite.md#_snippet_10

language: typescript
code:
```
const insertCat = db.prepare("INSERT INTO cats (name) VALUES ($name)");
const insertCats = db.transaction(cats => {
  for (const cat of cats) insertCat.run(cat);
});
```

---

title: Formatting Colors as CSS
description: Demonstrates how to format colors as CSS using `Bun.color` with the `css` option. It returns the most compact CSS representation of the color, suitable for stylesheets or inline styles.
source: docs/api/color.md#_snippet_0

language: ts
code:
```
Bun.color("red", "css"); // "red"
Bun.color(0xff0000, "css"); // "#f000"
Bun.color("#f00", "css"); // "red"
Bun.color("#ff0000", "css"); // "red"
Bun.color("rgb(255, 0, 0)", "css"); // "red"
Bun.color("rgba(255, 0, 0, 1)", "css"); // "red"
Bun.color("hsl(0, 100%, 50%)", "css"); // "red"
Bun.color("hsla(0, 100%, 50%, 1)", "css"); // "red"
Bun.color({ r: 255, g: 0, b: 0 }, "css"); // "red"
Bun.color({ r: 255, g: 0, b: 0, a: 1 }, "css"); // "red"
Bun.color([255, 0, 0], "css"); // "red"
Bun.color([255, 0, 0, 255], "css"); // "red"
```

---

title: Formatting Colors as ANSI (for Terminals)
description: Illustrates how to format colors as ANSI escape codes using `Bun.color` with the `ansi` option for colorful terminal output. It automatically chooses the appropriate ANSI color format based on the environment.
source: docs/api/color.md#_snippet_1

language: ts
code:
```
Bun.color("red", "ansi"); // "\u001b[38;2;255;0;0m"
Bun.color(0xff0000, "ansi"); // "\u001b[38;2;255;0;0m"
Bun.color("#f00", "ansi"); // "\u001b[38;2;255;0;0m"
Bun.color("#ff0000", "ansi"); // "\u001b[38;2;255;0;0m"
Bun.color("rgb(255, 0, 0)", "ansi"); // "\u001b[38;2;255;0;0m"
Bun.color("rgba(255, 0, 0, 1)", "ansi"); // "\u001b[38;2;255;0;0m"
Bun.color("hsl(0, 100%, 50%)", "ansi"); // "\u001b[38;2;255;0;0m"
Bun.color("hsla(0, 100%, 50%, 1)", "ansi"); // "\u001b[38;2;255;0;0m"
Bun.color({ r: 255, g: 0, b: 0 }, "ansi"); // "\u001b[38;2;255;0;0m"
Bun.color({ r: 255, g: 0, b: 0, a: 1 }, "ansi"); // "\u001b[38;2;255;0;0m"
Bun.color([255, 0, 0], "ansi"); // "\u001b[38;2;255;0;0m"
Bun.color([255, 0, 0, 255], "ansi"); // "\u001b[38;2;255;0;0m"
```

---

title: Formatting Colors as 24-bit ANSI Colors (ansi-16m)
description: Demonstrates how to format colors as 24-bit ANSI escape codes using `Bun.color` with the `ansi-16m` option. This allows displaying 16 million colors on supported terminals.
source: docs/api/color.md#_snippet_2

language: ts
code:
```
Bun.color("red", "ansi-16m"); // "\x1b[38;2;255;0;0m"
Bun.color(0xff0000, "ansi-16m"); // "\x1b[38;2;255;0;0m"
Bun.color("#f00", "ansi-16m"); // "\x1b[38;2;255;0;0m"
Bun.color("#ff0000", "ansi-16m"); // "\x1b[38;2;255;0;0m"
```

---

title: Formatting Colors as 256 ANSI Colors (ansi-256)
description: Illustrates how to format colors as 256 ANSI escape codes using `Bun.color` with the `ansi-256` option. This approximates the input color to the nearest of the 256 ANSI colors.
source: docs/api/color.md#_snippet_3

language: ts
code:
```
Bun.color("red", "ansi-256"); // "\u001b[38;5;196m"
Bun.color(0xff0000, "ansi-256"); // "\u001b[38;5;196m"
Bun.color("#f00", "ansi-256"); // "\u001b[38;5;196m"
Bun.color("#ff0000", "ansi-256"); // "\u001b[38;5;196m"
```

---

title: Formatting Colors as 16 ANSI Colors (ansi-16)
description: Demonstrates how to format colors as 16 ANSI escape codes using `Bun.color` with the `ansi-16` option. This approximates the input color to the nearest of the 16 ANSI colors supported by most terminals.
source: docs/api/color.md#_snippet_4

language: ts
code:
```
Bun.color("red", "ansi-16"); // "\u001b[38;5;\tm"
Bun.color(0xff0000, "ansi-16"); // "\u001b[38;5;\tm"
Bun.color("#f00", "ansi-16"); // "\u001b[38;5;\tm"
Bun.color("#ff0000", "ansi-16"); // "\u001b[38;5;\tm"
```

---

title: Formatting Colors as Numbers
description: Illustrates how to format colors as 24-bit numbers using `Bun.color` with the `number` option. This creates a compact representation of the color suitable for databases or configuration files.
source: docs/api/color.md#_snippet_5

language: ts
code:
```
Bun.color("red", "number"); // 16711680
Bun.color(0xff0000, "number"); // 16711680
Bun.color({ r: 255, g: 0, b: 0 }, "number"); // 16711680
Bun.color([255, 0, 0], "number"); // 16711680
Bun.color("rgb(255, 0, 0)", "number"); // 16711680
Bun.color("rgba(255, 0, 0, 1)", "number"); // 16711680
Bun.color("hsl(0, 100%, 50%)", "number"); // 16711680
Bun.color("hsla(0, 100%, 50%, 1)", "number"); // 16711680
```

---

title: Formatting Colors as Lowercase Hex Strings
description: Illustrates how to format colors as lowercase hex strings using `Bun.color` with the `hex` option. This is commonly used in CSS or other contexts requiring hex color codes.
source: docs/api/color.md#_snippet_10

language: ts
code:
```
Bun.color("hsl(0, 0%, 50%)", "hex"); // "#808080"
Bun.color("red", "hex"); // "#ff0000"
Bun.color(0xff0000, "hex"); // "#ff0000"
Bun.color({ r: 255, g: 0, b: 0 }, "hex"); // "#ff0000"
Bun.color([255, 0, 0], "hex"); // "#ff0000"
```

---

title: Formatting Colors as Uppercase Hex Strings
description: Demonstrates how to format colors as uppercase hex strings using `Bun.color` with the `HEX` option. This is useful in contexts where uppercase hex codes are preferred.
source: docs/api/color.md#_snippet_11

language: ts
code:
```
Bun.color("hsl(0, 0%, 50%)", "HEX"); // "#808080"
Bun.color("red", "HEX"); // "#FF0000"
Bun.color(0xff0000, "HEX"); // "#FF0000"
Bun.color({ r: 255, g: 0, b: 0 }, "HEX"); // "#FF0000"
Bun.color([255, 0, 0], "HEX"); // "#FF0000"
```

---

title: Enabling Write-Ahead Logging (WAL)
description: Demonstrates how to enable Write-Ahead Logging (WAL) mode in SQLite to improve performance, especially with concurrent readers and a single writer. WAL mode writes changes to a separate WAL file before integrating them into the main database file. The snippet shows the pragma query to enable WAL.
source: docs/api/sqlite.md#_snippet_11

language: ts
code:
```
db.exec("PRAGMA journal_mode = WAL;");
```

---

title: Sending Messages to Worker
description: Illustrates sending messages between the main thread and a worker thread using `postMessage`. Messages are sent using the structured clone algorithm.
source: docs/api/workers.md#_snippet_8

language: js
code:
```
// On the worker thread, `postMessage` is automatically "routed" to the parent thread.
postMessage({ hello: "world" });

// On the main thread
worker.postMessage({ hello: "world" });
```

---

title: Handling Messages with Event Listeners
description: Demonstrates how to use event listeners to handle incoming messages in both the worker and main threads.  This example shows both `addEventListener` and the `onmessage` setter approach.
source: docs/api/workers.md#_snippet_9

language: js
code:
```
// Worker thread:
self.addEventListener("message", event => {
  console.log(event.data);
});
// or use the setter:
// self.onmessage = fn

// if on the main thread
worker.addEventListener("message", event => {
  console.log(event.data);
});
// or use the setter:
// worker.onmessage = fn
```

---

title: Committing Patched Changes-Bash
description: Illustrates how to commit changes made to a patched package using `bun patch --commit`. This command generates a patch file in the `patches/` directory, updates the `package.json` and lockfile, and ensures Bun uses the patched package in subsequent operations.
source: docs/install/patch.md#_snippet_1

language: bash
code:
```
# you can supply the path to the patched package
$ bun patch --commit node_modules/react

# ... or the package name and optionally the version
$ bun patch --commit react@17.0.2

# choose the directory to store the patch files
$ bun patch --commit react --patches-dir=mypatches

# `patch-commit` is available for compatibility with pnpm
$ bun patch-commit react
```

---

title: Handling Vulnerability-Free Scenarios - CLI
description: Illustrates the output when no vulnerabilities are found during a `bun audit`. This response indicates that all checked packages are secure.
source: docs/install/audit.md#_snippet_1

language: text
code:
```
No vulnerabilities found
```

---

title: Configuring Workspaces in Packagejson
description: Demonstrates how to configure workspaces in the root `package.json` file of a monorepo. The `workspaces` key specifies an array of glob patterns that identify subdirectories as individual packages within the monorepo, enabling efficient dependency management and code sharing.
source: docs/install/workspaces.md#_snippet_0

language: json
code:
```
{
  "name": "my-project",
  "version": "1.0.0",
  "workspaces": ["packages/*"],
  "devDependencies": {
    "example-package-in-monorepo": "workspace:*"
  }
}
```

---

title: Defining Dependencies Using Postinstall
description: Defines a `package.json` file that declares `node-sass` as a dependency. `node-sass` commonly uses the `postinstall` lifecycle script to build a native binary for Sass, making this example relevant for illustrating how Bun handles such scripts.
source: docs/install/lifecycle.md#_snippet_0

language: json
code:
```
{
  "name": "my-app",
  "version": "1.0.0",
  "dependencies": {
    "node-sass": "^6.0.1"
  }
}
```

---

title: Configuring Dependency Overrides- package.json
description: Demonstrates how to use the `overrides` field in `package.json` to specify a version range for a metadependency. This allows you to pin a specific version of `bar` to `~4.4.0`, overriding the version specified by `foo`.
source: docs/install/overrides.md#_snippet_0

language: json-diff
code:
```
  {
    "name": "my-app",
    "dependencies": {
      "foo": "^2.0.0"
    },
+   "overrides": {
+     "bar": "~4.4.0"
+   }
  }
```

---

title: Configuring Dependency Resolutions- package.json
description: Illustrates using the `resolutions` field in `package.json` as an alternative to `overrides` for specifying version ranges for metadependencies.  Like `overrides`, it allows pinning a specific version; here, `bar` is pinned to `~4.4.0`.
source: docs/install/overrides.md#_snippet_2

language: json-diff
code:
```
  {
    "name": "my-app",
    "dependencies": {
      "foo": "^2.0.0"
    },
+   "resolutions": {
+     "bar": "~4.4.0"
+   }
  }
```

---

title: Prefetching DNS Entries with Bun
description: Demonstrates how to use the `dns.prefetch` API to prefetch a DNS entry. This is useful when you know you'll need to connect to a host soon and want to avoid the initial DNS lookup.
source: docs/api/fetch.md#_snippet_0

language: typescript
code:
```
import { dns } from "bun";

dns.prefetch("bun.com");
```

---

title: Preconnecting to a Host Using Fetch
description: Illustrates the use of `fetch.preconnect` to initiate early DNS lookup, TCP socket connection, and TLS handshake to a host. This is beneficial when a connection will be needed soon, but the request isn't immediately ready.
source: docs/api/fetch.md#_snippet_1

language: typescript
code:
```
import { fetch } from "bun";

fetch.preconnect("https://bun.com");
```

---

title: Preconnecting to a Host at Startup
description: Shows how to preconnect to a host at startup using the `--fetch-preconnect` option. This is similar to `<link rel="preconnect">` in HTML and allows for faster initial connections.
source: docs/api/fetch.md#_snippet_2

language: sh
code:
```
$ bun --fetch-preconnect https://bun.com ./my-script.ts
```

---

title: Implementing Caching With Redis - Bun
description: Illustrates how to use Redis for caching data, specifically fetching user data from a cache and falling back to a database if the data is not cached. The data is then stored in the cache with an expiration time to reduce database load.
source: docs/api/redis.md#_snippet_14

language: ts
code:
```
async function getUserWithCache(userId) {
  const cacheKey = `user:${userId}`;

  // Try to get from cache first
  const cachedUser = await redis.get(cacheKey);
  if (cachedUser) {
    return JSON.parse(cachedUser);
  }

  // Not in cache, fetch from database
  const user = await database.getUser(userId);

  // Store in cache for 1 hour
  await redis.set(cacheKey, JSON.stringify(user));
  await redis.expire(cacheKey, 3600);

  return user;
}
```

---

title: Adding Integers Using Zig
description: Illustrates how to define and compile a Zig function that adds two integers, and then use `bun:ffi` to load the compiled library and call the function from JavaScript. This example shows how to pass integer arguments and retrieve an integer return value.
source: docs/api/ffi.md#_snippet_1

language: zig
code:
```
// add.zig
pub export fn add(a: i32, b: i32) i32 {
  return a + b;
}
```

language: bash
code:
```
$ zig build-lib add.zig -dynamic -OReleaseFast
```

language: typescript
code:
```
import { dlopen, FFIType, suffix } from "bun:ffi";
const { i32 } = FFIType;

const path = `libadd.${suffix}`;

const lib = dlopen(path, {
  add: {
    args: [i32, i32],
    returns: i32,
  },
});

console.log(lib.symbols.add(1, 2));
```

---

title: Adding Integers Using Rust
description: Demonstrates how to define and compile a Rust function that adds two integers, and shows the command to compile the rust code.
source: docs/api/ffi.md#_snippet_2

language: rust
code:
```
// add.rs
#[no_mangle]
pub extern "C" fn add(a: i32, b: i32) -> i32 {
    a + b
}
```

language: bash
code:
```
$ rustc --crate-type cdylib add.rs
```

---

title: Adding Integers Using C++
description: Demonstrates how to define and compile a C++ function that adds two integers. It also includes the compilation command using Zig's build system.
source: docs/api/ffi.md#_snippet_3

language: c++
code:
```
#include <cstdint>

extern "C" int32_t add(int32_t a, int32_t b) {
    return a + b;
}
```

language: bash
code:
```
$ zig build-lib add.cpp -dynamic -lc -lc++
```

---

title: Configuring Hashing Algorithms in Bunpassword
description: Illustrates how to configure the `Bun.password.hash` function to use either the `argon2` or `bcrypt` hashing algorithms. It showcases setting algorithm-specific parameters like `memoryCost` and `timeCost` for Argon2, and `cost` for Bcrypt, to adjust the computational intensity.
source: docs/api/hashing.md#_snippet_1

language: typescript
code:
```
const password = "super-secure-pa$$word";

// use argon2 (default)
const argonHash = await Bun.password.hash(password, {
  algorithm: "argon2id", // "argon2id" | "argon2i" | "argon2d"
  memoryCost: 4, // memory usage in kibibytes
  timeCost: 3, // the number of iterations
});

// use bcrypt
const bcryptHash = await Bun.password.hash(password, {
  algorithm: "bcrypt",
  cost: 4, // number between 4-31
});
```

---

title: Verifying Password Hashes with Algorithm Detection
description: Demonstrates the usage of `Bun.password.verify` to automatically detect the hashing algorithm from the hash itself, supporting both PHC- and MCF-encoded hashes. This enables seamless verification without needing to specify the algorithm used during hashing.
source: docs/api/hashing.md#_snippet_2

language: typescript
code:
```
const password = "super-secure-pa$$word";

const hash = await Bun.password.hash(password, {
  /* config */
});

const isMatch = await Bun.password.verify(password, hash);
// => true
```

---

title: Configuring Default Registry - Bunfig.toml
description: Illustrates how to configure the default registry in `bunfig.toml` using a string, token, or username/password. This is useful for specifying a central repository for package installations.
source: docs/install/registries.md#_snippet_0

language: toml
code:
```
[install]
# set default registry as a string
registry = "https://registry.npmjs.org"
# set a token
registry = { url = "https://registry.npmjs.org", token = "123456" }
# set a username/password
registry = "https://username:password@registry.npmjs.org"
```

---

title: Configuring Scoped Registry - Bunfig.toml
description: Demonstrates how to configure a private registry scoped to a particular organization within `bunfig.toml`.  This allows specific packages to be resolved from a different registry than the default, useful for internal or proprietary packages.
source: docs/install/registries.md#_snippet_1

language: toml
code:
```
[install.scopes]
# registry as string
"@myorg1" = "https://username:password@registry.myorg.com/"

# registry with username/password
# you can reference environment variables
"@myorg2" = { username = "myusername", password = "$NPM_PASS", url = "https://registry.myorg.com/" }

# registry with token
"@myorg3" = { token = "$npm_token", url = "https://registry.myorg.com/" }
```

---

title: Rendering HTML with ArrowJS - Typescript
description: Illustrates rendering HTML using `@stricjs/arrow/utils` within a Stric application. The `render` function utilizes the `html` template literal to create a `<p>` element containing the text 'Hi'. The `path` variable defines the route associated with this component.
source: docs/ecosystem/stric.md#_snippet_1

language: ts
code:
```
import { html } from '@stricjs/arrow/utils';

// Code inside this function can use web APIs
export function render() {
  // Render a <p> element with text 'Hi'
  html`<p>Hi</p>`;
};

// Set the path to handle
export const path = '/';
```

---

title: Setting Default Registry - npmrc
description: Demonstrates how to set the default registry for resolving packages using the `registry` option in `.npmrc`. This configuration allows Bun to fetch packages from a specified custom registry instead of the default npm registry, which is useful for private or internal package hosting.
source: docs/install/npmrc.md#_snippet_0

language: ini
code:
```
registry=http://localhost:4873/
```

---

title: Configuring Registry for Specific Scope - npmrc
description: Illustrates how to configure a specific registry for a given scope using the `@<scope>:registry` option in `.npmrc`. This is useful for organizations that host their own packages under a specific scope and need to direct Bun to resolve those packages from their internal registry.
source: docs/install/npmrc.md#_snippet_1

language: ini
code:
```
@myorg:registry=http://localhost:4873/
```

---

title: Adding Backend Routes with Bun Serve
description: Illustrates how to add backend routes to a frontend using the `routes` option in `Bun.serve`. This enables creating full-stack applications where the frontend and backend are tightly integrated, allowing for efficient handling of requests and responses within the Bun runtime.
source: docs/bundler/html.md#_snippet_0

language: javascript
code:
```
To add a backend to your frontend, you can use the `"routes"` option in `Bun.serve`.

Learn more in [the full-stack docs](/docs/bundler/fullstack).
```

---

title: Configuring React Monorepo Catalogs
description: Shows a comprehensive `package.json` catalog example for a React monorepo. It defines the single `catalog` as well as named catalogs such as `build` and `testing` to manage different groups of dependencies.
source: docs/install/catalogs.md#_snippet_4

language: json
code:
```
{
  "name": "react-monorepo",
  "workspaces": {
    "packages": ["packages/*"],
    "catalog": {
      "react": "^19.0.0",
      "react-dom": "^19.0.0",
      "react-router-dom": "^6.15.0"
    },
    "catalogs": {
      "build": {
        "webpack": "5.88.2",
        "babel": "7.22.10"
      },
      "testing": {
        "jest": "29.6.2",
        "react-testing-library": "14.0.0"
      }
    }
  },
  "devDependencies": {
    "typescript": "5.1.6"
  }
}
```

---

title: Configuring Isolated Installs in bunfigtoml
description: Illustrates setting the default linker strategy to `isolated` within the `bunfig.toml` configuration file.  This configuration ensures that all subsequent `bun install` commands within the project use the isolated installation strategy unless explicitly overridden.  This provides a persistent way to manage dependency resolution.
source: docs/install/isolated.md#_snippet_1

language: toml
code:
```
[install]
linker = "isolated"
```

---

title: Sending a POST Request with Fetch
description: Illustrates how to send a POST request using Bun's `fetch` API. The example sets the `method` to `POST` and includes a `body` with the data to be sent, which can be a string or other supported data type.
source: docs/api/fetch.md#_snippet_1

language: typescript
code:
```
const response = await fetch("http://example.com", {
  method: "POST",
  body: "Hello, world!",
});
```

---

title: Using Async/Await in Bun Serve Routes
description: Demonstrates using `async/await` within `Bun.serve` route handlers. This allows for asynchronous operations, such as database queries, to be performed directly within the route handler, with the result being returned as a `Promise<Response>`.
source: docs/api/http.md#_snippet_2

language: typescript
code:
```
import { sql, serve } from "bun";

serve({
  port: 3001,
  routes: {
    "/api/version": async () => {
      const [version] = await sql`SELECT version()`;
      return Response.json(version);
    },
  },
});
```

---

title: Serving Static Responses with Bun Serve
description: Demonstrates serving static responses using `Bun.serve`, which optimizes for zero-allocation dispatch, enhancing performance for health checks, redirects, and fixed content.  It shows example for custom headers, redirects and API responses.
source: docs/api/http.md#_snippet_5

language: typescript
code:
```
Bun.serve({
  routes: {
    // Health checks
    "/health": new Response("OK"),
    "/ready": new Response("Ready", {
      headers: {
        // Pass custom headers
        "X-Ready": "1",
      },
    }),

    // Redirects
    "/blog": Response.redirect("https://bun.com/blog"),

    // API responses
    "/api/config": Response.json({
      version: "1.0.0",
      env: "production",
    }),
  },
});
```

---

title: Using Native Plugin in Bun Build
description: Illustrates how to use a native plugin within a `Bun.build()` configuration. This snippet shows how to import the native addon and configure the `onBeforeParse` hook to use the native module, enabling pre-processing of files during the build process.
source: docs/bundler/plugins.md#_snippet_3

language: typescript
code:
```
import myNativeAddon from "./my-native-addon";
Bun.build({
  entrypoints: ["./app.tsx"],
  plugins: [
    {
      name: "my-plugin",

      setup(build) {
        build.onBeforeParse(
          {
            namespace: "file",
            filter: "**/*.tsx",
          },
          {
            napiModule: myNativeAddon,
            symbol: "replace_foo_with_bar",
            // external: myNativeAddon.getSharedState()
          },
        );
      },
    },
  ],
});
```

---

title: Adding a Specific Package
description: Shows how to use `bun add` to add a specific package as a dependency to the project. You can specify a version, version range, or tag when adding the package.
source: docs/install/index.md#_snippet_6

language: bash
code:
```
$ bun add preact
```

language: bash
code:
```
$ bun add zod@3.20.0
$ bun add zod@^3.0.0
$ bun add zod@latest
```

---

title: Adding a Package Globally
description: Shows how to use the `--global` or `-g` flag with `bun add` to install a package globally. Globally installed packages are available to all projects on the system and are typically command-line tools.
source: docs/install/index.md#_snippet_10

language: bash
code:
```
$ bun add --global cowsay # or `bun add -g cowsay`
$ cowsay "Bun!"
```

language: text
code:
```
 ______
< Bun! >
 ------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
```

---

title: Building for Production - Bash and TypeScript
description: Demonstrates how to create optimized production bundles using `bun build`. The first example uses the CLI to build `index.html`, minify the output, and specify the output directory. The second uses the API to specify the entrypoint, output directory, and minification options.
source: docs/bundler/html.md#_snippet_7

language: bash
code:
```
$ bun build ./index.html --minify --outdir=dist
```

language: ts
code:
```
Bun.build({
  entrypoints: ["./index.html"],
  outdir: "./dist",
  minify: {
    whitespace: true,
    identifiers: true,
    syntax: true,
  }
});
```

---

title: Importing JSON Files
description: Demonstrates how to directly import JSON files into a TypeScript/JavaScript module. The parsed JSON data is inlined into the bundle as a JavaScript object during the bundling process.
source: docs/bundler/loaders.md#_snippet_0

language: ts
code:
```
import pkg from "./package.json";
pkg.name; // => "my-package"
```

---

title: Importing TOML Files
description: Demonstrates how to directly import TOML files into a TypeScript/JavaScript module. The TOML data is parsed and inlined as a JavaScript object during bundling.
source: docs/bundler/loaders.md#_snippet_2

language: ts
code:
```
import config from "./bunfig.toml";
config.logLevel; // => "debug"

// via import attribute:
// import myCustomTOML from './my.config' with {type: "toml"};
```

---

title: Importing Text Files
description: Demonstrates how to import a text file and access its content as a string. The file's contents are read and inlined into the bundle as a JavaScript string.
source: docs/bundler/loaders.md#_snippet_4

language: ts
code:
```
import contents from "./file.txt";
console.log(contents); // => "Hello, world!"

// To import an html file as text
// The "type' attribute can be used to override the default loader.
import html from "./index.html" with { type: "text" };
```

---

title: Importing HTML Files
description: Illustrates how the HTML loader processes HTML files, bundling any referenced assets. It bundles and hashes JavaScript files, CSS files, and images, while preserving external URLs.
source: docs/bundler/loaders.md#_snippet_8

language: html
code:
```
<!DOCTYPE html>
<html>
  <body>
    <img src="./image.jpg" alt="Local image">
    <img src="https://example.com/image.jpg" alt="External image">
    <script type="module" src="./script.js"></script>
  </body>
</html>
```

---

title: Resulting Bundled HTML Assets
description: Illustrates the output of the HTML loader after bundling assets. The local image and script are hashed, while external URLs are preserved.
source: docs/bundler/loaders.md#_snippet_9

language: html
code:
```
<!DOCTYPE html>
<html>
  <body>
    <img src="./image-HASHED.jpg" alt="Local image">
    <img src="https://example.com/image.jpg" alt="External image">
    <script type="module" src="./output-ALSO-HASHED.js"></script>
  </body>
</html>
```

---

title: Providing TLS Key and Certificate Contents
description: Illustrates the different ways to provide the contents of the TLS key to `Bun.serve`. It supports passing a `BunFile`, a `Buffer`, a string, or an array of the preceding, which allows flexibility in how the TLS key is loaded. You must read the contents of your TLS key and certificate, _not a path to it_.
source: docs/api/http.md#_snippet_13

language: typescript
code:
```
Bun.serve({
  fetch() {},

  tls: {
    // BunFile
    key: Bun.file("./key.pem"),
    // Buffer
    key: fs.readFileSync("./key.pem"),
    // string
    key: fs.readFileSync("./key.pem", "utf8"),
    // array of above
    key: [Bun.file("./key1.pem"), Bun.file("./key2.pem")],
  },
});
```

---

title: Defining Server with Export Default Syntax - TypeScript
description: Illustrates an alternative syntax for defining a Bun server using `export default`. This approach exports a server configuration object that satisfies the `Serve` type, enabling hot reloading.
source: docs/api/http.md#_snippet_1

language: typescript
code:
```
import {type Serve} from "bun";

export default {
  fetch(req) {
    return new Response("Bun!");
  },
} satisfies Serve;
```

---

title: Setting Public Path with Bun Build
description: Demonstrates how to set the `publicPath` option in `Bun.build` to prefix all file paths with a specified value. This is useful when deploying assets to a CDN or a different domain.
source: docs/bundler/index.md#_snippet_0

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  publicPath: 'https://cdn.example.com/', // default is undefined
})
```

language: CLI
code:
```
$ bun build ./index.tsx --outdir ./out --public-path https://cdn.example.com/
```

language: Output
code:
```
- var logo = './logo-a7305bdef.svg';
+ var logo = 'https://cdn.example.com/logo-a7305bdef.svg';
```

---

title: Building with CommonJS Format
description: Demonstrates building a CommonJS module using both the JavaScript API and the CLI. Setting `format` to `cjs` allows Bun to transpile to the CommonJS format.  The default target changes from `browser` to `node` when using `cjs`.
source: docs/bundler/index.md#_snippet_1

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  format: "cjs",
})
```

language: CLI
code:
```
$ bun build ./index.tsx --outdir ./out --format cjs
```

---

title: Enabling Code Splitting
description: Demonstrates how to enable code splitting using both the JavaScript API and the CLI. Setting `splitting` to `true` allows the bundler to split shared code into separate chunks, improving caching and reducing initial load times.
source: docs/bundler/index.md#_snippet_4

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./entry-a.ts', './entry-b.ts'],
  outdir: './out',
  splitting: true,
})
```

language: CLI
code:
```
$ bun build ./entry-a.ts ./entry-b.ts --outdir ./out --splitting
```

---

title: Using Media Query Ranges - CSS
description: Demonstrates modern CSS media query range syntax using comparison operators, which is then converted to traditional `min-` and `max-` syntax by Bun's CSS bundler for broader browser compatibility. This allows developers to write more intuitive breakpoints while ensuring styles work across all browsers.
source: docs/bundler/css.md#_snippet_0

language: css
code:
```
/* Modern syntax with comparison operators */
@media (width >= 768px) {
  .container {
    max-width: 720px;
  }
}

/* Inclusive range using <= and >= */
@media (768px <= width <= 1199px) {
  .sidebar {
    display: flex;
  }
}

/* Exclusive range using < and > */
@media (width > 320px) and (width < 768px) {
  .mobile-only {
    display: block;
  }
}
```

language: css
code:
```
/* Converted to traditional min/max syntax */
@media (min-width: 768px) {
  .container {
    max-width: 720px;
  }
}

@media (min-width: 768px) and (max-width: 1199px) {
  .sidebar {
    display: flex;
  }
}

@media (min-width: 321px) and (max-width: 767px) {
  .mobile-only {
    display: block;
  }
}
```

---

title: Implementing CSS Shorthands
description: Illustrates the use of modern CSS shorthand properties for alignment, overflow, and text decoration, which are then converted to their longhand equivalents by Bun's CSS bundler for maximum browser compatibility. This ensures clean and maintainable stylesheets while providing broad support.
source: docs/bundler/css.md#_snippet_1

language: css
code:
```
/* Alignment shorthands */
.flex-container {
  /* Shorthand for align-items and justify-items */
  place-items: center start;

  /* Shorthand for align-content and justify-content */
  place-content: space-between center;
}

.grid-item {
  /* Shorthand for align-self and justify-self */
  place-self: end center;
}

/* Two-value overflow */
.content-box {
  /* First value for horizontal, second for vertical */
  overflow: hidden auto;
}

/* Enhanced text-decoration */
.fancy-link {
  /* Combines multiple text decoration properties */
  text-decoration: underline dotted blue 2px;
}

/* Two-value display syntax */
.component {
  /* Outer display type + inner display type */
  display: inline flex;
}
```

language: css
code:
```
.flex-container {
  /* Expanded alignment properties */
  align-items: center;
  justify-items: start;

  align-content: space-between;
  justify-content: center;
}

.grid-item {
  align-self: end;
  justify-self: center;
}

.content-box {
  /* Separate overflow properties */
  overflow-x: hidden;
  overflow-y: auto;
}

.fancy-link {
  /* Individual text decoration properties */
  text-decoration-line: underline;
  text-decoration-style: dotted;
  text-decoration-color: blue;
  text-decoration-thickness: 2px;
}

.component {
  /* Single value display */
  display: inline-flex;
}
```

---

title: Creating Double Position Gradients
description: Demonstrates how to create hard color stops in CSS gradients using the double position gradient syntax and how Bun's CSS bundler converts this to the traditional format for older browsers. This provides cleaner code while ensuring cross-browser compatibility.
source: docs/bundler/css.md#_snippet_2

language: css
code:
```
.striped-background {
  /* Creates a sharp transition from green to red at 30%-40% */
  background: linear-gradient(
    to right,
    yellow 0%,
    green 20%,
    green 30%,
    red 30%,
    /* Double position creates hard stop */ red 70%,
    blue 70%,
    blue 100%
  );
}

.progress-bar {
  /* Creates distinct color sections */
  background: linear-gradient(
    to right,
    #4caf50 0% 25%,
    /* Green from 0% to 25% */ #ffc107 25% 50%,
    /* Yellow from 25% to 50% */ #2196f3 50% 75%,
    /* Blue from 50% to 75% */ #9c27b0 75% 100% /* Purple from 75% to 100% */
  );
}
```

language: css
code:
```
.striped-background {
  background: linear-gradient(
    to right,
    yellow 0%,
    green 20%,
    green 30%,
    red 30%,
    /* Split into two color stops */ red 70%,
    blue 70%,
    blue 100%
  );
}

.progress-bar {
  background: linear-gradient(
    to right,
    #4caf50 0%,
    #4caf50 25%,
    /* Two stops for green section */ #ffc107 25%,
    #ffc107 50%,
    /* Two stops for yellow section */ #2196f3 50%,
    #2196f3 75%,
    /* Two stops for blue section */ #9c27b0 75%,
    #9c27b0 100% /* Two stops for purple section */
  );
}
```

---

title: Implementing System-Ui Font
description: Illustrates the use of the `system-ui` generic font family to utilize the device's native UI font, and how Bun's CSS bundler expands it to a comprehensive cross-platform font stack for older browsers. This ensures a native look and feel while maintaining broad compatibility.
source: docs/bundler/css.md#_snippet_3

language: css
code:
```
.native-interface {
  /* Use the system's default UI font */
  font-family: system-ui;
}

.fallback-aware {
  /* System UI font with explicit fallbacks */
  font-family: system-ui, sans-serif;
}
```

language: css
code:
```
.native-interface {
  /* Expanded to support all major platforms */
  font-family:
    system-ui,
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    "Noto Sans",
    Ubuntu,
    Cantarell,
    "Helvetica Neue";
}

.fallback-aware {
  /* Preserves the original fallback after the expanded stack */
  font-family:
    system-ui,
    -apple-system,
    BlinkMacSystemFont,
    "Segoe UI",
    Roboto,
    "Noto Sans",
    Ubuntu,
    Cantarell,
    "Helvetica Neue",
    sans-serif;
}
```

---

title: Logging CSS Modules
description: Demonstrates how CSS Modules transform locally scoped class names into unique identifiers and then logs to console. As you can see, the class names are unique to each file, avoiding any collisions!
source: docs/bundler/css.md#_snippet_5

language: tsx
code:
```
import styles from "./styles.module.css";
import otherStyles from "./other-styles.module.css";

console.log(styles);
console.log(otherStyles);
```

language: ts
code:
```
{
  button: "button_123";
}

{
  button: "button_456";
}
```

---

title: Composing CSS Selectors
description: Illustrates how to compose class selectors together to reuse style rules across multiple classes. The `composes` property must come before any regular CSS properties or declarations and you can only use `composes` on a simple selector with a single class name.
source: docs/bundler/css.md#_snippet_6

language: css
code:
```
/* styles.module.css */
.button {
  composes: background;
  color: red;
}

.background {
  background-color: blue;
}
```

language: css
code:
```
.button {
  background-color: blue;
  color: red;
}

.background {
  background-color: blue;
}
```

---

title: Composing From Separate Module File
description: Demonstrates composing from a separate CSS module file. This lets you reuse style rules across multiple classes from different files.
source: docs/bundler/css.md#_snippet_7

language: css
code:
```
/* background.module.css */
.background {
  background-color: blue;
}

/* styles.module.css */
.button {
  composes: background from "./background.module.css";
  color: red;
}
```

---

title: Transpiling CSS Nesting
description: Demonstrates how Bun transpiles CSS nesting syntax into traditional flat CSS for browser compatibility. This allows developers to write more concise stylesheets using nested selectors, which are then converted into a format that works across all browsers. The example shows nesting selectors and media queries.
source: docs/bundler/css.md#_snippet_0

language: css
code:
```
/* With nesting */
.card {
  background: white;
  border-radius: 4px;

  .title {
    font-size: 1.2rem;
    font-weight: bold;
  }

  .content {
    padding: 1rem;
  }
}

```

language: css
code:
```
/* Compiled output */
.card {
  background: white;
  border-radius: 4px;
}

.card .title {
  font-size: 1.2rem;
  font-weight: bold;
}

.card .content {
  padding: 1rem;
}

```

language: css
code:
```
.responsive-element {
  display: block;

  @media (min-width: 768px) {
    display: flex;
  }
}

```

---

title: Transpiling CSS Color Mix
description: Illustrates how Bun's CSS bundler evaluates `color-mix()` functions at build time to generate static color values for browser compatibility. This enables developers to blend colors dynamically within their stylesheets without needing preprocessors. The example mixes blue and red, and also creates a lighter variant for the hover state.
source: docs/bundler/css.md#_snippet_1

language: css
code:
```
.button {
  /* Mix blue and red in the RGB color space with a 30/70 proportion */
  background-color: color-mix(in srgb, blue 30%, red);

  /* Create a lighter variant for hover state */
  &:hover {
    background-color: color-mix(in srgb, blue 30%, red, white 20%);
  }
}

```

language: css
code:
```
.button {
  /* Computed to the exact resulting color */
  background-color: #b31a1a;
}

.button:hover {
  background-color: #c54747;
}

```

---

title: Transpiling CSS Relative Colors
description: Demonstrates how Bun's CSS bundler computes relative color modifications at build time to generate static color values for browser compatibility. This allows developers to modify individual color components like lightness or saturation using relative color syntax. The example creates an accent color with increased lightness and a desaturated blue.
source: docs/bundler/css.md#_snippet_2

language: css
code:
```
.theme-color {
  /* Start with a base color and increase lightness by 15% */
  --accent: lch(from purple calc(l + 15%) c h);

  /* Take our brand blue and make a desaturated version */
  --subtle-blue: oklch(from var(--brand-blue) l calc(c * 0.8) h);
}

```

language: css
code:
```
.theme-color {
  --accent: lch(69.32% 58.34 328.37);
  --subtle-blue: oklch(60.92% 0.112 240.01);
}

```

---

title: Transpiling CSS LAB Colors
description: Illustrates how Bun automatically converts modern CSS color formats like LAB and OKLCH to backwards-compatible alternatives for browsers that don't yet support them. This allows developers to use wider color gamuts and perceptual color spaces while ensuring optimal color rendering across all browsers. The example uses `lab` to define color and `oklch` for gradients.
source: docs/bundler/css.md#_snippet_3

language: css
code:
```
.vibrant-element {
  /* A vibrant red that exceeds sRGB gamut boundaries */
  color: lab(55% 78 35);

  /* A smooth gradient using perceptual color space */
  background: linear-gradient(
    to right,
    oklch(65% 0.25 10deg),
    oklch(65% 0.25 250deg)
  );
}

```

language: css
code:
```
.vibrant-element {
  /* Fallback to closest RGB approximation */
  color: #ff0f52;
  /* P3 fallback for browsers with wider gamut support */
  color: color(display-p3 1 0.12 0.37);
  /* Original value preserved for browsers that support it */
  color: lab(55% 78 35);

  background: linear-gradient(to right, #cd4e15, #3887ab);
  background: linear-gradient(
    to right,
    oklch(65% 0.25 10deg),
    oklch(65% 0.25 250deg)
  );
}

```

---

title: Transpiling CSS Color Function
description: Demonstrates how Bun provides RGB fallbacks for browsers that don't support advanced color functions like `color()` with `display-p3` or `a98-rgb`. This allows developers to specify colors in various predefined color spaces, expanding design options beyond the traditional RGB space, while ensuring compatibility across different browsers. The example shows defining colors using `display-p3` and `a98-rgb`.
source: docs/bundler/css.md#_snippet_4

language: css
code:
```
.vivid-element {
  /* Using the Display P3 color space for wider gamut colors */
  color: color(display-p3 1 0.1 0.3);

  /* Using A98 RGB color space */
  background-color: color(a98-rgb 0.44 0.5 0.37);
}

```

language: css
code:
```
.vivid-element {
  /* RGB fallback first for maximum compatibility */
  color: #fa1a4c;
  /* Keep original for browsers that support it */
  color: color(display-p3 1 0.1 0.3);

  background-color: #6a805d;
  background-color: color(a98-rgb 0.44 0.5 0.37);
}

```

---

title: Transpiling CSS HWB Colors
description: Illustrates how Bun's CSS bundler automatically converts HWB (Hue, Whiteness, Blackness) colors to RGB for compatibility with all browsers. This allows developers to use a more intuitive color model for creating color variations, especially for design systems. The example defines a primary color and creates light, dark, and muted variations using HWB.
source: docs/bundler/css.md#_snippet_5

language: css
code:
```
.easy-theming {
  /* Pure cyan with no white or black added */
  --primary: hwb(180 0% 0%);

  /* Same hue, but with 20% white added (tint) */
  --primary-light: hwb(180 20% 0%);

  /* Same hue, but with 30% black added (shade) */
  --primary-dark: hwb(180 0% 30%);

  /* Muted version with both white and black added */
  --primary-muted: hwb(180 30% 20%);
}

```

language: css
code:
```
.easy-theming {
  --primary: #00ffff;
  --primary-light: #33ffff;
  --primary-dark: #00b3b3;
  --primary-muted: #339999;
}

```

---

title: Transpiling Modern CSS Color Notation
description: Demonstrates how Bun automatically converts modern CSS color formats like space-separated RGB, hex with alpha, and simplified HSL notation to ensure compatibility with older browsers. This allows developers to write cleaner, more modern CSS while ensuring their styles work correctly across all browsers. The example showcases space-separated RGB, hex with alpha, and simplified HSL notation.
source: docs/bundler/css.md#_snippet_6

language: css
code:
```
.modern-styling {
  /* Space-separated RGB notation (no commas) */
  color: rgb(50 100 200);

  /* Space-separated RGB with alpha */
  border-color: rgba(100 50 200 / 75%);

  /* Hex with alpha channel (8 digits) */
  background-color: #00aaff80;

  /* HSL with simplified notation */
  box-shadow: 0 5px 10px hsl(200 50% 30% / 40%);
}

```

language: css
code:
```
.modern-styling {
  /* Converted to comma format for older browsers */
  color: rgb(50, 100, 200);

  /* Alpha channels handled appropriately */
  border-color: rgba(100, 50, 200, 0.75);

  /* Hex+alpha converted to rgba when needed */
  background-color: rgba(0, 170, 255, 0.5);

  box-shadow: 0 5px 10px rgba(38, 115, 153, 0.4);
}

```

---

title: Granularly Enabling Minifications with Bun Build
description: Illustrates how to enable specific minification options, such as whitespace, identifiers, and syntax minification, using both the JavaScript API and the command-line interface. This provides finer-grained control over the minification process.
source: docs/bundler/index.md#_snippet_1

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  minify: {
    whitespace: true,
    identifiers: true,
    syntax: true,
  },
})
```

language: bash
code:
```
$ bun build ./index.tsx --outdir ./out --minify-whitespace --minify-identifiers --minify-syntax
```

---

title: Creating Full-Stack Executables
description: Illustrates how Bun's `--compile` flag can bundle both server and client code into a single executable for full-stack applications.  Importing HTML files in the server code triggers bundling of frontend assets, and Bun automatically serves these assets with the correct MIME types.
source: docs/bundler/executables.md#_snippet_5

language: typescript
code:
```
import { serve } from "bun";
import index from "./index.html";

const server = serve({
  routes: {
    "/": index,
    "/api/hello": { GET: () => Response.json({ message: "Hello from API" }) },
  },
});

console.log(`Server running at http://localhost:${server.port}`);
```

language: html
code:
```
<!DOCTYPE html>
<html>
  <head>
    <title>My App</title>
    <link rel="stylesheet" href="./styles.css">
  </head>
  <body>
    <h1>Hello World</h1>
    <script src="./app.js"></script>
  </body>
</html>
```

language: javascript
code:
```
console.log("Hello from the client!");
```

---

title: Building Full-Stack Applications
description: Provides the command to build a full-stack application into a single executable using `bun build --compile`. This bundles server code, the Bun runtime, frontend assets (HTML, CSS, JavaScript), and npm packages, simplifying deployment.
source: docs/bundler/executables.md#_snippet_6

language: sh
code:
```
bun build --compile ./server.ts --outfile myapp
```

---

title: Defining Bun Module Types
description: Demonstrates how to define types and interfaces within the `bun` module using `declare module "bun"`. This allows for defining both types/interfaces and runtime values that can be consumed via imports or the global `Bun` object.
source: packages/bun-types/authoring.md#_snippet_0

language: typescript
code:
```
declare module "bun" {
  // Your types go here
  interface MyInterface {
    // ...
  }

  type MyType = string | number;

  function myFunction(): void;
}
```

---

title: Compiling Zig Object File - Bash
description: Compiles the `bun-zig.o` object file using CMake and Ninja. This process involves configuring the build environment with CMake, specifying the target CPU and Zig architectures, and then using Ninja to build the object file from the Zig source code.
source: docs/project/internals/build-process-for-ci.md#_snippet_1

language: sh
code:
```
BUN_REPO=/path/to/oven-sh/bun

cd tmp1

cmake $BUN_REPO \
  -G Ninja \
  -DCMAKE_BUILD_TYPE=Release \
  -DCPU_TARGET="native" \
  -DZIG_TARGET="native" \
  -DBUN_ZIG_OBJ_DIR="./build"

ninja ./build/bun-zig.o
# -> bun-zig.o
```

---

title: Compiling C++ Object Archive - Bash
description: Compiles a C++ object archive (`bun-cpp-objects.a`) using CMake and a custom compilation script. The CMake configuration sets up the build environment, and the `compile-cpp-only.sh` script likely handles the actual compilation of C++ source files into an archive.
source: docs/project/internals/build-process-for-ci.md#_snippet_2

language: sh
code:
```
cd tmp2

cmake $BUN_REPO \
  -G Ninja \
  -DCMAKE_BUILD_TYPE=Release \
  -DBUN_CPP_ONLY=1 \

bash compile-cpp-only.sh
# -> bun-cpp-objects.a
```

---

title: Linking Bun Executable - Bash
description: Links the Zig object file (`bun-zig.o`) and the C++ object archive (`bun-cpp-objects.a`) to create the final `bun` executable. This process uses CMake to configure the linker with the paths to the object files and then uses Ninja to perform the linking operation, generating the `bun` executable along with optional profiling and debugging files.
source: docs/project/internals/build-process-for-ci.md#_snippet_3

language: sh
code:
```
cd tmp3

cmake $BUN_REPO \
  -G Ninja \
  -DCMAKE_BUILD_TYPE=Release \
  -DBUN_LINK_ONLY=1 \
  -DBUN_ZIG_OBJ_DIR="/path/to/bun-zig-dir" \
  -DBUN_CPP_ARCHIVE="/path/to/bun-cpp-objects.a"

ninja

# optional:
#   -DBUN_DEPS_OUT_DIR=... custom deps dir, use this to cache the built deps between rebuilds
#   -DWEBKIT_DIR=... same thing, but it's probably fast enough to pull from github releases

# -> bun
# -> bun-profile
# -> bun.dSYM/
```

---

title: Defining a Non-HTTP Event Handler - TypeScript
description: Demonstrates how to create a Bun Lambda function that handles non-HTTP events such as S3, SQS, and EventBridge events. The example shows how to parse the event payload from the request body as JSON. This allows processing various event types within the Lambda function.
source: packages/bun-lambda/README.md#_snippet_2

language: ts
code:
```
export default {
  async fetch(request: Request): Promise<Response> {
    const event = await request.json();
    // ...
    return new Response();
  },
};
```

---

title: Building Bun Lambda Layer
description: Demonstrates building a Lambda layer for Bun using the `bun run build-layer` command.  This command allows specifying architecture, Bun release, and output path, offering control over the layer's configuration.
source: packages/bun-lambda/README.md#_snippet_5

language: sh
code:
```
bun run build-layer -- \
  --arch x64 \
  --release canary \
  --output /path/to/layer.zip
```

---

title: Bundling Svelte Components - Typescript
description: Shows how to use `bun-plugin-svelte` with `Bun.build` to bundle Svelte components. The example imports `SveltePlugin` and configures it within the `Bun.build` options, specifying the entry point, output directory, target environment, and development mode.
source: packages/bun-plugin-svelte/README.md#_snippet_3

language: typescript
code:
```
// build.ts
// to use: bun run build.ts
import { SveltePlugin } from "bun-plugin-svelte"; // NOTE: not published to npm yet

Bun.build({
  entrypoints: ["src/index.ts"],
  outdir: "dist",
  target: "browser",
  sourcemap: true, // sourcemaps not yet supported
  plugins: [
    SveltePlugin({
      development: true, // turn off for prod builds. Defaults to false
    }),
  ],
});
```

---

title: Ensuring Efficient HTTP Responses with Corking - C++
description: Demonstrates how to use `res->cork` to ensure efficient HTTP responses in uWebSockets. Wrapping sending function calls within `res->cork` combines multiple send operations (e.g., `res->writeStatus`, `res->writeHeader`, and `res->end`) into a single system call, reducing network overhead and improving performance.
source: packages/bun-uws/misc/READMORE.md#_snippet_0

language: c++
code:
```
res->cork([]() {
    res->end(
```

---

title: Bundling HTML with Script and Link Tags
description: Illustrates how Bun automatically bundles `<script>` and `<link>` tags within an HTML file when it's served as a route. This example shows an `index.html` file with CSS and JavaScript dependencies and the resulting bundled HTML with hashed filenames for cache-busting.
source: docs/bundler/fullstack.md#_snippet_2

language: html
code:
```
<!DOCTYPE html>
<html>
  <head>
    <title>Home</title>
    <link rel="stylesheet" href="./reset.css" />
    <link rel="stylesheet" href="./styles.css" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./sentry-and-preloads.ts"></script>
    <script type="module" src="./my-app.tsx"></script>
  </body>
</html>
```

language: html
code:
```
<!DOCTYPE html>
<html>
  <head>
    <title>Home</title>
    <link rel="stylesheet" href="/index-[hash].css" />
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/index-[hash].js"></script>
  </body>
</html>
```

---

title: Integrating React (Frontend) with Bun (Backend)
description: Demonstrates how to integrate a React frontend with a Bun backend. It shows how to import the `dashboard.html` file in the backend, serve it using `Bun.serve()`, and render a React component inside that HTML using `react-dom/client`.
source: docs/bundler/fullstack.md#_snippet_3

language: typescript
code:
```
import dashboard from "../public/dashboard.html";
import { serve } from "bun";

serve({
  routes: {
    "/": dashboard,
  },

  async fetch(req) {
    // ...api requests
    return new Response("hello world");
  },
});
```

language: typescript
code:
```
import "./styles.css";
import { createRoot } from "react-dom/client";
import { App } from "./app.tsx";

document.addEventListener("DOMContentLoaded", () => {
  const root = createRoot(document.getElementById("root"));
  root.render(<App />);
});
```

language: html
code:
```
<!DOCTYPE html>
<html>
  <head>
    <title>Dashboard</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="../src/frontend.tsx"></script>
  </body>
</html>
```

---

title: Sourcing vs-shellps1 - PowerShell
description: Illustrates how to source the `vs-shell.ps1` script in a PowerShell terminal. This script sets up the environment variables needed to use the Visual Studio compiler tools, ensuring the correct build environment.
source: docs/project/building-windows.md#_snippet_5

language: ps1
code:
```
> .\scripts\vs-shell.ps1
```

---

title: Verifying MSVC Command Line - PowerShell
description: Demonstrates how to verify that the MSVC command-line environment is correctly set up. Checks for the existence of `mt.exe` to confirm the Visual Studio tools are accessible in the current shell.
source: docs/project/building-windows.md#_snippet_6

language: ps1
code:
```
> Get-Command mt
```

---

title: Configuring Bundler with Yaml Plugin
description: Illustrates how to integrate the `bun-plugin-yaml` into Bun's bundler configuration.  It shows how to import the plugin and include it in the `plugins` array within the `Bun.build` options, enabling `.yaml` file processing during the bundling process.
source: packages/bun-plugin-yaml/README.md#_snippet_1

language: typescript
code:
```
import yamlPlugin from "bun-plugin-yaml";

await Bun.build({
  entrypoints: ["./index.tsx"],
  // other config

  plugins: [yamlPlugin()],
});
```

---

title: Implementing the onBeforeParse Hook - Rust
description: Illustrates how to define a Bun native plugin using the `bun_native_plugin::bun` proc macro and implement the `onBeforeParse` hook.  It shows how to access and modify source code using the `OnBeforeParse` API, replacing all occurrences of `foo` with `bar` and setting the `BunLoader` to `BUN_LOADER_JSX`.
source: packages/bun-native-plugin-rs/README.md#_snippet_1

language: rs
code:
```
use bun_native_plugin::{define_bun_plugin, OnBeforeParse, bun, Result, anyhow, BunLoader};
use napi_derive::napi;

/// Define the plugin and its name
define_bun_plugin!("replace-foo-with-bar");

/// Here we'll implement `onBeforeParse` with code that replaces all occurrences of
/// `foo` with `bar`.
///
/// We use the #[bun] macro to generate some of the boilerplate code.
///
/// The argument of the function (`handle: &mut OnBeforeParse`) tells
/// the macro that this function implements the `onBeforeParse` hook.
#[bun]
pub fn replace_foo_with_bar(handle: &mut OnBeforeParse) -> Result<()> {
  // Fetch the input source code.
  let input_source_code = handle.input_source_code()?;

  // Get the Loader for the file
  let loader = handle.output_loader();


  let output_source_code = input_source_code.replace("foo", "bar");

  handle.set_output_source_code(output_source_code, BunLoader::BUN_LOADER_JSX);

  Ok(())
}
```

---

title: Printing a Yarn Lockfile to Console
description: Demonstrates how to output a Yarn lockfile to the console without writing it to disk. Using `bun bun.lockb` transforms the binary `bun.lockb` format into a human-readable Yarn lockfile format.
source: docs/guides/install/yarnlock.md#_snippet_2

language: sh
code:
```
$ bun bun.lockb
```

---

title: Controlling SQLite Files with fileControl - TypeScript
description: Demonstrates how to use the advanced `sqlite3_file_control` API through the `.fileControl()` method on a `Database` instance. This example configures the database to prevent WAL (Write-Ahead Logging) files from persisting after the database is closed. This is useful to ensure no lingering WAL files exist after the database connection is closed.
source: docs/api/sqlite.md#_snippet_1

language: typescript
code:
```
import { Database, constants } from "bun:sqlite";

const db = new Database();
// Ensure WAL mode is NOT persistent
// this prevents wal files from lingering after the database is closed
db.fileControl(constants.SQLITE_FCNTL_PERSIST_WAL, 0);
```

---

title: Resetting the Expo Project
description: Details how to reset an Expo project to a blank state using `npm run reset-project`. This command moves the existing starter code to the `app-example` directory and creates an empty `app` directory, allowing developers to begin with a clean slate.
source: test/integration/expo-app/README.md#_snippet_2

language: bash
code:
```
npm run reset-project
```

---

title: Adding Regression Tests - TypeScript
description: Demonstrates how to add a regression test to the `test/regression/` directory. This ensures that a previously fixed bug does not reappear in future versions.
source: test/README.md#_snippet_2

language: ts
code:
```
// test/regression/issue/02005.test.ts

import { it, expect } from "bun:test";

it("regex literal should work with non-latin1", () => {
  const text = "è¿™æ˜¯ä¸€æ®µè¦æ›¿æ¢çš„æ–‡å­—";
  expect(text.replace(new RegExp("è¦æ›¿æ¢"), "")).toBe("è¿™æ˜¯ä¸€æ®µçš„æ–‡å­—");
  expect(text.replace(/è¦æ›¿æ¢/, "")).toBe("è¿™æ˜¯ä¸€æ®µçš„æ–‡å­—");
});
```

---

title: Upgrading Bun
description: Shows how to upgrade Bun to the latest version using the `bun upgrade` command. Also illustrates how to upgrade to the latest canary build using the `--canary` flag, providing access to the newest features and bug fixes.
source: README.md#_snippet_3

language: sh
code:
```
bun upgrade
```

language: sh
code:
```
bun upgrade --canary
```

---

title: Displaying Certificate Text
description: Illustrates displaying the contents of the newly created certificate using `openssl`. This allows verification of the certificate's attributes.
source: test/js/node/test/fixtures/0-dns/README.md#_snippet_4

language: console
code:
```
$ openssl x509 -text -in 0-dns-cert.pem
(You can not see evil.example.com in subjectAltName field)
```

---

title: Preventing Object Mutation Deeply
description: Demonstrates how to use `mustNotMutateObjectDeep` to prevent mutation of an object, including nested objects. It wraps the target object with a proxy that throws an `AssertionError` on any mutation attempt, useful for regression tests to ensure immutability.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_0

language: javascript
code:
```
import { open } from 'node:fs/promises';
import { mustNotMutateObjectDeep } from '../common/index.mjs';

const _mutableOptions = { length: 4, position: 8 };
const options = mustNotMutateObjectDeep(_mutableOptions);

// In filehandle.read or filehandle.write, attempt to mutate options will throw
// In the test code, options can still be mutated via _mutableOptions
const fh = await open('/path/to/file', 'r+');
const { buffer } = await fh.read(options);
_mutableOptions.position = 4;
await fh.write(buffer, options);

// Inline usage
const stats = await fh.stat(mustNotMutateObjectDeep({ bigint: true }));
console.log(stats.size);
```

---

title: Implementing a Countdown Mechanism
description: Illustrates how to use the `Countdown` module for tests that require an action to be taken after a specific number of tasks are completed.  The countdown will fail if the remainder did not reach zero.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_3

language: javascript
code:
```
const Countdown = require('../common/countdown');

function doSomething() {
  console.log('.');
}

const countdown = new Countdown(2, doSomething);
countdown.dec();
countdown.dec();
```

---

title: Creating Http2 Settings Frame
description: Demonstrates the creation of a `http2.SettingsFrame` with an optional `ack` parameter to indicate whether to set the ACK flag. The resulting frame's data is then written to a socket.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_0

language: js
code:
```
// ack is a boolean indicating whether or not to set the ACK flag.
const frame = new http2.SettingsFrame(ack);

socket.write(frame.data);
```

---

title: Creating Http2 Headers Frame With Fake Request Headers
description: Illustrates how to create a `http2.HeadersFrame` using `http2.kFakeRequestHeaders` as the payload.  This simulates a minimal set of serialized HTTP/2 request headers and writes the frame's data to a socket.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_1

language: js
code:
```
const frame = new http2.HeadersFrame(1, http2.kFakeRequestHeaders, 0, true);

socket.write(frame.data);
```

---

title: Creating Http2 Headers Frame With Fake Response Headers
description: Demonstrates how to create a `http2.HeadersFrame` using `http2.kFakeResponseHeaders` as the payload.  This simulates a minimal set of serialized HTTP/2 response headers and writes the frame's data to a socket.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_2

language: js
code:
```
const frame = new http2.HeadersFrame(1, http2.kFakeResponseHeaders, 0, true);

socket.write(frame.data);
```

---

title: Requiring HTTP/2 module
description: Illustrates how to import the `http2` module from `../common/http2`. This module provides utilities for creating mock HTTP/2 frames for testing HTTP/2 endpoints.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_2

language: js
code:
```
const http2 = require('../common/http2');
```

---

title: Creating a Frame instance
description: Demonstrates how to create an instance of the `http2.Frame` class.  The code shows how to construct a basic HTTP/2 frame by providing length, type, flags, and id, and then write it to a socket for communication.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_3

language: js
code:
```
// length is a 24-bit unsigned integer
// type is an 8-bit unsigned integer identifying the frame type
// flags is an 8-bit unsigned integer containing the flag bits
// id is the 32-bit stream identifier, if any.
const frame = new http2.Frame(length, type, flags, id);

// Write the frame data to a socket
socket.write(frame.data);
```

---

title: Creating a HeadersFrame instance
description: Demonstrates how to create an instance of the `http2.HeadersFrame` class, a subclass of `http2.Frame` used to serialize a `HEADERS` frame. The code shows how to construct the headers frame by providing the stream id, the payload, the padding length, and the final flag. The frame is then written to the socket.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_4

language: js
code:
```
// id is the 32-bit stream identifier
// payload is a Buffer containing the HEADERS payload (see either
// http2.kFakeRequestHeaders or http2.kFakeResponseHeaders).
// padlen is an 8-bit integer giving the number of padding bytes to include
// final is a boolean indicating whether the End-of-stream flag should be set,
// defaults to false.
const frame = new http2.HeadersFrame(id, payload, padlen, final);

socket.write(frame.data);
```

---

title: Testing for Errors - TypeScript
description: Illustrates how to check exit codes and test error scenarios in Bun tests. It shows how to use `Bun.spawn` to execute a command and verify its exit code, and how to use `toThrow` for synchronous error assertions.
source: test/AGENTS.md#_snippet_5

language: typescript
code:
```
test("handles errors", async () => {
  await using proc = Bun.spawn({
    cmd: [bunExe(), "run", "invalid.js"],
    env: bunEnv,
  });

  const exitCode = await proc.exited;
  expect(exitCode).not.toBe(0);

  // For synchronous errors
  expect(() => someFunction()).toThrow("Expected error message");
});
```

---

title: Using Temporary Directories with Files - TypeScript
description: Illustrates how to create a temporary directory with pre-populated files using the `tempDirWithFiles` function from the `harness` module.  This simplifies test setup by providing a clean, isolated environment with necessary files. The code reads and asserts the content of the created file.
source: test/CLAUDE.md#_snippet_3

language: typescript
code:
```
import { tempDirWithFiles } from "harness";
import path from "node:path";

test("creates a temporary directory with files", () => {
  const dir = tempDirWithFiles("my-test-prefix", {
    "file.txt": "Hello, world!",
  });

  expect(await Bun.file(path.join(dir.path, "file.txt")).text()).toBe(
    "Hello, world!",
  );
});
```

---

title: Testing for Errors - TypeScript
description: Demonstrates how to test for error conditions in Bun.  It illustrates how to check the exit code of a spawned process using `Bun.spawn` and how to verify that a synchronous function throws an expected error using `expect(() => someFunction()).toThrow()`.  The tests ensure that the application handles errors gracefully.
source: test/CLAUDE.md#_snippet_5

language: typescript
code:
```
test("handles errors", async () => {
  await using proc = Bun.spawn({
    cmd: [bunExe(), "run", "invalid.js"],
    env: bunEnv,
  });

  const exitCode = await proc.exited;
  expect(exitCode).not.toBe(0);

  // For synchronous errors
  expect(() => someFunction()).toThrow("Expected error message");
});
```

---

title: Using Inspect with Custom Styling
description: Illustrates how to customize the output of `inspect` by providing a `stylize` function. The example defines a `stylizeWithHTML` function that wraps strings with HTML span tags based on the style type, allowing for custom styling of the inspected object.
source: src/js/internal/util/README.md#_snippet_0

language: js
code:
```
inspect(
  { a: 1 },
  {
    compact: false,
    stylize: stylizeWithHTML,
  }
);
```

language: html
code:
```
{ a: <span style="color:yellow;">1</span> }
```

---

title: Defining Custom HTML Styling for Inspect
description: Defines a custom `stylizeWithHTML` function for use with `inspect`. This function takes a string and a style type, and wraps the string in an HTML `span` tag with a color style corresponding to the provided style type. This allows for HTML-based styling of `inspect` output.
source: src/js/internal/util/README.md#_snippet_1

language: js
code:
```
function stylizeWithHTML(str, styleType) {
  const style = inspect.styles[styleType];
  if (style !== undefined) {
    return `<span style="color:${style};">${str}</span>`;
  }
  return str;
}
```

---

title: Using Private Property Names and Intrinsics
description: Demonstrates how to access private property names and JavaScriptCore (JSC) intrinsics using the `$` prefix. This prefix allows accessing private versions of globals and prototype values, which are typically inaccessible, offering a way to interact with internal engine mechanisms. The `$` prefix gets transpiled to `@` during the build process.
source: src/js/README.md#_snippet_0

language: ts
code:
```
// Many globals have private versions which are impossible for the user to
// tamper with. Though, these global variables are auto-prefixed by the bundler.
const hello = $Array.from(...);

// Similar situation with prototype values. These aren't autoprefixed since it depends on type.
something.$then(...);
map.$set(...);

// Internal variables we define
$requireMap.$has("elysia");

// JSC engine intrinsics. These usually translate directly to bytecode instructions.
const arr = $newArrayWithSize(5);
// A side effect of this is that using an intrinsic incorrectly like
// this will fail to parse and cause a segfault.
console.log($getInternalField)
```

---

title: Defining Builtin Functions for C++ Integration
description: Demonstrates how to define isolated functions in `./functions` that can be accessed from C++ code using `<file><function>CodeGenerator(vm)`. Each function is bundled separately, meaning you cannot use global variables, non-type imports, or directly reference other functions in these files.
source: src/js/README.md#_snippet_2

language: c
code:
```
object->putDirectBuiltinFunction(
  vm,
  globalObject,
  identifier,
  // ReadableStream.ts, `function readableStreamToJSON()`
  // This returns a FunctionExecutable* (extends JSCell*, but not JSFunction*).
  readableStreamReadableStreamToJSONCodeGenerator(vm),
  JSC::PropertyAttribute::DontDelete | 0
);
```

---

title: Serving HTML with Bun
description: Illustrates how to serve HTML content using `Bun.serve()`, including defining routes and handling API requests. The example also shows optional WebSocket support with `open`, `message`, and `close` handlers.
source: src/init/rule.md#_snippet_1

language: typescript
code:
```
import index from "./index.html"

Bun.serve({
  routes: {
    "/": index,
    "/api/users/:id": {
      GET: (req) => {
        return new Response(JSON.stringify({ id: req.params.id }));
      },
    },
  },
  // optional websocket support
  websocket: {
    open: (ws) => {
      ws.send("Hello, world!");
    },
    message: (ws, message) => {
      ws.send(message);
    },
    close: (ws) => {
      // handle close
    }
  },
  development: {
    hmr: true,
    console: true,
  }
})
```

---

title: Importing and Bundling with HTML - Bun
description: Demonstrates how HTML files can import `.tsx`, `.jsx`, or `.js` files, leveraging Bun's bundler for transpilation and bundling. It shows importing a `frontend.tsx` file, which allows React components to be used directly in HTML.
source: src/init/rule.md#_snippet_2

language: html
code:
```
<html>
  <body>
    <h1>Hello, world!</h1>
    <script type="module" src="./frontend.tsx"></script>
  </body>
</html>
```

---

title: Building React Components - Bun
description: Illustrates building a React component (`Frontend`) and rendering it into the document body using `react-dom/client`. It imports a CSS file directly, which Bun will bundle, showing how styles can be included in React components.
source: src/init/rule.md#_snippet_3

language: tsx
code:
```
import React from "react";

// import .css files directly and it works
import './index.css';

import { createRoot } from "react-dom/client";

const root = createRoot(document.body);

export default function Frontend() {
  return <h1>Hello, world!</h1>;
}

root.render(<Frontend />);
```

---

title: Configuring Compiler Options for Bun Projects
description: Illustrates recommended `compilerOptions` for a Bun project's `tsconfig.json` file. These options enable features like top-level await, JSX, and extensioned `.ts` imports, which are supported by Bun but not enabled by default in standard TypeScript configurations. This prevents compiler warnings when using Bun-specific features.
source: docs/typescript.md#_snippet_1

language: jsonc
code:
```
{
  "compilerOptions": {
    // Environment setup & latest features
    "lib": ["ESNext"],
    "target": "ESNext",
    "module": "Preserve",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,

    // Bundler mode
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,

    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true,

    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false,
  },
}
```

---

title: Stripping Exports - JavaScript
description: Demonstrates removing `export` keywords from function and variable declarations during bundling, which is essential when modules are treated as internal components of a larger bundle. The `default` export is converted to a `var` declaration.
source: src/bundler/linker_context/README.md#_snippet_0

language: javascript
code:
```
// Input (when bundling):
export function greet() { return 'hello'; }
export const name = 'world';
export default 42;

// Output (exports removed since internal to bundle):
function greet() { return 'hello'; }
const name = 'world';
var default = 42;
```

---

title: Handling CommonJS Module Wrappers - JavaScript
description: Demonstrates the generated structure for CommonJS module wrappers. The code illustrates how the original module code is wrapped within a `__commonJS` function, providing an isolated scope and how `exports` is used to expose module functionalities. External imports are hoisted to the top-level scope.
source: src/bundler/linker_context/README.md#_snippet_3

language: javascript
code:
```
// Generated wrapper structure:
var require_moduleName = __commonJS((exports, module) => {
  // Original module code here with isolated scope
  exports.foo = 123;
});
```

---

title: Handling ESM Module Wrappers - JavaScript
description: Demonstrates the generated structure for ESM module wrappers.  The code shows how variables are hoisted outside the wrapper using `__export` and `__esm`, avoiding scope isolation and how an `init_moduleName` function is used to initialize the module.
source: src/bundler/linker_context/README.md#_snippet_4

language: javascript
code:
```
// Generated wrapper structure:
var moduleName_exports = {};
__export(moduleName_exports, { foo: () => foo });
let init_moduleName = __esm(() => {
  // Original module code here - variables are hoisted outside
  foo = 123;
});
```

---

title: Defining Global Variables in Test Files
description: Shows how to define global variables within a test file using `globalThis`. This enables the test to define functions or variables that are not present in the original scope of the bundled code, such as defining a `foo()` function within `/test.js` which is then referenced in the bundled `/entry.js`.
source: test/bundler/expectBundled.md#_snippet_3

language: typescript
code:
```
itBundled("default/MinifiedBundleEndingWithImportantSemicolon", {
  files: {
    // foo() is not defined in this scope
    "/entry.js": `while(foo()); // This semicolon must not be stripped`,

    "/test.js": /* js */ `
      let i = 0;
      // let's define foo()
      globalThis.foo = () => {
        console.log(i++);
        return i === 1;
      };
      await import('./out.js')
    `,
  },
  minifyWhitespace: true,
  format: "iife",
  run: {
    file: "/test.js",
    stdout: "0\n1",
  },
});
```

---

title: Resolving Relative Paths With Bun File - TypeScript
description: Illustrates how `Bun.file()` resolves relative paths. Relative paths are resolved relative to the project root, which is the nearest directory containing a `package.json` file.
source: docs/guides/read-file/string.md#_snippet_1

language: typescript
code:
```
const path = "./file.txt";
const file = Bun.file(path);
```

---

title: Commenting in Bun Flavored TOML
description: Illustrates how comments can be added using `#` or `;` in Bun-flavored TOML, matching the behavior of INI files. This allows for more flexible commenting styles compared to standard TOML.
source: docs/bun-flavored-toml.md#_snippet_0

language: ini
code:
```
# This is a comment
; This is also a comment
```

---

title: Generating Chunks in Parallel
description: Details the parallel processing used to generate final output files from chunks. The process includes symbol renaming, source map processing, CSS preparation, and JavaScript/CSS/HTML code generation. The chunks are finalized with cross-chunk imports/exports.
source: src/bundler/linker_context/README.md#_snippet_2

---

title: Cascading Module Wrapping
description: Illustrates how module wrapping cascades through the dependency chain.  If a module imports a CommonJS module, all modules that import the wrapped module are also wrapped to maintain compatibility.
source: src/bundler/linker_context/README.md#_snippet_6

language: javascript
code:
```
// File hierarchy:
// entry.js â†’ utils.js â†’ legacy.cjs

// legacy.cjs (CommonJS module)
exports.helper = function () {
  return "help";
};

// utils.js (imports CommonJS)
import { helper } from "./legacy.cjs"; // Forces utils.js to be wrapped

// entry.js (imports wrapped module)
import { helper } from "./utils.js"; // Forces entry.js to be wrapped

// Result: All three files get wrapper functions to maintain compatibility
```

---

title: Iterating Over Stream Chunks Using Async Iteration - TypeScript
description: Illustrates how to consume the chunks of a `ReadableStream` as an [async iterable](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_async_iterator_and_async_iterable_protocols) using `for await`. Each `chunk` represents a `Uint8Array` of the file's contents, allowing developers to process the stream incrementally.
source: docs/guides/read-file/stream.md#_snippet_1

language: typescript
code:
```
for await (const chunk of stream) {
  chunk; // => Uint8Array
}
```

---

title: Defining Stream Results - Zig
description: Defines the `streams.Result` union in Zig, a universal data-carrying type for native stream reads. It specifies variants like `owned`, `temporary`, `owned_and_done`, `temporary_and_done`, `into_array`, and `pending`, which signal data ownership, zero-copy reads, end-of-stream, BYOB writes, and asynchronous operations, respectively. These variants are crucial signals from the source to the sink.
source: src/bun.js/STREAMS.md#_snippet_0

language: zig
code:
```
  - `owned: bun.ByteList`: Represents a heap-allocated buffer. The receiver is now responsible for freeing this memory. This is used when data must outlive the current scope.
  - `temporary: bun.ByteList`: A borrowed, read-only view into a source's internal buffer. This is the key to **zero-copy reads**, as the sink can process the data without taking ownership or performing a copy. It is only valid for the duration of the function call.
  - `owned_and_done` / `temporary_and_done`: These variants bundle the final data chunk with the end-of-stream signal. This is a critical latency optimization, as it collapses two distinct events (data and close) into one, saving an I/O round trip.
  - `into_array`: Used for BYOB (Bring-Your-Own-Buffer) readers. It contains a handle to the JS-provided `ArrayBufferView` (`value: JSValue`) and the number of bytes written (`len`). This confirms a zero-copy write directly into JS-managed memory.
  - `pending: *Pending`: A handle to a future/promise, used to signal that the result is not yet available and the operation should be suspended.
```

---

title: Implementing Native Signals - Zig
description: Defines the `streams.Signal` v-table in Zig, which provides a type-erased interface for backpressure communication between native stream components. The `start`, `ready`, and `close` methods decouple source and sink implementations, enabling any native source to connect to any native sink without direct knowledge of their types. This is essential for the Direct Path optimization.
source: src/bun.js/STREAMS.md#_snippet_1

language: zig
code:
```
  - **`start()`**: Tells the source to begin producing data.
  - **`ready()`**: The sink calls this to signal it has processed data and is ready for more, effectively managing backpressure.
  - **`close()`**: The sink calls this to tell the source to stop, either due to completion or an error.
    This v-table decouples native components, allowing any native source to be connected to any native sink without direct knowledge of each other's concrete types, which is essential for the Direct Path optimization.
```

---

title: Buffering Body Values Natively - Zig
description: Describes how `Body.ValueBufferer` in `Body.zig` efficiently collects all chunks into a single native buffer when a consuming method like `.text()` is called on a body. It details the instantiation with an `onFinishedBuffering` callback, native piping using `onStreamPipe`, and completion when an `_and_done` flag is received, minimizing overhead by concatenating data chunks in native memory without crossing the JS boundary repeatedly.
source: src/bun.js/STREAMS.md#_snippet_4

language: zig
code:
```
- **Instantiation:** A `Body.ValueBufferer` is created with a callback, `onFinishedBuffering`, which will be invoked upon completion to resolve the original JS promise.
- **Native Piping (`onStreamPipe`):** For a `ByteStream` source, the bufferer sets itself as the `pipe` destination. The `ByteStream.onData` method, instead of interacting with JavaScript, now directly calls the bufferer's `onStreamPipe` function. This function appends the received `streams.Result` slice to its internal `stream_buffer`. The entire collection loop happens natively.
- **Completion:** When a chunk with the `_and_done` flag is received, `onStreamPipe` calls the `onFinishedBuffering` callback, passing the final, fully concatenated buffer. This callback then resolves the original JavaScript promise.
```

---

title: Optimizing Memory and Strings - Zig
description: Explains several memory and string optimizations in Bun, including the use of `Blob` and `Blob.Store` to manage different backing stores (memory, file, S3), zero-copy views with `blob.slice()`, the `is_all_ascii` flag to skip UTF-8 validation, and `WTFStringImpl` integration to avoid copying JS strings until necessary.
source: src/bun.js/STREAMS.md#_snippet_5

language: zig
code:
```
- **`Blob` and `Blob.Store` (`Blob.zig`):** A `Blob` is a lightweight handle to a `Blob.Store`. The store can be backed by memory (`.bytes`), a file (`.file`), or an S3 object (`.s3`). This allows Bun to implement optimized operations based on the blob's backing store (e.g., `Bun.write(file1, file2)` becomes a native file copy via `copy_file.zig`).
- **`Blob.slice()` as a Zero-Copy View:** `blob.slice()` is a constant-time operation that creates a new `Blob` handle pointing to the same store but with a different `offset` and `size`, avoiding any data duplication.
- **`is_all_ascii` Flag:** `Blob`s and `ByteStream`s track whether their content is known to be pure ASCII. This allows `.text()` to skip expensive UTF-8 validation and decoding for a large class of text-based data, treating the Latin-1 bytes directly as a string.
- **`WTFStringImpl` Integration:** Bun avoids copying JS strings by default, instead storing a pointer to WebKit's internal `WTF::StringImpl` (`Body.Value.WTFStringImpl`). The conversion to a UTF-8 byte buffer is deferred until it's absolutely necessary (e.g., writing to a socket), avoiding copies for string-based operations that might never touch the network.
```

---

title: Accessing ArrayBuffer Content as Int8Array
description: Illustrates how to access the binary content of an `ArrayBuffer` as a typed array, specifically an `Int8Array`. This allows for reading and manipulating the raw bytes of the file, such as accessing specific bytes or determining the length of the buffer.
source: docs/guides/read-file/arraybuffer.md#_snippet_1

language: typescript
code:
```
const buffer = await file.arrayBuffer();
const bytes = new Int8Array(buffer);

bytes[0];
bytes.length;
```

---

title: Preparing CSS ASTs for Chunking- Zig
description: Demonstrates the steps involved in preparing CSS ASTs for chunking within the `prepareCssAstsForChunk.zig` file. This includes CSS rule deduplication, optimization passes, and asset reference resolution.
source: src/bundler/linker_context/README.md#_snippet_1

language: text
code:
```
### Post-Processing Phase

#### `prepareCssAstsForChunk.zig`

**Purpose**: Prepares CSS ASTs before final processing.

**Key functions**:

- CSS rule deduplication
- CSS optimization passes
- Asset reference resolution
```

---

title: Post-Processing JavaScript Chunks- Zig
description: Illustrates the final processing steps applied to JavaScript chunks in `postProcessJSChunk.zig`. This involves cross-chunk binding code generation, final minification passes, source map integration, and output formatting.
source: src/bundler/linker_context/README.md#_snippet_2

language: text
code:
```
#### `postProcessJSChunk.zig`

**Purpose**: Final processing of JavaScript chunks after code generation.

**Key functions**:

- Cross-chunk binding code generation
- Final minification passes
- Source map integration
- Output formatting
```

---

title: Post-Processing CSS Chunks- Zig
description: Details the final processing steps for CSS chunks within `postProcessCSSChunk.zig`. This includes CSS rule optimization, asset URL finalization, CSS minification, and source map generation.
source: src/bundler/linker_context/README.md#_snippet_3

language: text
code:
```
#### `postProcessCSSChunk.zig`

**Purpose**: Final processing of CSS chunks.

**Key functions**:

- CSS rule optimization
- Asset URL finalization
- CSS minification
- Source map generation
```

---

title: Post-Processing HTML Chunks- Zig
description: Describes the final processing steps for HTML chunks in `postProcessHTMLChunk.zig`. This includes HTML optimization, asset reference injection, script/stylesheet linking, and HTML minification.
source: src/bundler/linker_context/README.md#_snippet_4

language: text
code:
```
#### `postProcessHTMLChunk.zig`

**Purpose**: Final processing of HTML chunks.

**Key functions**:

- HTML optimization
- Asset reference injection
- Script/stylesheet linking
- HTML minification
```

---

title: Writing Output Files to Disk- Zig
description: Demonstrates writing the generated chunks and assets to the filesystem using `writeOutputFilesToDisk.zig`. This includes file system operations, directory creation, chunk serialization, source map file generation, and asset copying.
source: src/bundler/linker_context/README.md#_snippet_5

language: text
code:
```
#### `writeOutputFilesToDisk.zig`

**Purpose**: Writes all generated chunks and assets to the filesystem.

**Key functions**:

- File system operations
- Directory creation
- Chunk serialization
- Source map file generation
- Asset copying
```

---

title: Using Figlet in Bun Serve - API Integration
description: Illustrates how to integrate the `figlet` package into a `Bun.serve` handler to generate ASCII art. The example installs `figlet` and `@types/figlet`, imports the `figlet` library, and then uses the `figlet.textSync` method to create an ASCII art banner that is returned as the HTTP response body.
source: docs/quickstart.md#_snippet_4

language: bash
code:
```
$ bun add figlet
$ bun add -d @types/figlet # TypeScript users only
```

language: typescript
code:
```
+ import figlet from "figlet";

  const server = Bun.serve({
    port: 3000,
    fetch(req) {
+     const body = figlet.textSync("Bun!");
+     return new Response(body);
-     return new Response("Bun!");
    },
  });
```

---

title: Verifying Skipped Test in Bun Test Output - Shell
description: Illustrates the terminal output when running `bun test` with a skipped test. The output shows the number of passed and skipped tests. This confirms that the `test.skip` function prevents the test from running, providing clear feedback in the test results.
source: docs/guides/test/skip-tests.md#_snippet_1

language: shell
code:
```
$ bun test

test.test.ts:
âœ“ add [0.03ms]
âœ“ multiply [0.02ms]
Â» unimplemented feature

 2 pass
 1 skip
 0 fail
 2 expect() calls
Ran 3 tests across 1 files. [74.00ms]
```

---

title: Reading Standard Input
description: Demonstrates how to read data from standard input using Bun.js. The code iterates over lines received from `stdin` via `console`, logging each line to the console. This is useful for processing piped data or interactive command-line input.
source: docs/benchmarks.md#_snippet_2

language: typescript
code:
```
for await (const line of console) {
  // line of text from stdin
  console.log(line);
}
```

---

title: Writing Files Using Blobs
description: Demonstrates how to write a file using a `Blob` in Bun.js, leveraging optimized system calls. The code reads `input.txt` into a `Blob` using `Bun.file()` and then writes the `Blob` to `output.txt` using `Bun.write()`. On Linux, this utilizes the `copy_file_range` syscall, and on macOS, it becomes `clonefile` for improved performance.
source: docs/benchmarks.md#_snippet_5

language: javascript
code:
```
const blob = Bun.file("input.txt");
await Bun.write("output.txt", blob);
```

---

title: Stopping File System Watcher on Signal Interrupt
description: Illustrates how to properly close the file system watcher using `watcher.close()` when the process receives a `SIGINT` signal (e.g., when the user presses Ctrl-C). This ensures that the watcher is closed gracefully, preventing resource leaks and allowing the program to exit cleanly.
source: docs/guides/read-file/watch.md#_snippet_3

language: ts
code:
```
import { watch } from "fs";

const watcher = watch(import.meta.dir, (event, filename) => {
  console.log(`Detected ${event} in ${filename}`);
});

process.on("SIGINT", () => {
  // close watcher when Ctrl-C is pressed
  console.log("Closing watcher...");
  watcher.close();

  process.exit(0);
});
```

---

title: Installing GC Listener for Target Object
description: Demonstrates the usage of `async_hooks` to install a garbage collection listener for a target object. This enables `async_hooks` tracking, which may affect test functionality and introduces a `setImmediate()` invocation between `global.gc()` and listener invocation.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_0

language: javascript
code:
```
### `onGC(target, listener)`

* `target` [\[<Object>\]][<Object>]
* `listener` [\[<Object>\]][<Object>]
  * `ongc` [\[<Function>\]][<Function>]

Installs a GC listener for the collection of `target`.

This uses `async_hooks` for GC tracking. This means that it enables
`async_hooks` tracking, which may affect the test functionality. It also
means that between a `global.gc()` call and the listener being invoked
a full `setImmediate()` invocation passes.

`listener` is an object to make it easier to use a closure; the target object
should not be in scope when `listener.ongc()` is created.
```

---

title: Finding Diagnostic Reports
description: Demonstrates the use of the `findReports` function to retrieve diagnostic report file names from a specified directory. The files returned should have been generated by a process with a PID matching the provided `pid` argument.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_2

language: javascript
code:
```
### `findReports(pid, dir)`

* `pid` [\[<number>\]][<number>] Process ID to retrieve diagnostic report files
  for.
* `dir` [\[<string>\]][<string>] Directory to search for diagnostic report files.
* return [\[<Array>\]][<Array>]

Returns an array of diagnostic report file names found in `dir`. The files
should have been generated by a process whose PID matches `pid`.
```

---

title: Validating Diagnostic Report File Schema
description: Illustrates how to validate the schema of a diagnostic report using the `validate` function. The function takes the filepath of the diagnostic report as input and throws an exception if the report fails validation.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_3

language: javascript
code:
```
### `validate(filepath)`

* `filepath` [\[<string>\]][<string>] Diagnostic report filepath to validate.

Validates the schema of a diagnostic report file whose path is specified in
`filepath`. If the report fails validation, an exception is thrown.
```

---

title: Validating Diagnostic Report Content
description: Demonstrates how to validate the schema of a diagnostic report using the `validateContent` function. The function accepts either the JSON contents of a report or the parsed JavaScript object and throws an exception if the report fails validation.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_4

language: javascript
code:
```
### `validateContent(report)`

* `report` [\[<Object>\]][<Object>] | [\[<string>\]][<string>] JSON contents of a
  diagnostic report file, the parsed Object thereof, or the result of
  `process.report.getReport()`.

Validates the schema of a diagnostic report whose content is specified in
`report`. If the report fails validation, an exception is thrown.
```

---

title: Generating a Single Executable Application
description: Describes how to use `generateSEA` to create a single executable application by copying a source executable to a target executable, injecting a SEA blob using `postject`, and signing the resulting executable if necessary. If `verifyWorkflow` is false and any step fails, the tests are skipped; otherwise, an error is thrown.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_6

language: javascript
code:
```
### `generateSEA(targetExecutable, sourceExecutable, seaBlob, verifyWorkflow)`

Copy `sourceExecutable` to `targetExecutable`, use postject to inject `seaBlob`
into `targetExecutable` and sign it if necessary.

If `verifyWorkflow` is false (default) and any of the steps fails,
it skips the tests. Otherwise, an error is thrown.
```

---

title: Calling a Callback After a Specific Number of Ticks
description: Illustrates how to use the `tick` function to call a callback function after a specified number of event loop ticks. This allows for precise timing control in asynchronous operations.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_7

language: javascript
code:
```
### `tick(x, cb)`

* `x` [\[<number>\]][<number>] Number of event loop "ticks".
* `cb` [\[<Function>\]][<Function>] A callback function.
```

---

title: Accessing Temporary Directory Path
description: Demonstrates how to access the realpath of the testing temporary directory using the `tmpdir.path` property. This provides a reliable way to interact with temporary files and directories during testing.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_8

language: javascript
code:
```
### `path`

* [\[<string>\]][<string>]

The realpath of the testing temporary directory.
```

---

title: Resolving File URLs in Temporary Directory
description: Demonstrates how to resolve a sequence of paths into an absolute URL within the temporary directory using the `tmpdir.fileURL()` function. When called without arguments, it returns the absolute URL of the temporary directory with an explicit trailing `/`.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_9

language: javascript
code:
```
### `fileURL([...paths])`

* `...paths` [\[<string>\]][<string>]
* return [\[<URL>\]][<URL>]

Resolves a sequence of paths into absolute url in the temporary directory.

When called without arguments, returns absolute url of the testing
temporary directory with explicit trailing `/`.
```

---

title: Refreshing the Temporary Directory
description: Explains how to delete and recreate the testing temporary directory using `tmpdir.refresh()`. The function uses `child_process.spawnSync` when `useSpawn` is true. The first call adds a listener to process `'exit'` that cleans the directory, so files under `tmpdir.path` should be closed before test completion.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_10

language: javascript
code:
```
### `refresh(useSpawn)`

* `useSpawn` [\[<boolean>\]][<boolean>] default = false

Deletes and recreates the testing temporary directory. When `useSpawn` is true
this action is performed using `child_process.spawnSync`.

The first time `refresh()` runs, it adds a listener to process `'exit'` that
cleans the temporary directory. Thus, every file under `tmpdir.path` needs to
be closed before the test completes. A good way to do this is to add a
listener to process `'beforeExit'`. If a file needs to be left open until
Node.js completes, use a child process and call `refresh()` only in the
parent.

It is usually only necessary to call `refresh()` once in a test file.
Avoid calling it more than once in an asynchronous context as one call
might refresh the temporary directory of a different context, causing
the test to fail somewhat mysteriously.
```

---

title: Resolving Paths in Temporary Directory
description: Demonstrates how to resolve a sequence of paths into an absolute path within the temporary directory using the `tmpdir.resolve()` function. This simplifies the process of working with files and directories inside the temporary directory.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_11

language: javascript
code:
```
### `resolve([...paths])`

* `...paths` [\[<string>\]][<string>]
* return [\[<string>\]][<string>]

Resolves a sequence of paths into absolute path in the temporary directory.
```

---

title: Checking Available Space in Temporary Directory
description: Describes how to use `tmpdir.hasEnoughSpace(size)` to check if the file system underlying the temporary directory has enough space to hold a file of a given size. While inaccurate, this is useful for skipping tests requiring large temporary files.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_12

language: javascript
code:
```
### `hasEnoughSpace(size)`

* `size` [\[<number>\]][<number>] Required size, in bytes.

Returns `true` if the available blocks of the file system underlying `path`
are likely sufficient to hold a single file of `size` bytes. This is useful for
skipping tests that require hundreds of megabytes or even gigabytes of temporary
files, but it is inaccurate and susceptible to race conditions.
```

---

title: Running WPT with WPTRunner Class
description: Describes the `WPTRunner` class, which serves as a driver for running Web Platform Tests with the WPT harness in a worker thread. Refer to the WPT tests README for more details.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_14

language: javascript
code:
```
### Class: WPTRunner

A driver class for running WPT with the WPT harness in a worker thread.

See [\[the WPT tests README\]][] for details.
```

---

title: Creating Namespace Exports - Javascript
description: Demonstrates how namespace export objects are created for modules with exports, including `helper`, `version`, and `DEFAULT`. It includes a `Symbol.toStringTag` and `__esModule` property, enabling CommonJS interop and ES6 import star functionality.
source: src/bundler/linker_context/README.md#_snippet_3

language: javascript
code:
```
// For a module with exports: { helper, version, DEFAULT }
// Creates namespace object like:
{
  helper: helper_symbol_ref,
  version: version_symbol_ref,
  default: DEFAULT_symbol_ref,
  [Symbol.toStringTag]: 'Module',
  __esModule: true // For CommonJS interop
}
```

---

title: Using Runtime Helper Functions - Javascript
description: Demonstrates the use of runtime helper functions (`__toESM`, `__toCommonJS`, `__require`, `__reExport`) for handling compatibility between CommonJS and ES6 modules. These helpers are used when importing CommonJS modules with ES6 syntax or requiring ES6 modules in a CommonJS environment.
source: src/bundler/linker_context/README.md#_snippet_5

language: javascript
code:
```
// __toESM: Used when importing CommonJS with ES6 syntax
import utils from "./commonjs-module.js";
// Generates: __toESM(require('./commonjs-module.js'))

// __toCommonJS: Used when requiring ES6 module
const utils = require("./es6-module.js");
// Generates: __toCommonJS(es6_module_exports)

// __require: Used for external require() calls in non-CommonJS output
const path = require("path");
// Generates: __require('path')

// __reExport: Used for export star from external modules
export * from "external-package";
// Generates: __reExport(exports, require('external-package'))
```

---

title: Handling Entry Point Dependencies - Javascript
description: Illustrates how dependencies are added from the entry point to all parts that declare exports. This ensures all exports are included in the final bundle by creating dependencies from the entry point to the declaring parts.
source: src/bundler/linker_context/README.md#_snippet_6

language: javascript
code:
```
// For entry points, ensure all exports are included in final bundle
for (exportAlias of entryPointExports) {
  const exportDef = resolvedExports[exportAlias];
  const declaringParts = getPartsDeclaringSymbol(
    exportDef.sourceIndex,
    exportDef.ref,
  );

  // Add dependencies from entry point to all parts that declare exports
  entryPointPart.dependencies.addAll(declaringParts);
}
```

---

title: Setting Up Wrapper Function Dependency - Javascript
description: Illustrates how dependencies are set up for wrapper functions when a module needs wrapping. Other modules must depend on its wrapper function for correct module access, which generates code to import the wrapper function, especially in ES6 imports of CommonJS modules that require a `__toESM` wrapper.
source: src/bundler/linker_context/README.md#_snippet_7

language: javascript
code:
```
// When a module needs wrapping, other modules must depend on its wrapper
if (targetModule.needsWrapper) {
  // Import the wrapper function instead of direct module access
  currentPart.dependencies.add({
    sourceIndex: targetModule.index,
    ref: targetModule.wrapperRef, // Points to require_moduleName() function
  });

  // For ES6 imports of CommonJS, add __toESM wrapper
  if (importKind !== "require" && targetModule.isCommonJS) {
    record.wrapWithToESM = true;
    generateRuntimeSymbolImport("__toESM");
  }
}
```

---

title: Understanding Snapshot File Structure
description: Illustrates the directory structure created by Bun when running snapshot tests for the first time. A `__snapshots__` directory is created alongside the test file, and a `.snap` file is generated inside, containing the snapshot of the test's output.
source: docs/guides/test/update-snapshots.md#_snippet_1

language: txt
code:
```
test
â”œâ”€â”€ __snapshots__
â”‚  â””â”€â”€ snap.test.ts.snap
â””â”€â”€ snap.test.ts
```

---

title: Updating Snapshots
description: Demonstrates how to regenerate snapshot files using the `--update-snapshots` flag.  This command updates the snapshots to reflect any changes in the test's output, ensuring that the tests continue to pass with the updated snapshots.
source: docs/guides/test/update-snapshots.md#_snippet_2

language: sh
code:
```
$ bun test --update-snapshots
bun test v$BUN_LATEST_VERSION (9c68abdb)

test/snap.test.ts:
âœ“ snapshot [0.86ms]

 1 pass
 0 fail
 snapshots: +1 added # the snapshot was regenerated
 1 expect() calls
Ran 1 tests across 1 files. [102.00ms]
```

---

title: Inspecting the Snapshot File Contents
description: Illustrates the content of the `.snap` file generated by Bun. The snapshot file contains a JavaScript representation of the serialized value that was passed to `expect()`, allowing Bun to compare future test runs against the stored snapshot.
source: docs/guides/test/snapshot.md#_snippet_2

language: js
code:
```
// Bun Snapshot v1, https://bun.sh/docs/test/snapshots

exports[`snapshot 1`] = `
{
  "foo": "bar",
}
`;
```

---

title: Updating Snapshots Using a Flag
description: Explains how to update the snapshots using the `--update-snapshots` flag. When this flag is used, Bun will regenerate the snapshot files with the current values.
source: docs/guides/test/snapshot.md#_snippet_4

language: sh
code:
```
$ bun test --update-snapshots
bun test v$BUN_LATEST_VERSION (9c68abdb)

test/snap.test.ts:
âœ“ snapshot [0.86ms]

 1 pass
 0 fail
 snapshots: +1 added  # the snapshot was regenerated
 1 expect() calls
Ran 1 tests across 1 files. [102.00ms]
```

---

title: Accessing Mock Function Calls and Results - TypeScript
description: Illustrates how to access the calls and results of a mock function using the `mock.calls` and `mock.results` properties. These properties are useful for asserting how the mock function was used during testing, providing insights into its arguments and return values.
source: docs/guides/test/mock-functions.md#_snippet_2

language: typescript
code:
```
import { mock } from "bun:test";

const random = mock((multiplier: number) => multiplier * Math.random());

random(2);
random(10);

random.mock.calls;
// [[ 2 ], [ 10 ]]

random.mock.results;
//  [
//    { type: "return", value: 0.6533907460954099 },
//    { type: "return", value: 0.6452713933037312 }
//  ]
```

---

title: Writing Assertions for Mock Function Usage - TypeScript
description: Demonstrates how to write assertions about the usage of a mock function using `expect`. The example shows how to verify the number of calls, arguments, and return values of the mock function, providing a way to ensure the mock is behaving as expected during tests.
source: docs/guides/test/mock-functions.md#_snippet_3

language: typescript
code:
```
import { test, expect, mock } from "bun:test";

const random = mock((multiplier: number) => multiplier * Math.random());

test("random", async () => {
  const a = random(1);
  const b = random(2);
  const c = random(3);

  expect(random).toHaveBeenCalled();
  expect(random).toHaveBeenCalledTimes(3);
  expect(random.mock.args).toEqual([[1], [2], [3]]);
  expect(random.mock.results[0]).toEqual({ type: "return", value: a });
});
```

---

title: Converting Readable Stream to Uint8Array - Typescript
description: Demonstrates how to convert a Node.js `Readable` stream to a `Uint8Array` in Bun. The code creates a new `Response` object with the stream as the body, then uses `bytes()` to read the stream into an `Uint8Array`. This is useful for processing streaming data in memory.
source: docs/guides/streams/node-readable-to-uint8array.md#_snippet_0

language: typescript
code:
```
import { Readable } from "stream";
const stream = Readable.from(["Hello, ", "world!"]);
const buf = await new Response(stream).bytes();
```

---

title: Converting ReadableStream to Chunk Array - TypeScript
description: Demonstrates how to convert a `ReadableStream` into an array of chunks using `Bun.readableStreamToArray`. This is useful for processing stream data in a chunk-oriented manner, allowing you to work with the stream's content in discrete segments.
source: docs/guides/streams/to-array.md#_snippet_0

language: typescript
code:
```
const stream = new ReadableStream();
const str = await Bun.readableStreamToArray(stream);
```

---

title: Converting ReadableStream to Blob - TypeScript
description: Demonstrates how to convert a `ReadableStream` to a `Blob` using `Bun.readableStreamToBlob()`. This is useful for handling streaming data and converting it into a format suitable for file operations or network transfers.
source: docs/guides/streams/to-blob.md#_snippet_0

language: typescript
code:
```
const stream = new ReadableStream();
const blob = await Bun.readableStreamToBlob(stream);
```

---

title: Resetting System Time to Actual Time
description: Demonstrates how to reset the system clock to the actual time using `setSystemTime` without any arguments. This is useful for cleaning up after tests that mock the system time or for ensuring that subsequent tests are not affected by a previously mocked clock. The example shows the import statement alongside the function call that resets the clock.
source: docs/guides/test/mock-clock.md#_snippet_2

language: typescript
code:
```
import { test, expect, beforeAll, setSystemTime } from "bun:test";

setSystemTime(); // reset to actual time
```

---

title: Filtering Tests by Name with Bun Test
description: Illustrates how to selectively run tests by name using the `-t` or `--test-name-pattern` flag with the `bun test` command. This allows developers to focus on specific test cases or suites, improving efficiency during debugging and development.
source: docs/guides/test/run-tests.md#_snippet_3

language: sh
code:
```
$ bun test -t add
```

---

title: Checking Bun Revision
description: Illustrates how to check the specific commit of the `oven-sh/bun` repository that's being used with `bun --revision`. This can be useful for debugging or verifying specific builds.
source: docs/installation.md#_snippet_7

language: sh
code:
```
$ bun --revision
1.x.y+b7982ac13189
```

---

title: Piping Stderr in Bun
description: Demonstrates how to pipe `stderr` when using `Bun.spawn()`. Setting the `stderr` option to `pipe` allows you to read and handle `stderr` from the child process instead of it being inherited from the spawning process.
source: docs/guides/process/spawn-stderr.md#_snippet_0

language: typescript
code:
```
const proc = Bun.spawn(["echo", "hello"], {
  stderr: "pipe",
});
proc.stderr; // => ReadableStream
```

---

title: Reading Stderr as Text in Bun
description: Illustrates how to read `stderr` as text until the child process exits using `.text()`. The resulting string contains any errors produced by the child process, which can then be handled.
source: docs/guides/process/spawn-stderr.md#_snippet_1

language: typescript
code:
```
const proc = Bun.spawn(["echo", "hello"], {
  stderr: "pipe",
});

const errors: string = await proc.stderr.text();
if (errors) {
  // handle errors
}
```

---

title: Inheriting Stdout - Bun
description: Illustrates how to pipe the `stdout` of a child process directly to the `stdout` of the parent process. This is achieved by setting the `stdout` option to `"inherit"` in the `Bun.spawn()` options, which is useful for simple cases where you want the child's output to appear directly in the parent's console.
source: docs/guides/process/spawn-stdout.md#_snippet_1

language: ts
code:
```
const proc = Bun.spawn(["echo", "hello"], {
  stdout: "inherit",
});
```

---

title: Listening to Exit Event - TypeScript
description: Illustrates how to listen for the `
source: docs/guides/process/os-signals.md#_snippet_1

language: typescript
code:
```
process.on("exit", code => {
  console.log(`Process exited with code ${code}`);
});
```

---

title: Reading Chunks from Stdin - TypeScript
description: Illustrates reading data in chunks from standard input using `Bun.stdin.stream()`. The example iterates over the stream, converting each `Uint8Array` chunk to a string and logging it to the console. This is useful for handling large inputs that are piped into the `bun` process.
source: docs/guides/process/stdin.md#_snippet_1

language: typescript
code:
```
for await (const chunk of Bun.stdin.stream()) {
  // chunk is Uint8Array
  // this converts it to text (assumes ASCII encoding)
  const chunkText = Buffer.from(chunk).toString();
  console.log(`Chunk: ${chunkText}`);
}
```

---

title: Setting Proxy via Environment Variable
description: Illustrates how to set the `$HTTP_PROXY` or `$HTTPS_PROXY` environment variable to specify a proxy URL for all requests. This is useful when you want to use the same proxy for all outgoing HTTP(S) connections made by Bun.
source: docs/guides/http/proxy.md#_snippet_1

language: shell
code:
```
HTTPS_PROXY=https://username:password@proxy.example.com:8080 bun run index.ts
```

---

title: Configuring Child Process Options with Bun
description: Illustrates how to configure a child process using the second argument of `Bun.spawn()`. The configuration includes setting the current working directory (`cwd`), environment variables (`env`), and an exit handler function (`onExit`).
source: docs/guides/process/spawn.md#_snippet_1

language: ts
code:
```
const proc = Bun.spawn(["echo", "Hello, world!"], {
  cwd: "/tmp",
  env: { FOO: "bar" },
  onExit(proc, exitCode, signalCode, error) {
    // exit handler
  },
});
```

---

title: Consuming Child Process Output Using ReadableStream - Bun
description: Demonstrates how to capture the standard output (`stdout`) of a child process as a `ReadableStream` using `proc.stdout`. The example shows how to convert the stream to text using `.text()` and then displays the output.
source: docs/guides/process/spawn.md#_snippet_2

language: ts
code:
```
const proc = Bun.spawn(["echo", "hello"]);

const output = await proc.stdout.text();
output; // => "hello\n"
```

---

title: Configuring TLS with Certificate and Key - TypeScript
description: Illustrates how to configure TLS for a Bun server using `Bun.file()` to read the certificate and key files. This enables HTTPS for the server, ensuring secure communication.
source: docs/guides/http/tls.md#_snippet_0

language: typescript
code:
```
const server = Bun.serve({
  fetch: request => new Response("Welcome to Bun!"),
  tls: {
    cert: Bun.file("cert.pem"),
    key: Bun.file("key.pem"),
  },
});
```

---

title: Deleting a File Using BunFile
description: Demonstrates how to delete a file using `Bun.file()` and the `.delete()` method. The code initializes a `BunFile` instance with the file path, then asynchronously deletes the file. This approach is useful for removing files within a Bun environment.
source: docs/guides/write-file/unlink.md#_snippet_0

language: typescript
code:
```
const path = "/path/to/file.txt";
const file = Bun.file(path);

await file.delete();
```

---

title: Sending POST Request Using Unix Domain Sockets - Typescript
description: Illustrates sending a `POST` request to an API endpoint using a unix domain socket with Bun's `fetch()`. It sets the `unix` option to the socket's path, specifies the `POST` method, includes a JSON body, and sets the `Content-Type` header.
source: docs/guides/http/fetch-unix.md#_snippet_1

language: ts
code:
```
const response = await fetch("https://hostname/a/path", {
  unix: "/var/run/path/to/unix.sock",
  method: "POST",
  body: JSON.stringify({ message: "Hello from Bun!" }),
  headers: {
    "Content-Type": "application/json",
  },
});

const body = await response.json();
```

---

title: Writing to Stdout Using Bun.write
description: Illustrates writing to standard output using `Bun.write()` and `Bun.stdout`. `Bun.stdout` exposes stdout as a `BunFile`, which can be used as a destination for `Bun.write()` for more advanced use cases.
source: docs/guides/write-file/stdout.md#_snippet_1

language: ts
code:
```
await Bun.write(Bun.stdout, "Lorem ipsum");
```

---

title: Sending Data Between Processes - TypeScript
description: Shows how to send various data types as messages between parent and child processes using `process.send()`. Messages are serialized using the JSC `serialize` API, which supports transferrable types like strings and objects.
source: docs/guides/process/ipc.md#_snippet_2

language: typescript
code:
```
// send a string
process.send("Hello from child as string");

// send an object
process.send({ message: "Hello from child as object" });
```

---

title: Checking File Existence (TypeScript)
description: Illustrates how to check if a file exists using `Bun.file(filePath).exists()`. This is useful for validating file paths before attempting to read or write to a file, preventing errors.
source: README.md#_snippet_1

language: typescript
code:
```
const filePath = "./my-file.txt";

if (await Bun.file(filePath).exists()) {
  console.log("File exists!");
} else {
  console.log("File does not exist.");
}
```

---

title: Reading a File as a String (TypeScript)
description: Demonstrates how to read the contents of a file as a string using `Bun.file(filePath).text()`. This is useful for reading configuration files, text documents, or any other file that can be represented as a string.
source: README.md#_snippet_2

language: typescript
code:
```
const filePath = "./my-file.txt";
const fileContent = await Bun.file(filePath).text();

console.log(fileContent);
```

---

title: Writing a String to a File (TypeScript)
description: Demonstrates how to write a string to a file using `Bun.write(filePath, data)`. This is a fundamental operation for creating and modifying files in Bun.
source: README.md#_snippet_3

language: typescript
code:
```
const filePath = "./output.txt";
const data = "Hello, Bun!";

await Bun.write(filePath, data);
```

---

title: Reading Environment Variables (TypeScript)
description: Demonstrates how to read environment variables using `process.env`. This allows your application to access configuration values defined in the environment.
source: README.md#_snippet_5

language: typescript
code:
```
const apiUrl = process.env.API_URL;
const debugMode = process.env.DEBUG === "true";

console.log(`API URL: ${apiUrl}`);
console.log(`Debug Mode: ${debugMode}`);
```

---

title: Importing a JSON File (TypeScript)
description: Demonstrates how to import a JSON file directly into your TypeScript code. This allows you to easily load and use JSON data in your application.
source: README.md#_snippet_6

language: typescript
code:
```
import data from "./data.json";

console.log(data.name);
console.log(data.version);
```

---

title: Importing a TOML File (TypeScript)
description: Demonstrates how to import a TOML file directly into your TypeScript code.  This provides a convenient way to load configuration data structured in the TOML format.
source: README.md#_snippet_7

language: typescript
code:
```
import config from "./config.toml";

console.log(config.database.server);
console.log(config.owner.name);
```

---

title: Spawning a Child Process (TypeScript)
description: Illustrates how to spawn a child process using `Bun.spawn`.  This allows you to execute external commands from within your Bun application, enabling interaction with system utilities or other programs.
source: README.md#_snippet_8

language: typescript
code:
```
const { stdout, stderr, exited } = Bun.spawn(['ls', '-l', '/'], {
  stdout: 'pipe',
  stderr: 'pipe',
});

const output = await new Response(stdout).text();
console.log(output);

const errOutput = await new Response(stderr).text();
console.error(errOutput);

const exitCode = await exited;
console.log(`Exit code: ${exitCode}`);
```

---

title: Running a Shell Command (TypeScript)
description: Demonstrates running a shell command using the `$` operator. This offers a more concise syntax for executing shell commands and capturing their output.
source: README.md#_snippet_9

language: typescript
code:
```
const output = await $\`ls -l /\`;
console.log(output.stdout.toString());
```

---

title: Reading from Stdin (TypeScript)
description: Illustrates how to read input from stdin using `Bun.stdin`. This allows your Bun application to interact with the user by reading data entered from the command line.
source: README.md#_snippet_10

language: typescript
code:
```
const input = await Bun.stdin.text();
console.log(`You entered: ${input}`);
```

---

title: Parsing Command Line Arguments (TypeScript)
description: Illustrates how to parse command-line arguments using `process.argv`. This allows your Bun application to accept and process arguments passed when the script is executed from the command line, customizing its behavior.
source: README.md#_snippet_12

language: typescript
code:
```
const args = process.argv.slice(2);
console.log('Arguments:', args);
```

---

title: Skipping Tests With The Bun Test Runner (TypeScript)
description: Demonstrates the usage of `.skip` to skip tests in Bun's test runner.  Skipping tests is useful for temporarily disabling tests that are failing or not yet implemented, allowing you to focus on other parts of the codebase.
source: README.md#_snippet_15

language: typescript
code:
```
import { describe, expect, it } from 'bun:test';

describe('MyComponent', () => {
  it('should render correctly', () => {
    // ...
  });

  it.skip('should handle edge cases', () => {
    // This test is skipped
  });
});
```

---

title: Encoding and Decoding Base64 Strings (TypeScript)
description: Demonstrates how to encode and decode base64 strings using `Bun.encode` and `Bun.decode`. Base64 encoding is commonly used to represent binary data in a text format that can be safely transmitted over networks.
source: README.md#_snippet_17

language: typescript
code:
```
const text = "Hello, world!";
const encoded = Bun.encode(text, "base64");
console.log("Encoded:", encoded);

const decoded = Bun.decode(encoded, "base64");
console.log("Decoded:", decoded);
```

---

title: Compressing and Decompressing Data with Gzip (TypeScript)
description: Demonstrates how to compress and decompress data using gzip with `Bun.gzipSync` and `Bun.gunzipSync`. Gzip compression is widely used to reduce the size of data transmitted over networks or stored on disk.
source: README.md#_snippet_18

language: typescript
code:
```
const data = Buffer.from('Some data to compress');

const compressed = Bun.gzipSync(data);
console.log('Compressed data length:', compressed.length);

const decompressed = Bun.gunzipSync(compressed);
console.log('Decompressed data:', decompressed.toString());
```

---

title: Getting the Directory of the Current File (TypeScript)
description: Illustrates how to obtain the directory of the current file using `import.meta.dir`.  This is useful for resolving relative paths to other files within the same directory as the current module.
source: README.md#_snippet_20

language: typescript
code:
```
console.log('Directory of the current file:', import.meta.dir);
```

---

title: Getting the Absolute Path of the Current File (TypeScript)
description: Shows how to retrieve the absolute path of the current file using `import.meta.path`. This is particularly useful when you need a full path to access the file in the file system.
source: README.md#_snippet_21

language: typescript
code:
```
console.log('Absolute path of the current file:', import.meta.path);
```

---

title: Writing a Response to a File - TypeScript
description: Demonstrates writing a `Response` from a `fetch` call to a file using `Bun.write()`. This is useful for saving the contents of a web request to disk. Bun consumes the `Response` body according to its `Content-Type` header.
source: docs/guides/write-file/response.md#_snippet_0

language: typescript
code:
```
const result = await fetch("https://bun.com");
const path = "./file.txt";
await Bun.write(path, result);
```

---

title: Determining Content Type from File - Bun
description: Illustrates how `Bun` automatically determines and sets the `Content-Type` header based on the file extension when creating a `Response` from a `BunFile`. This eliminates the need for manual `Content-Type` configuration for common file types.
source: docs/guides/http/stream-file.md#_snippet_1

language: typescript
code:
```
new Response(Bun.file("./package.json")).headers.get("Content-Type");
// => application/json;charset=utf-8

new Response(Bun.file("./test.txt")).headers.get("Content-Type");
// => text/plain;charset=utf-8

new Response(Bun.file("./index.tsx")).headers.get("Content-Type");
// => text/javascript;charset=utf-8

new Response(Bun.file("./img.png")).headers.get("Content-Type");
// => image/png
```

---

title: Creating Heap Snapshot Files - TypeScript
description: Demonstrates how to generate a V8 heap snapshot file using `v8.writeHeapSnapshot()`. The function returns the file path to the generated `.heapsnapshot` file, which can then be loaded into tools like Chrome DevTools for memory analysis.
source: docs/guides/runtime/heap-snapshot.md#_snippet_0

language: ts
code:
```
import v8 from "node:v8";

// Creates a heap snapshot file with an auto-generated name
const snapshotPath = v8.writeHeapSnapshot();
console.log(`Heap snapshot written to: ${snapshotPath}`);
```

---

title: Appending Data Asynchronously with Callbacks - TypeScript
description: Illustrates how to append data to a file asynchronously using the callback-based `fs.appendFile` function from the `node:fs` module. The code imports `appendFile` and passes a file name, the data to append, and a callback function that handles potential errors.
source: docs/guides/write-file/append.md#_snippet_1

language: typescript
code:
```
import { appendFile } from "node:fs";

appendFile("message.txt", "data to append", err => {
  if (err) throw err;
  console.log('The "data to append" was appended to file!');
});
```

---

title: Appending Data Synchronously - TypeScript
description: Demonstrates how to append data to a file synchronously using `fs.appendFileSync` from the `node:fs` module. The file name, data to append, and encoding are provided as arguments to `appendFileSync`, which blocks until the operation is complete.
source: docs/guides/write-file/append.md#_snippet_3

language: typescript
code:
```
import { appendFileSync } from "node:fs";

appendFileSync("message.txt", "data to append", "utf8");
```

---

title: Setting Environment Variables (Command Line)
description: Demonstrates how to set environment variables via the command line when running a Bun script. The methods differ between operating systems, with separate instructions provided for Linux/macOS, Windows CMD, and PowerShell.
source: docs/guides/runtime/set-env.md#_snippet_2

language: sh
code:
```
$ FOO=helloworld bun run dev
```

language: sh
code:
```
# Using CMD
$ set FOO=helloworld && bun run dev

# Using PowerShell
$ $env:FOO="helloworld"; bun run dev
```

---

title: Getting the Bytes Written to Disk - TS
description: Illustrates how to obtain the number of bytes written to disk using `Bun.write()`. The function returns the byte count after a successful write operation.
source: docs/guides/write-file/basic.md#_snippet_3

language: ts
code:
```
const path = "./file.txt";
const bytes = await Bun.write(path, "Lorem ipsum");
// => 11
```

---

title: Importing JSON Data With Import Attributes - TypeScript
description: Illustrates how to import a `.json` file in Bun using import attributes. This syntax explicitly tells Bun that the imported file is JSON, which can be useful for clarity and compatibility with other tools. The imported data can then be accessed like a regular JavaScript object.
source: docs/guides/runtime/import-json.md#_snippet_1

language: typescript
code:
```
import data from "./package.json" with { type: "json" };

data.name; // => "bun"
data.version; // => "1.0.0"
data.author.name; // => "John Dough"
```

---

title: Printing All Environment Variables For Debugging - Shell
description: Demonstrates how to print all currently set environment variables to the command line using `bun --print process.env`. This is useful for debugging and verifying that environment variables are set correctly.
source: docs/guides/runtime/read-env.md#_snippet_2

language: sh
code:
```
$ bun --print process.env
BAZ=stuff
FOOBAR=aaaaaa
<lots more lines>
```

---

title: Capturing Shell Command Output - Typescript
description: Illustrates how to capture the output of a shell command using the `text()` method. The example executes `ls -l` and logs the output to the console, showing how to work with command results.
source: docs/guides/runtime/shell.md#_snippet_1

language: typescript
code:
```
import { $ } from "bun";

const output = await $`ls -l`.text();
console.log(output);
```

---

title: Iterating Over Shell Command Output Lines - Typescript
description: Demonstrates how to process the output of a shell command line by line using the `lines()` method. This allows you to iterate through each line of the output from a command like `ls -l`.
source: docs/guides/runtime/shell.md#_snippet_2

language: typescript
code:
```
import { $ } from "bun";

for await (const line of $`ls -l`.lines()) {
  console.log(line);
}
```

---

title: Handling Non-Existent Directory During Deletion - TypeScript
description: Illustrates how to handle the case where the directory to be deleted does not exist. It uses a `try...catch` block to catch the `ENOENT` error, which is thrown when the directory is not found.  The code attempts to delete the directory recursively and logs a message if it does not exist, avoiding program termination.
source: docs/guides/runtime/delete-directory.md#_snippet_1

language: typescript
code:
```
try {
  await rm("path/to/directory", { recursive: true });
} catch (error) {
  if (error.code === "ENOENT") {
    console.log("Directory doesn't exist");
  } else {
    throw error;
  }
}
```

---

title: Listing Code Signing Identities - macOS
description: Lists available code signing identities using the `security find-identity` command on macOS.  This command is necessary to retrieve the correct identity to use for signing the executable.
source: docs/guides/runtime/codesign-macos-executable.md#_snippet_1

language: sh
code:
```
$ security find-identity -v -p codesigning
1. XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX "Developer ID Application: Your Name (ZZZZZZZZZZ)"
   1 valid identities found
```

---

title: Replacing Values with JSON
description: Explains how to use the `--define` flag to replace values with JSON objects and arrays, which are then transformed into equivalent JavaScript code during transpilation.
source: docs/guides/runtime/define-constant.md#_snippet_6

language: sh
code:
```
# JSON
bun --define AWS='{"ACCESS_KEY":"abc","SECRET_KEY":"def"}' src/index.ts
```

language: ts
code:
```
console.log(AWS.ACCESS_KEY); // => "abc"
```

---

title: Replacing Values With Other Properties
description: Illustrates how to replace values with other properties using the `--define` flag, demonstrating a dynamic replacement of `console.write` with `console.log`.
source: docs/guides/runtime/define-constant.md#_snippet_7

language: sh
code:
```
bun --define console.write=console.log src/index.ts
```

language: ts
code:
```
console.write("Hello, world!");
```

language: ts
code:
```
console.log("Hello, world!");
```

---

title: Adding a Peer Dependency with Bun
description: Demonstrates how to add a package as a peer dependency using the `bun add` command with the `--peer` flag. This ensures that the package is added to the `peerDependencies` section of the `package.json` file, indicating that the package is expected to be provided by the host environment.
source: docs/guides/install/add-peer.md#_snippet_0

language: shell
code:
```
$ bun add @types/bun --peer
```

---

title: Defining Peer Dependencies in Package JSON
description: Illustrates how a peer dependency is represented in the `package.json` file. The `@types/bun` package is added to the `peerDependencies` section, specifying the required version. This allows the package manager to verify that a compatible version of the dependency is available during installation.
source: docs/guides/install/add-peer.md#_snippet_1

language: json-diff
code:
```
{
  "peerDependencies": {
+   "@types/bun": "^$BUN_LATEST_VERSION"
  }
}
```

---

title: Updating Package.json with Git Dependency
description: Illustrates the `package.json` file modification after adding a GitHub repository as a dependency. The `lodash` dependency is added with the `github:lodash/lodash` specifier.
source: docs/guides/install/add-git.md#_snippet_1

language: json-diff
code:
```
{
  "dependencies": {
+   "lodash": "github:lodash/lodash"
  }
}
```

---

title: Adding Git Dependencies with Different Protocols
description: Demonstrates various protocols for specifying Git dependencies using the `bun add` command. It covers `git+https`, `git+ssh`, `git@`, and direct GitHub specifiers, providing flexibility in defining dependencies.
source: docs/guides/install/add-git.md#_snippet_2

language: shell
code:
```
$ bun add git+https://github.com/lodash/lodash.git
$ bun add git+ssh://github.com/lodash/lodash.git#4.17.21
$ bun add git@github.com:lodash/lodash.git
$ bun add github:colinhacks/zod
```

---

title: Illustrating Dev Dependencies Update - JSON
description: Illustrates the effect of adding a development dependency on the `package.json` file. The `zod` package is added to the `devDependencies` section with its corresponding version.
source: docs/guides/install/add-dev.md#_snippet_1

language: json
code:
```
{
  "devDependencies": {
+   "zod": "^3.0.0"
  }
}
```

---

title: Illustrating Changes to packagejson
description: Illustrates the change to `package.json` after adding `zod` as a dependency. The `zod` package and its version are added to the `dependencies` section with a `^` specifier, allowing for future minor and patch version updates.
source: docs/guides/install/add.md#_snippet_1

language: json-diff
code:
```
{
  "dependencies": {
+     "zod": "^3.0.0"
  }
}
```

---

title: Simulating Sleep Using Promise and setTimeout-TypeScript
description: Illustrates an alternative approach to achieve sleep functionality using `Promise` and `setTimeout`. This is equivalent to `Bun.sleep` and provides control over asynchronous delays.
source: docs/guides/util/sleep.md#_snippet_1

language: typescript
code:
```
await new Promise(resolve => setTimeout(resolve, ms));
```

---

title: Converting Relative URLs to Absolute URLs - HTMLRewriter
description: Illustrates how to convert relative URLs to absolute URLs when scraping websites using Bun's `HTMLRewriter`. The code fetches HTML content, extracts `href` attributes from `<a>` tags, and uses the `URL` constructor to resolve relative URLs against the base URL of the webpage. A `try...catch` block handles cases where the `href` is not a valid URL.
source: docs/guides/html-rewriter/extract-links.md#_snippet_1

language: typescript
code:
```
async function extractLinksFromURL(url: string) {
  const response = await fetch(url);
  const links = new Set<string>();

  const rewriter = new HTMLRewriter().on("a[href]", {
    element(el) {
      const href = el.getAttribute("href");
      if (href) {
        // Convert relative URLs to absolute
        try {
          const absoluteURL = new URL(href, url).href;
          links.add(absoluteURL);
        } catch {
          links.add(href);
        }
      }
    },
  });

  // Wait for the response to be processed
  await rewriter.transform(response).blob();
  return [...links];
}

const websiteLinks = await extractLinksFromURL("https://example.com");
```

---

title: Generating a UUID v7 Using Bun
description: Illustrates how to generate a UUID v7 using the `Bun.randomUUIDv7()` method. This method is specific to Bun and generates UUIDs according to the [UUID v7](https://www.ietf.org/archive/id/draft-peabody-dispatch-new-uuid-format-01.html) specification.
source: docs/guides/util/javascript-uuid.md#_snippet_1

language: typescript
code:
```
Bun.randomUUIDv7();
// => "0196a000-bb12-7000-905e-8039f5d5b206"
```

---

title: Enabling Strict Mode for Deep Equality - TypeScript
description: Illustrates how to use strict mode in `Bun.deepEquals` by passing `true` as the third argument. Strict mode considers `undefined` values and object types, providing a more precise comparison.
source: docs/guides/util/deep-equals.md#_snippet_1

language: typescript
code:
```
// undefined values
Bun.deepEquals({}, { a: undefined }, true); // false

// undefined in arrays
Bun.deepEquals(["asdf"], ["asdf", undefined], true); // false

// sparse arrays
Bun.deepEquals([, 1], [undefined, 1], true); // false

// object literals vs instances w/ same properties
class Foo {
  a = 1;
}
Bun.deepEquals(new Foo(), { a: 1 }, true); // false
```

---

title: Configuring Argon2id Hashing Parameters
description: Illustrates how to configure the hashing parameters for the Argon2id algorithm using the second argument of `Bun.password.hash()`. This allows customization of `memoryCost` and `timeCost` for fine-tuning security and performance.
source: docs/guides/util/hash-a-password.md#_snippet_1

language: typescript
code:
```
const password = "super-secure-pa$$word";

// use argon2 (default)
const argonHash = await Bun.password.hash(password, {
  memoryCost: 4, // memory usage in kibibytes
  timeCost: 3, // the number of iterations
});
```

---

title: Hashing a Password with Bcrypt
description: Demonstrates how to hash a password using the bcrypt algorithm with `Bun.password.hash()`. Specifying `algorithm: "bcrypt"` allows using bcrypt and configuring its cost parameter, which represents the computational cost of the hashing process.
source: docs/guides/util/hash-a-password.md#_snippet_2

language: typescript
code:
```
// use bcrypt
const bcryptHash = await Bun.password.hash(password, {
  algorithm: "bcrypt",
  cost: 4, // number between 4-31
});
```

---

title: Running the Dev Server with Nodejs
description: Demonstrates how to start the Next.js development server using Node.js. Omitting the `--bun` argument will run the script with Node.js.
source: docs/guides/ecosystem/nextjs.md#_snippet_3

language: sh
code:
```
$ cd my-app
$ bun run dev
```

---

title: Building and Starting a Remix App
description: Demonstrates how to build and start a Remix application for production using `bun run build` and `bun start`.  The `remix build` command compiles the application, and `bun start` serves the built application from the `build/index.js` file. This allows serving the built application in a production environment.
source: docs/guides/ecosystem/remix.md#_snippet_2

language: sh
code:
```
$ bun run build
 $ remix build
 info  building... (NODE_ENV=production)
 info  built (158ms)
$ bun start
 $ remix-serve ./build/index.js
 [remix-serve] http://localhost:3000 (http://192.168.86.237:3000)
```

---

title: Serving Static Files - TypeScript
description: Demonstrates serving static files from a `/public` directory using `@stricjs/utils` in StricJS. It imports the `dir` function and adds a route that serves files from the specified directory for any GET request. This allows the server to serve static content such as HTML, CSS, and JavaScript files.
source: docs/guides/ecosystem/stric.md#_snippet_2

language: typescript
code:
```
import { dir } from '@stricjs/utils';

export default new Router()
  .get('/', () => new Response('Hi'))
  .get('/*', dir('./public'));
```

---

title: Capturing Exceptions - JavaScript
description: Demonstrates how to capture exceptions in a Bun application using `Sentry.captureException()`. This snippet wraps potentially failing code (calling `foo()`) in a `try...catch` block and reports any caught exceptions to Sentry. This allows developers to track and resolve errors that occur during runtime.
source: docs/guides/ecosystem/sentry.md#_snippet_2

language: javascript
code:
```
setTimeout(() => {
  try {
    foo();
  } catch (e) {
    Sentry.captureException(e);
  }
}, 99);
```

---

title: Configuring Build-Time Constants - JavaScript API
description: Demonstrates how to define build-time constants using the JavaScript API for `Bun.build`. It shows how to pass a `define` object containing key-value pairs representing the constants, such as `BUILD_VERSION`, `BUILD_TIME`, and `DEBUG` to be replaced during the build process.
source: docs/guides/runtime/build-time-constants.md#_snippet_2

language: ts
code:
```
await Bun.build({
  entrypoints: ["./src/index.ts"],
  outdir: "./dist",
  define: {
    BUILD_VERSION: '"1.0.0"',
    BUILD_TIME: '"2024-01-15T10:30:00Z"',
    DEBUG: "false",
  },
});
```

---

title: Replacing Configuration Objects at Build Time - TypeScript
description: Illustrates replacing a configuration object at build time. The TypeScript code declares a constant `CONFIG` object and uses its properties in a `fetch` call, demonstrating how the build process replaces `CONFIG` with the actual object specified in the build command.
source: docs/guides/runtime/build-time-constants.md#_snippet_6

language: ts
code:
```
declare const CONFIG: {
  apiUrl: string;
  timeout: number;
  retries: number;
};

// CONFIG is replaced with the actual object at build time
const response = await fetch(CONFIG.apiUrl, {
  timeout: CONFIG.timeout,
});
```

---

title: Building with Configuration Object Defined - Shell
description: Demonstrates building an application with a configuration object defined at build time using the `--define` flag. The `CONFIG` object, containing `apiUrl`, `timeout`, and `retries`, is passed as a stringified JSON object.
source: docs/guides/runtime/build-time-constants.md#_snippet_7

language: sh
code:
```
$ bun build --compile --define 'CONFIG={"apiUrl":"https://api.example.com","timeout":5000,"retries":3}' src/app.ts --outfile app
```

---

title: Accessing ArrayBuffer From Uint8Array
description: Demonstrates how to access the underlying `ArrayBuffer` of a `Uint8Array` using the `buffer` property. This is useful when you need to work with the raw binary data represented by the typed array.
source: docs/guides/binary/typedarray-to-arraybuffer.md#_snippet_0

language: typescript
code:
```
const arr = new Uint8Array(64);
arr.buffer; // => ArrayBuffer(64)
```

---

title: Building a Production Bundle
description: Demonstrates how to build a production bundle using the `bun --bun run build` command. This command triggers the Vite build process and generates optimized production-ready assets.  It also shows the output of the build process when using the `svelte-adapter-bun`.
source: docs/guides/ecosystem/sveltekit.md#_snippet_3

language: sh
code:
```
$ bun --bun run build
  $ vite build
  vite v5.4.10 building SSR bundle for production...
  "confetti" is imported from external module "@neoconfetti/svelte" but never used in "src/routes/sverdle/+page.svelte".
  âœ“ 130 modules transformed.
  vite v5.4.10 building for production...
  âœ“ 148 modules transformed.
  ...
  âœ“ built in 231ms
  ...
  âœ“ built in 899ms

  Run npm run preview to preview your production build locally.

  > Using svelte-adapter-bun
    âœ” Start server with: bun ./build/index.js
    âœ” done
```

---

title: Generating Prisma Client -Bash
description: Illustrates how to manually regenerate the Prisma client using the Prisma CLI. The command `bunx prisma generate` ensures that the Prisma client is up-to-date with the current Prisma schema, providing a fully typed API for database interactions.
source: docs/guides/ecosystem/prisma.md#_snippet_5

language: sh
code:
```
$ bunx prisma generate
```

---

title: Converting Blob to DataView - TypeScript
description: Demonstrates how to convert a `Blob` object to a `DataView` in TypeScript. It reads the `Blob`'s content into an `ArrayBuffer` using `blob.arrayBuffer()`, then constructs a `DataView` from the resulting buffer, allowing typed access to the binary data.
source: docs/guides/binary/blob-to-dataview.md#_snippet_0

language: typescript
code:
```
const blob = new Blob(["hello world"]);
const arr = new DataView(await blob.arrayBuffer());
```

---

title: Setting Blob Type During Creation
description: Illustrates how to set the `type` property of a `Blob` during construction. Passing a second argument with the `type` option allows specifying the MIME type of the `Blob`.
source: docs/guides/binary/arraybuffer-to-blob.md#_snippet_1

language: typescript
code:
```
const buf = new ArrayBuffer(64);
const blob = new Blob([buf], { type: "application/octet-stream" });
blob.type; // => "application/octet-stream"
```

---

title: Building the App for Production Using Bun
description: Demonstrates how to build the application for production using Vite and Bun.  This command generates optimized production-ready assets.
source: docs/guides/ecosystem/vite.md#_snippet_5

language: sh
code:
```
$ bunx --bun vite build
```

---

title: Configuring Workspaces in PackageJson
description: This snippet defines workspaces in `package.json` to organize multi-package projects.  The `workspaces` array specifies relative paths to packages within the project, enabling efficient dependency management and linking.
source: docs/guides/install/from-npm-install-to-bun-install.md#_snippet_2

language: json
code:
```
{
  "name": "my-app",
  "workspaces": ["packages/*", "apps/*"]
}
```

---

title: Updating Dependencies Using Bun Update
description: These commands illustrate how to update dependencies using `bun update`.  It allows updating a single dependency, all dependencies, or updating to the latest version, with options to ignore semver or specify a specific version.
source: docs/guides/install/from-npm-install-to-bun-install.md#_snippet_4

language: sh
code:
```
# Update a single dependency
$ bun update @types/bun

# Update all dependencies
$ bun update

# Ignore semver, update to the latest version
$ bun update @types/bun --latest

# Update a dependency to a specific version
$ bun update @types/bun@$BUN_LATEST_VERSION

# Update all dependencies to the latest versions
$ bun update --latest
```

---

title: Viewing Outdated Dependencies With Bun Outdated
description: This demonstrates using `bun outdated` to view a compact list of outdated dependencies in a project.  It displays the current, updateable, and latest versions of each package, helping to manage dependency updates effectively.
source: docs/guides/install/from-npm-install-to-bun-install.md#_snippet_5

language: sh
code:
```
$ bun outdated
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Package                                â”‚ Current â”‚ Update â”‚ Latest â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ @types/bun (dev)                       â”‚ 1.1.6   â”‚ 1.1.10 â”‚ 1.1.10 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ @types/react (dev)                     â”‚ 18.3.3  â”‚ 18.3.8 â”‚ 18.3.8 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ @typescript-eslint/eslint-plugin (dev) â”‚ 7.16.1  â”‚ 7.18.0 â”‚ 8.6.0  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ @typescript-eslint/parser (dev)        â”‚ 7.16.1  â”‚ 7.18.0 â”‚ 8.6.0  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ @vscode/debugadapter (dev)             â”‚ 1.66.0  â”‚ 1.67.0 â”‚ 1.67.0 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ esbuild (dev)                          â”‚ 0.21.5  â”‚ 0.21.5 â”‚ 0.24.0 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ eslint (dev)                           â”‚ 9.7.0   â”‚ 9.11.0 â”‚ 9.11.0 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ mitata (dev)                           â”‚ 0.1.11  â”‚ 0.1.14 â”‚ 1.0.2  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ prettier-plugin-organize-imports (dev) â”‚ 4.0.0   â”‚ 4.1.0  â”‚ 4.1.0  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ source-map-js (dev)                    â”‚ 1.2.0   â”‚ 1.2.1  â”‚ 1.2.1  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ typescript (dev)                       â”‚ 5.5.3   â”‚ 5.6.2  â”‚ 5.6.2  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

title: Listing Installed Packages Using Bun Pm Ls
description: This demonstrates how to list installed packages using `bun pm ls`, which displays top-level or all installed packages based on Bun's lockfile.  The `-a` flag includes transitive dependencies, providing a comprehensive view of the project's dependency tree.
source: docs/guides/install/from-npm-install-to-bun-install.md#_snippet_6

language: sh
code:
```
# List top-level installed packages:
$ bun pm ls
my-pkg node_modules (781)
â”œâ”€â”€ @types/node@20.16.5
â”œâ”€â”€ @types/react@18.3.8
â”œâ”€â”€ @types/react-dom@18.3.0
â”œâ”€â”€ eslint@8.57.1
â”œâ”€â”€ eslint-config-next@14.2.8

# List all installed packages:
$ bun pm ls -a
my-pkg node_modules
â”œâ”€â”€ @alloc/quick-lru@5.2.0
â”œâ”€â”€ @isaacs/cliui@8.0.2
â”‚   â””â”€â”€ strip-ansi@7.1.0
â”‚       â””â”€â”€ ansi-regex@6.1.0
â”œâ”€â”€ @jridgewell/gen-mapping@0.3.5
â”œâ”€â”€ @jridgewell/resolve-uri@3.1.2
...
```

---

title: Creating a Package Tarball With Bun Pm Pack
description: This demonstrates creating a package tarball using `bun pm pack`. This command generates a tarball of the current package, which can be used for distribution or archiving.
source: docs/guides/install/from-npm-install-to-bun-install.md#_snippet_7

language: sh
code:
```
# Create a tarball
$ bun pm pack

Total files: 46
Shasum: 2ee19b6f0c6b001358449ca0eadead703f326216
Integrity: sha512-ZV0lzWTEkGAMz[...]Gl4f8lA9sl97g==
Unpacked size: 0.41MB
Packed size: 117.50KB
```

---

title: Installing Packages Globally With Bun
description: These commands demonstrate how to install a package globally using `bun i -g <package>` and then run it.  Global installations are placed in a `.bun/install/global/node_modules` folder, and the installed package can be executed without the `bun run` prefix.
source: docs/guides/install/from-npm-install-to-bun-install.md#_snippet_9

language: sh
code:
```
# Install a package globally
$ bun i -g eslint

# Run a globally-installed package without the `bun run` prefix
$ eslint --init
```

---

title: Converting Uint8Array to Regular Array - TypeScript
description: Illustrates how to convert a `Uint8Array` to a regular JavaScript `Array` using `Array.from()` in TypeScript. This is useful when you need the flexibility of a standard array but it may be slower than using `Uint8Array` directly. The example initializes a `Uint8Array` from an `ArrayBuffer` and then converts it.
source: docs/guides/binary/arraybuffer-to-array.md#_snippet_1

language: ts
code:
```
const buf = new ArrayBuffer(64);
const uintArr = new Uint8Array(buf);
const regularArr = Array.from(uintArr);
// number[]
```

---

title: Converting Blob to Uint8Array
description: Demonstrates converting a `Blob` to a `Uint8Array` using the `arrayBuffer` method. This allows accessing the blob's data as an array of unsigned 8-bit integers, useful for binary data manipulation.
source: docs/guides/binary/blob-to-typedarray.md#_snippet_0

language: ts
code:
```
const blob = new Blob(["hello world"]);
const arr = new Uint8Array(await blob.arrayBuffer());
```

---

title: Decoding ArrayBuffer to String - TypeScript
description: Demonstrates how to convert an `ArrayBuffer` to a string using the `TextDecoder` class in Bun. This class implements the Web standard for converting between binary data types and strings, enabling the manipulation of binary data.
source: docs/guides/binary/arraybuffer-to-string.md#_snippet_0

language: typescript
code:
```
const buf = new ArrayBuffer(64);
const decoder = new TextDecoder();
const str = decoder.decode(buf);
```

---

title: Converting Blob to ReadableStream
description: Demonstrates how to convert a `Blob` object into a `ReadableStream` using the `.stream()` method. This allows the `Blob`'s contents to be consumed as a stream of data, enabling processing and manipulation of the data in chunks.
source: docs/guides/binary/blob-to-stream.md#_snippet_0

language: typescript
code:
```
const blob = new Blob(["hello world"]);
const stream = await blob.stream();
```

---

title: Creating DataView from Uint8Array - TypeScript
description: Demonstrates how to create a `DataView` from a `Uint8Array` in TypeScript. This allows accessing and manipulating the underlying `ArrayBuffer` with more control over data types and endianness.
source: docs/guides/binary/typedarray-to-dataview.md#_snippet_0

language: ts
code:
```
const arr: Uint8Array = ...
const dv = new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
```

---

title: Converting Buffer to String with Encoding and Range - NodeJS
description: Illustrates how to specify an encoding and byte range when converting a `Buffer` to a string. The `.toString()` method accepts optional parameters to specify the encoding (`utf8` in this case) and the start and end indices for the conversion.
source: docs/guides/binary/buffer-to-string.md#_snippet_1

language: ts
code:
```
const buf = Buffer.from("hello world!");
const str = buf.toString("utf8", 0, 5);
// => "hello"
```

---

title: Converting Blob to ArrayBuffer - TypeScript
description: Demonstrates converting a `Blob` object to an `ArrayBuffer` using the `.arrayBuffer()` method. This allows for the binary data within the `Blob` to be accessed and manipulated as a raw byte array.
source: docs/guides/binary/blob-to-arraybuffer.md#_snippet_0

language: typescript
code:
```
const blob = new Blob(["hello world"]);
const buf = await blob.arrayBuffer();
```

---

title: Stopping a Docker Container
description: Illustrates how to stop a running Docker container using the `docker stop` command, referencing the container ID. This command terminates the container process, effectively stopping the Bun application running inside it.
source: docs/guides/ecosystem/docker.md#_snippet_4

language: sh
code:
```
$ docker stop 7f03e212a15ede8644379bce11a13589f563d3909a9640446c5bbefce993678d
```

---

title: Viewing a Portion of an ArrayBuffer - TypeScript
description: Illustrates how to create a `Buffer` that views only a specific portion of an `ArrayBuffer`. The `Buffer.from()` method accepts an offset and length to specify the region of the `ArrayBuffer` to be viewed by the new `Buffer`.
source: docs/guides/binary/arraybuffer-to-buffer.md#_snippet_1

language: typescript
code:
```
const arrBuffer = new ArrayBuffer(64);
const nodeBuffer = Buffer.from(arrBuffer, 0, 16); // view first 16 bytes
```

---

title: Creating a ReadableStream from a Buffer
description: Demonstrates how to create a `ReadableStream` from a `Buffer` by enqueuing the entire buffer as a single chunk. This approach is simple but may be inefficient for large buffers because it does not stream the data in smaller chunks.
source: docs/guides/binary/buffer-to-readablestream.md#_snippet_0

language: ts
code:
```
const buf = Buffer.from("hello world");
const stream = new ReadableStream({
  start(controller) {
    controller.enqueue(buf);
    controller.close();
  },
});
```

---

title: Streaming a Buffer Using Blob.stream()
description: Illustrates how to stream a `Buffer` in smaller chunks by creating a `Blob` instance from the `Buffer` and then using the `Blob.stream()` method to create a `ReadableStream`. This allows streaming the data in chunks of a specified size, improving efficiency for large buffers.
source: docs/guides/binary/buffer-to-readablestream.md#_snippet_1

language: ts
code:
```
const buf = Buffer.from("hello world");
const blob = new Blob([buf]);
const stream = blob.stream();
```

---

title: Setting Chunk Size When Streaming (Blob)
description: Demonstrates how to set the chunk size when creating a `ReadableStream` from a `Blob`. Passing a number to the `.stream()` method specifies the size of each chunk in bytes, allowing for control over the streaming granularity.
source: docs/guides/binary/buffer-to-readablestream.md#_snippet_2

language: ts
code:
```
const buf = Buffer.from("hello world");
const blob = new Blob([buf]);

// set chunk size of 1024 bytes
const stream = blob.stream(1024);
```

---

title: Defining a Database Schema with Drizzle
description: Defines a database schema using Drizzle's `sqliteTable`, `text`, and `integer` functions. This example creates a `movies` table with columns for `id`, `title`, and `releaseYear`, demonstrating how to define table structures in Drizzle.
source: docs/guides/ecosystem/drizzle.md#_snippet_4

language: ts
code:
```
import { sqliteTable, text, integer } from "drizzle-orm/sqlite-core";

export const movies = sqliteTable("movies", {
  id: integer("id").primaryKey(),
  title: text("name"),
  releaseYear: integer("release_year"),
});
```

---

title: Executing Database Migrations Using Bun
description: Shows how to execute the `migrate.ts` script with Bun to apply the generated migrations to the SQLite database. This command updates the database schema based on the migration files.
source: docs/guides/ecosystem/drizzle.md#_snippet_8

language: sh
code:
```
$ bun run migrate.ts
```

---

title: Running the Seed Script with Bun
description: Demonstrates running the `seed.ts` script using Bun to populate the database with initial data. This command executes the data insertion logic defined in the script.
source: docs/guides/ecosystem/drizzle.md#_snippet_10

language: sh
code:
```
$ bun run seed.ts
Seeding complete.
```

---

title: Displaying Query Results with Bun
description: Demonstrates how to execute the `index.ts` file with Bun and display the results of the database query. This output shows the movie records retrieved from the database.
source: docs/guides/ecosystem/drizzle.md#_snippet_12

language: sh
code:
```
$ bun run index.ts
bun run index.ts
[
  {
    id: 1,
    title: "The Matrix",
    releaseYear: 1999
  }, {
    id: 2,
    title: "The Matrix Reloaded",
    releaseYear: 2003
  }, {
    id: 3,
    title: "The Matrix Revolutions",
    releaseYear: 2003
  }
]
```

---

title: Managing Systemd Service (Bash)
description: Provides a cheatsheet of common `systemctl` commands for managing a systemd service. These commands allow you to reload, enable, disable, start, stop, and restart the service.
source: docs/guides/ecosystem/systemd.md#_snippet_7

language: bash
code:
```
$ sudo systemctl daemon-reload # tell systemd that some files got changed
$ sudo systemctl enable my-app # enable the app (to allow auto-start)
$ sudo systemctl disable my-app # disable the app (turns off auto-start)
$ sudo systemctl start my-app # start the app if is stopped
$ sudo systemctl stop my-app # stop the app
$ sudo systemctl restart my-app # restart the app
```

---

title: Creating Typed Arrays From ArrayBuffer
description: Illustrates the creation of various typed arrays (`Uint8Array`, `Uint16Array`, `Uint32Array`, `Float32Array`, `Float64Array`, `BigInt64Array`, and `BigUint64Array`) from a single `ArrayBuffer`. Each typed array provides a different view of the underlying data in the buffer, interpreting it as different data types.
source: docs/guides/binary/arraybuffer-to-typedarray.md#_snippet_1

language: ts
code:
```
const buffer = new ArrayBuffer(64);

const arr1 = new Uint8Array(buffer);
const arr2 = new Uint16Array(buffer);
const arr3 = new Uint32Array(buffer);
const arr4 = new Float32Array(buffer);
const arr5 = new Float64Array(buffer);
const arr6 = new BigInt64Array(buffer);
const arr7 = new BigUint64Array(buffer);
```

---

title: Creating a ReadableStream From Uint8Array
description: Demonstrates the naive approach to creating a `ReadableStream` from a `Uint8Array` by enqueuing the entire array as a single chunk. This may be undesirable for larger arrays as it does not stream the data.
source: docs/guides/binary/typedarray-to-readablestream.md#_snippet_0

language: ts
code:
```
const arr = new Uint8Array(64);
const stream = new ReadableStream({
  start(controller) {
    controller.enqueue(arr);
    controller.close();
  },
});
```

---

title: Displaying Outdated Dependencies with Filters
description: Illustrates how to use the `--filter` flag with `bun outdated` to display outdated dependencies for specific packages in a monorepo.  The examples demonstrate filtering by package name and by root package directory.
source: docs/cli/filter.md#_snippet_1

language: bash
code:
```
# Display outdated dependencies for workspaces starting with `pkg-`
$ bun outdated --filter 'pkg-*'

# Display outdated dependencies for only the root package.json
$ bun outdated --filter './'
```

---

title: Running a Script in a Workspace Package Using Filters
description: Shows how to use `--filter` within a bun workspace to execute a script in a specific package without changing directories. It uses the package name to identify the target.
source: docs/cli/filter.md#_snippet_3

language: bash
code:
```
# in src/bar: runs myscript in src/foo, no need to cd!
bun run --filter foo myscript
```

---

title: Defining an EdgeDB Schema - Text
description: Shows how to define a basic schema in EdgeDB using the `default.esdl` file.  The example defines a `Movie` type with required `title` and optional `releaseYear` properties, demonstrating the declarative nature of EdgeDB's schema language.
source: docs/guides/ecosystem/edgedb.md#_snippet_4

language: txt
code:
```
module default {
  type Movie {
    required title: str;
    releaseYear: int64;
  }
};
```

---

title: Creating and Applying EdgeDB Migrations - Shell
description: Demonstrates how to create and apply database migrations in EdgeDB. The `edgedb migration create` command generates a new migration file based on schema changes, and the `edgedb migrate` command applies the migration to the database.
source: docs/guides/ecosystem/edgedb.md#_snippet_5

language: sh
code:
```
$ edgedb migration create
Created /Users/colinmcd94/Documents/bun/fun/examples/my-edgedb-app/dbschema/migrations/00001.edgeql, id: m1uwekrn4ni4qs7ul7hfar4xemm5kkxlpswolcoyqj3xdhweomwjrq
$ edgedb migrate
Applied m1uwekrn4ni4qs7ul7hfar4xemm5kkxlpswolcoyqj3xdhweomwjrq (00001.edgeql)
```

---

title: Generating EdgeQL Query Builder - Shell
description: Shows how to generate the EdgeQL query builder using `@edgedb/generate`. The generated code provides a type-safe way to construct EdgeQL queries in TypeScript. It also shows how to update `.gitignore` to exclude the generated directory.
source: docs/guides/ecosystem/edgedb.md#_snippet_9

language: sh
code:
```
$ bunx @edgedb/generate edgeql-js
Generating query builder...
Detected tsconfig.json, generating TypeScript files.
   To override this, use the --target flag.
   Run `npx @edgedb/generate --help` for full options.
Introspecting database schema...
Writing files to ./dbschema/edgeql-js
Generation complete! [U+1F918]
Checking the generated query builder into version control
is not recommended. Would you like to update .gitignore to ignore
the query builder directory? The following line will be added:

   dbschema/edgeql-js

[y/n] (leave blank for "y")
> y
```

---

title: Checking Installation Reasons for Specific Packages -Bash
description: Illustrates how to use `bun why` with a specific package name (`react`) to trace the dependency chain and identify which top-level package depends on it. This helps in understanding the direct dependencies of your project.
source: docs/cli/why.md#_snippet_1

language: bash
code:
```
$ bun why react
react@18.2.0
  â””â”€ my-app@1.0.0 (requires ^18.0.0)
```

---

title: Displaying Top-Level Dependencies -Bash
description: Illustrates the `--top` option, which restricts the `bun why` command to only show top-level dependencies. This simplifies the output by focusing only on the packages directly required by your project.
source: docs/cli/why.md#_snippet_3

language: bash
code:
```
$ bun why express --top
express@4.18.2
  â””â”€ my-app@1.0.0 (requires ^4.18.2)
```

---

title: Using the --bun Flag with Package Scripts
description: Explains how to use the `--bun` flag to execute Node.js-based CLIs with Bun instead of Node.js. The example shows a shebang in a JavaScript file and the `bun run --bun` command that overrides the shebang.
source: docs/cli/run.md#_snippet_2

language: javascript
code:
```
#!/usr/bin/env node

// do stuff
```

language: bash
code:
```
$ bun run --bun vite
```

---

title: Piping Code from Stdin Using bun run -
description: Demonstrates how to pipe code from stdin to `bun run -`, allowing for the execution of JavaScript, TypeScript, TSX, or JSX without creating temporary files. It treats all input as TypeScript with JSX support.
source: docs/cli/run.md#_snippet_3

language: bash
code:
```
$ echo "console.log('Hello')" | bun run -
```

language: bash
code:
```
$ echo "console.log!('This is TypeScript!' as any)" > secretly-typescript.js
$ bun run - < secretly-typescript.js
```

---

title: Saving a Linked Package as a Dependency
description: Demonstrates how to save a linked package as a dependency in the `package.json` file. Using the `--save` flag adds the linked package to the `dependencies` section with a special `link:` version specifier. This instructs Bun to load the package from the registered local directory instead of attempting to install it from a remote registry.
source: docs/cli/link.md#_snippet_2

language: json-diff
code:
```
  {
    "name": "my-app",
    "version": "1.0.0",
    "dependencies": {
+     "cool-pkg": "link:cool-pkg"
    }
  }
```

---

title: Handling Unhandled Errors in Asynchronous Code - TypeScript
description: Illustrates how `bun test` tracks unhandled promise rejections and errors that occur outside of test blocks. The test runner fails with a non-zero exit code if unhandled errors are detected, even if all tests pass, which is crucial for catching asynchronous errors that might otherwise be missed.
source: docs/test/runtime-behavior.md#_snippet_1

language: typescript
code:
```
import { test } from "bun:test";

test("test 1", () => {
  // This test passes
});

// This error happens outside any test
setTimeout(() => {
  throw new Error("Unhandled error");
}, 0);

test("test 2", () => {
  // This test also passes
});

// The test run will still fail with a non-zero exit code
// because of the unhandled error
```

---

title: Configuring Package Access During Publishing
description: Illustrates how to configure package access during publishing using the `--access` flag and the `publishConfig` field in `package.json`. The first example shows using the flag, while the second demonstrates setting the `access` property in `package.json`.
source: docs/cli/publish.md#_snippet_1

language: sh
code:
```
$ bun publish --access public
```

language: json
code:
```
{
  "publishConfig": {
    "access": "restricted"
  }
}
```

---

title: Setting Package Version Tag During Publishing
description: Demonstrates how to set the tag for the package version being published using the `--tag` flag and the `publishConfig` field in `package.json`. The first example shows using the flag, while the second demonstrates setting the `tag` property in `package.json`.
source: docs/cli/publish.md#_snippet_2

language: sh
code:
```
$ bun publish --tag alpha
```

language: json
code:
```
{
  "publishConfig": {
    "tag": "next"
  }
}
```

---

title: Defining a Database Schema with Drizzle ORM
description: Demonstrates defining a database schema using Drizzle ORM's schema definition primitives. It imports functions like `pgTable`, `integer`, `serial`, `text`, and `timestamp` from `drizzle-orm/pg-core` and defines a table named `authors` with columns for `id`, `name`, `bio`, and `createdAt`.
source: docs/guides/ecosystem/neon-drizzle.md#_snippet_5

language: ts
code:
```
import { pgTable, integer, serial, text, timestamp } from "drizzle-orm/pg-core";

export const authors = pgTable("authors", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  bio: text("bio"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
});
```

---

title: Generating an Initial SQL Migration
description: Shows how to use the `drizzle-kit` CLI to generate an initial SQL migration based on the defined schema. The command specifies the PostgreSQL dialect, schema file, and output directory.
source: docs/guides/ecosystem/neon-drizzle.md#_snippet_6

language: sh
code:
```
$ bunx drizzle-kit generate --dialect postgresql --schema ./schema.ts --out ./drizzle
```

---

title: Running Database Migrations
description: Demonstrates how to apply database migrations using the `migrate` function from `drizzle-orm/neon-http/migrator`.  It imports the database instance and the `migrate` function, then executes the migrations found in the specified `drizzle` directory.
source: docs/guides/ecosystem/neon-drizzle.md#_snippet_8

language: ts
code:
```
import { db } from './db';
import { migrate } from "drizzle-orm/neon-http/migrator";

const main = async () => {
  try {
    await migrate(db, { migrationsFolder: "drizzle" });
    console.log("Migration completed");
  } catch (error) {
    console.error("Error during migration:", error);
    process.exit(1);
  }
};

main();
```

---

title: Executing the Migration Script
description: Shows how to execute the `migrate.ts` script using `bun run`.  The output confirms successful completion of the database migration.
source: docs/guides/ecosystem/neon-drizzle.md#_snippet_9

language: sh
code:
```
$ bun run migrate.ts
Migration completed
```

---

title: Overwriting Existing Files - CLI
description: Demonstrates the use of the `--force` CLI flag. This flag is used with `bun create` to overwrite existing files in the destination directory, bypassing the default warning and exit behavior when file conflicts are detected.
source: docs/cli/bun-create.md#_snippet_1

language: shell
code:
```
`bun create ${template} ${destination} --force`
```

---

title: Skipping Installation with --no-install - CLI
description: Illustrates how to skip the `node_modules` installation and task execution using the `--no-install` flag with `bun create`. This is useful when you want to quickly scaffold a project without immediately installing dependencies.
source: docs/cli/bun-create.md#_snippet_2

language: shell
code:
```
`bun create ${template} ${destination} --no-install`
```

---

title: Omitting Git Initialization Using --no-git - CLI
description: Demonstrates the `--no-git` flag used with the `bun create` command. This prevents `bun create` from initializing a Git repository in the destination directory, useful when Git management is handled separately.
source: docs/cli/bun-create.md#_snippet_3

language: shell
code:
```
`bun create ${template} ${destination} --no-git`
```

---

title: Opening in Browser After Creation Using --open - CLI
description: Demonstrates the usage of `--open` CLI flag. It instructs `bun create` to start the application and open it in a web browser after finishing the creation process, facilitating immediate testing and development.
source: docs/cli/bun-create.md#_snippet_4

language: shell
code:
```
`bun create ${template} ${destination} --open`
```

---

title: Defining Package Executables (package.json)
description: Illustrates how to define package executables in the `package.json` file using the `bin` field. This allows running scripts directly from the command line using `bunx`.
source: docs/cli/bunx.md#_snippet_1

language: jsonc
code:
```
{
  // ... other fields
  "name": "my-cli",
  "bin": {
    "my-cli": "dist/index.js"
  }
}
```

---

title: Creating Executable JavaScript File with Shebang
description: Shows how to create a plain JavaScript file marked with a shebang line to specify the interpreter. This example indicates that the file should be executed with `node`.
source: docs/cli/bunx.md#_snippet_2

language: js
code:
```
#!/usr/bin/env node

console.log("Hello world!");
```

---

title: Running a Defined Executable with Bunx
description: Illustrates how to execute a defined executable using `bunx`. `bunx` checks for a locally installed package first, then falls back to auto-installing from `npm`.
source: docs/cli/bunx.md#_snippet_3

language: bash
code:
```
$ bunx my-cli
```

---

title: Passing Arguments to Executables Using Bunx
description: Demonstrates how to pass additional command-line flags and arguments to the executable. These arguments are placed after the executable name.
source: docs/cli/bunx.md#_snippet_4

language: bash
code:
```
$ bunx my-cli --foo bar
```

---

title: Specifying Bun with Shebang
description: Demonstrates how to force the use of Bun with a script by using the `#!/usr/bin/env bun` shebang.
source: docs/cli/bunx.md#_snippet_6

language: text
code:
```
#!/usr/bin/env bun
```

---

title: Formatting Output as JSON Using Bun Info
description: Illustrates how to use the `--json` flag with `bun info` to format the output in JSON. This is useful when the output needs to be parsed by other tools or scripts.
source: docs/cli/info.md#_snippet_3

language: bash
code:
```
$ bun info react --json
```

---

title: Testing Errors with Inline Snapshots in Bun
description: Demonstrates how to snapshot error messages using `.toThrowErrorMatchingSnapshot()` and `.toThrowErrorMatchingInlineSnapshot()` in Bun. This allows you to ensure that error messages remain consistent across test runs by storing the expected error message as a snapshot.
source: docs/test/snapshots.md#_snippet_3

language: ts
code:
```
import { test, expect } from "bun:test";

test("error snapshot", () => {
  expect(() => {
    throw new Error("Something went wrong");
  }).toThrowErrorMatchingSnapshot();

  expect(() => {
    throw new Error("Another error");
  }).toThrowErrorMatchingInlineSnapshot();
});
```

---

title: Filtering Tests by Name Using a Regex Pattern - Bash
description: Demonstrates filtering tests by name using the `--test-name-pattern` flag with `bun test`. The pattern is matched against a concatenated string of the test name prepended with the labels of all its parent describe blocks, separated by spaces. This is useful for running tests that match a specific feature or functionality.
source: docs/test/discovery.md#_snippet_2

language: sh
code:
```
# run all tests with "addition" in the name
$ bun test --test-name-pattern addition
```

language: javascript
code:
```
describe("Math", () => {
  describe("operations", () => {
    test("should add correctly", () => {
      // ...
    });
  });
});
```

---

title: Ensuring Vitest Compatibility - Bun
description: Demonstrates how Bun provides compatibility with Vitest using the `vi` global object as an alias for Jest mocking APIs. This allows developers familiar with Vitest to use similar mocking functions within the Bun testing environment, such as `vi.fn`, `vi.spyOn`, and `vi.mock`.
source: docs/test/mocks.md#_snippet_1

language: ts
code:
```
import { test, expect } from "bun:test";

// Using the 'vi' alias similar to Vitest
test("vitest compatibility", () => {
  const mockFn = vi.fn(() => 42);

  mockFn();
  expect(mockFn).toHaveBeenCalled();

  // The following functions are available on the vi object:
  // vi.fn
  // vi.spyOn
  // vi.mock
  // vi.restoreAllMocks
  // vi.clearAllMocks
});
```

---

title: Configuring TailwindCSS with Bun
description: Illustrates how `bun create` automatically configures TailwindCSS when it detects TailwindCSS class names in JSX/TSX files. It adds the `tailwindcss` and `bun-plugin-tailwind` dependencies to `package.json`, configures `bunfig.toml` to use the TailwindCSS plugin, and creates a CSS file with the `@import "tailwindcss";` directive.
source: docs/cli/bun-create.md#_snippet_1

language: json
code:
```
{
  "dependencies": {
    "tailwindcss": "^4",
    "bun-plugin-tailwind": "latest"
  }
}
```

language: toml
code:
```
[serve.static]
plugins = ["bun-plugin-tailwind"]
```

language: css
code:
```
@import "tailwindcss";
```

---

title: Adding shadcn/ui Components
description: Explains how `bun create` integrates with `shadcn/ui`.  If `bun create` detects shadcn/ui components, it automatically runs `bunx shadcn@canary add` to add them, configures `tsconfig.json` for path aliases, creates a `components.json` file, and sets up a `styles/globals.css` file for Tailwind v4.
source: docs/cli/bun-create.md#_snippet_2

language: bash
code:
```
# Assuming bun detected imports to @/components/ui/accordion and @/components/ui/button
$ bunx shadcn@canary add accordion button # and any other components
```

---

title: Adding a Development Dependency Using Bun
description: Illustrates how to add a package as a development dependency using the `--dev` flag with the `bun add` command. Development dependencies are used for tasks like testing, building, or documentation generation.
source: docs/cli/add.md#_snippet_2

language: bash
code:
```
$ bun add --dev @types/react
$ bun add -d @types/react
```

---

title: Pinning Package Version with Exact Flag in Bun
description: Demonstrates how to add a package and pin it to the resolved version using the `--exact` flag with the `bun add` command. This ensures that the exact specified version is installed, rather than a version range.
source: docs/cli/add.md#_snippet_5

language: bash
code:
```
$ bun add react --exact
$ bun add react -E
```

language: jsonc
code:
```
{
  "dependencies": {
    // without --exact
    "react": "^18.2.0", // this matches >= 18.2.0 < 19.0.0

    // with --exact
    "react": "18.2.0", // this matches only 18.2.0 exactly
  },
}
```

---

title: Specifying Git Dependencies in package.json
description: Demonstrates various formats for specifying Git dependencies in the `package.json` file. This showcases different protocols and ways to reference specific commits or tags.
source: docs/cli/add.md#_snippet_10

language: json
code:
```
{
  "dependencies": {
    "dayjs": "git+https://github.com/iamkun/dayjs.git",
    "lodash": "git+ssh://github.com/lodash/lodash.git#4.17.21",
    "moment": "git@github.com:moment/moment.git",
    "zod": "github:colinhacks/zod"
  }
}
```

---

title: Installing Tarball Dependencies Using Bun
description: Illustrates how to add a dependency from a publicly hosted `.tgz` file using the `bun add` command. Bun will download and install the package from the specified tarball URL.
source: docs/cli/add.md#_snippet_11

language: sh
code:
```
$ bun add zod@https://registry.npmjs.org/zod/-/zod-3.21.4.tgz
```

language: json
code:
```
{
  "dependencies": {
    "zod": "https://registry.npmjs.org/zod/-/zod-3.21.4.tgz"
  }
}
```

---

title: Specifying Package Version in Import Statement
description: Illustrates how to specify a specific version, npm tag, or semver range directly within the import statement using the `package@version` syntax. This allows developers to short-circuit Bun's default version resolution algorithm and use a specific version of a package.
source: docs/runtime/autoimport.md#_snippet_1

language: ts
code:
```
import { z } from "zod@3.0.0"; // specific version
import { z } from "zod@next"; // npm tag
import { z } from "zod@^3.20.0"; // semver range
```

---

title: Referencing DOM Library - TypeScript
description: Illustrates how to resolve the TypeScript error 'Cannot find name `document`' by adding a triple-slash directive referencing the `dom` library. This directive injects the types for `document` and other browser APIs into the test file, enabling TypeScript to recognize them.
source: docs/test/dom.md#_snippet_3

language: ts-diff
code:
```
+ /// <reference lib="dom" />

  import {test, expect} from 'bun:test';

  test('dom test', () => {
    document.body.innerHTML = `<button>My button</button>`;
    const button = document.querySelector('button');
    expect(button?.innerText).toEqual('My button');
  });
```

---

title: Configuring Installation Scopes with BunfigToml
description: Demonstrates how to configure scoped packages using the `bunfig.toml` file. The `install.scopes` section allows specifying registry URLs and authentication tokens for different scopes, enabling the use of private or custom registries. Environment variables can also be used to define tokens, providing flexibility in configuration.
source: docs/cli/bun-install.md#_snippet_0

language: toml
code:
```
# Using scoped packages with bun install
[install.scopes]

# Scope name      The value can be a URL string or an object
"@mybigcompany" = { token = "123456", url = "https://registry.mybigcompany.com" }
# URL is optional and falls back to the default registry

# The "@" in the scope is optional
mybigcompany2 = { token = "123456" }

# Environment variables can be referenced as a string that starts with $ and it will be replaced
mybigcompany3 = { token = "$npm_config_token" }

# Setting username and password turns it into a Basic Auth header by taking base64("username:password")
mybigcompany4 = { username = "myusername", password = "$npm_config_password", url = "https://registry.yarnpkg.com/" }
# You can set username and password in the registry URL. This is the same as above.
mybigcompany5 = "https://username:password@registry.yarnpkg.com/"

# You can set a token for a registry URL:
mybigcompany6 = "https://:$NPM_CONFIG_TOKEN@registry.yarnpkg.com/"

[install]
# Default registry
# can be a URL string or an object
registry = "https://registry.yarnpkg.com/"
# as an object
#registry = { url = "https://registry.yarnpkg.com", token = "123456" }

# Install for production? This is the equivalent to the "--production" CLI argument
production = false

# Save a text-based lockfile? This is equivalent to the "--save-text-lockfile" CLI argument
saveTextLockfile = false

# Disallow changes to lockfile? This is the equivalent to the "--frozen-lockfile" CLI argument
frozenLockfile = false

# Don't actually install
dryRun = true

# Install optionalDependencies (default: true)
# Setting this to false is equivalent to the `--omit=optional` CLI argument
optional = true

# Install local devDependencies (default: true)
# Setting this to false is equivalent to the `--omit=dev` CLI argument
dev = true

# Install peerDependencies (default: true)
# Setting this to false is equivalent to the `--omit=peer` CLI argument
peer = true

# Max number of concurrent lifecycle scripts (default: (cpu count or GOMAXPROCS) x2)
concurrentScripts = 16

# When using `bun install -g`, install packages here
globalDir = "~/.bun/install/global"

# When using `bun install -g`, link package bins here
globalBinDir = "~/.bun/bin"

# cache-related configuration
[install.cache]
# The directory to use for the cache
dir = "~/.bun/install/cache"

# Don't load from the global cache.
# Note: Bun may still write to node_modules/.cache
disable = false


# Always resolve the latest versions from the registry
disableManifest = false


# Lockfile-related configuration
[install.lockfile]

# Print a yarn v1 lockfile
# Note: it does not load the lockfile, it just converts bun.lock into a yarn.lock
print = "yarn"

# Save the lockfile to disk
save = true

```

---

title: Scoping Hooks to an Entire Test Run - Bun
description: Demonstrates how to scope `beforeAll` and `afterAll` hooks to an entire multi-file test run by defining them in a separate file (`setup.ts`) and preloading it using the `--preload` flag. This is useful for global setup and teardown operations that affect all tests.
source: docs/test/lifecycle.md#_snippet_3

language: typescript
code:
```
import { beforeAll, afterAll } from "bun:test";

beforeAll(() => {
  // global setup
});

afterAll(() => {
  // global teardown
});
```

language: shell
code:
```
$ bun test --preload ./setup.ts
```

---

title: Accessing Mock Properties and Call History
description: Demonstrates how to access properties of a mock function created with `mock` to inspect its call history and results. The example shows how to use `random.mock.calls` to inspect arguments and `random.mock.results` to see return values.
source: docs/test/mocks.md#_snippet_2

language: typescript
code:
```
import { mock } from "bun:test";
const random = mock((multiplier: number) => multiplier * Math.random());

random(2);
random(10);

random.mock.calls;
// [[ 2 ], [ 10 ]]

random.mock.results;
//  [
//    { type: "return", value: 0.6533907460954099 },
//    { type: "return", value: 0.6452713933037312 }
//  ]
```

---

title: Tracking Function Calls with `spyOn`
description: Illustrates how to use `spyOn` to track calls to a function without replacing it with a mock.  The `spyOn` function creates a spy that can be used with `.toHaveBeenCalled()` and `.toHaveBeenCalledTimes()` to verify the number of calls.
source: docs/test/mocks.md#_snippet_3

language: typescript
code:
```
import { test, expect, spyOn } from "bun:test";

const ringo = {
  name: "Ringo",
  sayHi() {
    console.log(`Hello I'm ${this.name}`);
  },
};

const spy = spyOn(ringo, "sayHi");

test("spyon", () => {
  expect(spy).toHaveBeenCalledTimes(0);
  ringo.sayHi();
  expect(spy).toHaveBeenCalledTimes(1);
});
```

---

title: Overriding Modules with `mock.module`
description: Demonstrates how to use `mock.module` to override the behavior of a module.  The mocked module will be used for both `import` and `require` statements.
source: docs/test/mocks.md#_snippet_4

language: typescript
code:
```
import { test, expect, mock } from "bun:test";

mock.module("./module", () => {
  return {
    foo: "bar",
  };
});

test("mock.module", async () => {
  const esm = await import("./module");
  expect(esm.foo).toBe("bar");

  const cjs = require("./module");
  expect(cjs.foo).toBe("bar");
});
```

---

title: Overriding Already Imported Modules
description: Demonstrates that `mock.module` overrides modules even after they've been imported. The example shows how live bindings are updated when a module is mocked after its initial import.
source: docs/test/mocks.md#_snippet_5

language: typescript
code:
```
import { test, expect, mock } from "bun:test";

// The module we're going to mock is here:
import { foo } from "./module";

test("mock.module", async () => {
  const cjs = require("./module");
  expect(foo).toBe("bar");
  expect(cjs.foo).toBe("bar");

  // We update it here:
  mock.module("./module", () => {
    return {
      foo: "baz",
    };
  });

  // And the live bindings are updated.
  expect(foo).toBe("baz");

  // The module is also updated for CJS.
  expect(cjs.foo).toBe("baz");
});
```

---

title: Clearing All Mocks with `mock.clearAllMocks`
description: Demonstrates how to use `mock.clearAllMocks()` to reset the call history for all mock functions without restoring their original implementations. This is useful for cleaning up mock state between tests.
source: docs/test/mocks.md#_snippet_6

language: typescript
code:
```
import { expect, mock, test } from "bun:test";

const random1 = mock(() => Math.random());
const random2 = mock(() => Math.random());

test("clearing all mocks", () => {
  random1();
  random2();

  expect(random1).toHaveBeenCalledTimes(1);
  expect(random2).toHaveBeenCalledTimes(1);

  mock.clearAllMocks();

  expect(random1).toHaveBeenCalledTimes(0);
  expect(random2).toHaveBeenCalledTimes(0);

  // Note: implementations are preserved
  expect(typeof random1()).toBe("number");
  expect(typeof random2()).toBe("number");
});
```

---

title: Customizing Stack Traces with ErrorprepareStackTrace - TypeScript
description: Demonstrates how to customize stack trace output using the `Error.prepareStackTrace` function. This function is called with the error object and an array of `CallSite` objects, allowing for a custom stack trace to be returned. It's useful for modifying the default stack trace format.
source: docs/runtime/debugger.md#_snippet_0

language: ts
code:
```
Error.prepareStackTrace = (err, stack) => {
  return stack.map(callSite => {
    return callSite.getFileName();
  });
};

const err = new Error("Something went wrong");
console.log(err.stack);
// [ "error.js" ]
```

---

title: Capturing Stack Traces with ErrorcaptureStackTrace - TypeScript
description: Illustrates how to capture a stack trace at a specific point in the code using `Error.captureStackTrace`. This is helpful when debugging asynchronous code or callbacks where the error origin is unclear. The example shows how to make `err.stack` point to the code calling `fn()` even though the error was thrown in `myInner`.
source: docs/runtime/debugger.md#_snippet_1

language: ts
code:
```
const fn = () => {
  function myInner() {
    throw err;
  }

  try {
    myInner();
  } catch (err) {
    console.log(err.stack);
    console.log("");
    console.log("-- captureStackTrace --");
    console.log("");
    Error.captureStackTrace(err, fn);
    console.log(err.stack);
  }
};

fn();
```

---

title: Importing Text Files as Strings-TS
description: Illustrates how to import a `.txt` file as a string in a TypeScript file. This is useful for loading configuration files or other text-based data directly into your application. The content of `text.txt` is then printed to the console.
source: docs/runtime/loaders.md#_snippet_1

language: ts
code:
```
import text from "./text.txt";
console.log(text);
// => "Hello world!"
```

language: txt
code:
```
Hello world!
```

---

title: Importing JSON and TOML Files-TS
description: Demonstrates how to directly import `.json` and `.toml` files into a TypeScript file. Bun automatically parses these files and returns their contents as JavaScript objects. This is useful for loading configuration data or other structured data into your application.
source: docs/runtime/loaders.md#_snippet_2

language: ts
code:
```
import pkg from "./package.json";
import data from "./data.toml";
```

---

title: Importing and Querying SQLite Databases-TS
description: Illustrates how to import an SQLite database directly into a TypeScript file and query it.  The database is automatically loaded and returned as a `Database` object. This allows you to directly access and manipulate SQLite databases within your Bun application using `bun:sqlite`.
source: docs/runtime/loaders.md#_snippet_4

language: ts
code:
```
import db from "./my.db" with { type: "sqlite" };
console.log(db.query("select * from users LIMIT 1").get());
```

---

title: Filtering Tests with Filters
description: Illustrates how to filter tests using positional arguments with `bun test`.  Passing `<filter>` arguments limits the test runner to only execute files whose paths match the given filters. Glob patterns are not yet supported.
source: docs/cli/test.md#_snippet_1

language: bash
code:
```
$ bun test <filter> <filter> ...
```

---

title: Filtering Tests by Test Name
description: Demonstrates how to filter tests by name using the `-t` or `--test-name-pattern` flag with `bun test`. This allows you to run all tests or test suites that include a specific pattern in their name.
source: docs/cli/test.md#_snippet_2

language: sh
code:
```
# run all tests or test suites with "addition" in the name
$ bun test --test-name-pattern addition
```

---

title: Running Specific Test Files
description: Illustrates running a specific test file with `bun test` by providing a path that starts with `./` or `/`.  This distinguishes the argument from a filter name, ensuring only the specified file is executed.
source: docs/cli/test.md#_snippet_3

language: bash
code:
```
$ bun test ./test/specific-file.test.ts
```

---

title: Generating JUnit XML Reports
description: Demonstrates how to generate JUnit XML reports using `bun test` with the `--reporter=junit` and `--reporter-outfile` flags. This allows integration with CI/CD pipelines that use JUnit XML for test reporting.
source: docs/cli/test.md#_snippet_5

language: sh
code:
```
$ bun test --reporter=junit --reporter-outfile=./bun.xml
```

---

title: Using Watch Mode for Automatic Re-Running
description: Illustrates how to use watch mode with `bun test` by passing the `--watch` flag.  This automatically re-runs tests when changes are detected in the project.
source: docs/cli/test.md#_snippet_9

language: bash
code:
```
$ bun test --watch
```

---

title: Creating Mock Functions
description: Shows how to create mock functions using the `mock` function from `bun:test`. Mocks are automatically reset between tests.  This allows you to isolate and test specific parts of your code.
source: docs/cli/test.md#_snippet_11

language: typescript
code:
```
import { test, expect, mock } from "bun:test";
const random = mock(() => Math.random());

test("random", () => {
  const val = random();
  expect(val).toBeGreaterThan(0);
  expect(random).toHaveBeenCalled();
  expect(random).toHaveBeenCalledTimes(1);
});
```

---

title: Creating Mock Functions with Jest Fn
description: Demonstrates creating mock functions using `jest.fn()` from `bun:test`, which behaves identically to `mock()`. The snippet shows how to replace `mock` with `jest.fn` while achieving the same result.
source: docs/cli/test.md#_snippet_12

language: diff
code:
```
- import { test, expect, mock } from "bun:test";
+ import { test, expect, jest } from "bun:test";

- const random = mock(() => Math.random());
+ const random = jest.fn(() => Math.random());
```

---

title: Using Snapshot Testing
description: Illustrates how to use snapshot testing with `bun test` to ensure UI components or data structures don't change unexpectedly. The `toMatchSnapshot()` method compares the current value with a previously stored snapshot.
source: docs/cli/test.md#_snippet_13

language: typescript
code:
```
// example usage of toMatchSnapshot
import { test, expect } from "bun:test";

test("snapshot", () => {
  expect({ a: 1 }).toMatchSnapshot();
});
```

---

title: Resetting System Time - TypeScript
description: Demonstrates how to reset the mocked system time in `bun:test` back to the real system time. Calling `setSystemTime()` without any arguments reverts the mocked time to the current system time, allowing subsequent tests to use the actual time.
source: docs/test/time.md#_snippet_2

language: typescript
code:
```
import { setSystemTime, expect, test } from "bun:test";

test("it was 2020, for a moment.", () => {
  // Set it to something!
  setSystemTime(new Date("2020-01-01T00:00:00.000Z"));
  expect(new Date().getFullYear()).toBe(2020);

  // reset it!
  setSystemTime();

  expect(new Date().getFullYear()).toBeGreaterThan(2020);
});
```

---

title: Getting Mocked Time with Jest Now - TypeScript
description: Illustrates how to retrieve the current mocked timestamp when using fake timers in `bun:test` with `jest.now()`. This function provides direct access to the mocked time value without needing to create a new `Date` object, ensuring consistency when performing time-sensitive assertions.
source: docs/test/time.md#_snippet_3

language: typescript
code:
```
import { test, expect, jest } from "bun:test";

test("get the current mocked time", () => {
  jest.useFakeTimers();
  jest.setSystemTime(new Date("2020-01-01T00:00:00.000Z"));

  expect(Date.now()).toBe(1577836800000); // Jan 1, 2020 timestamp
  expect(jest.now()).toBe(1577836800000); // Same value

  jest.useRealTimers();
});
```

---

title: Setting the Time Zone - TypeScript
description: Demonstrates how to set the time zone for `bun test` runs using the `$TZ` environment variable or `process.env.TZ`. This allows tests to simulate different time zones, influencing the results of functions like `new Date().getTimezoneOffset()` and `new Intl.DateTimeFormat().resolvedOptions().timeZone`.
source: docs/test/time.md#_snippet_4

language: typescript
code:
```
import { test, expect } from "bun:test";

test("Welcome to California!", () => {
  process.env.TZ = "America/Los_Angeles";
  expect(new Date().getTimezoneOffset()).toBe(420);
  expect(new Intl.DateTimeFormat().resolvedOptions().timeZone).toBe(
    "America/Los_Angeles",
  );
});

test("Welcome to New York!", () => {
  // Unlike in Jest, you can set the timezone multiple times at runtime and it will work.
  process.env.TZ = "America/New_York";
  expect(new Date().getTimezoneOffset()).toBe(240);
  expect(new Intl.DateTimeFormat().resolvedOptions().timeZone).toBe(
    "America/New_York",
  );
});
```

---

title: Generating an Lcov Report - Configuration
description: Demonstrates how to generate an lcov report by setting the `coverageReporter` option to `lcov` in `bunfig.toml`. This generates an `lcov.info` file in the `coverage` directory, which can be used for detailed code coverage analysis.
source: docs/test/coverage.md#_snippet_8

language: toml
code:
```
[test]
coverageReporter = "lcov"
```

---

title: Modifying Logging Verbosity - Bash
description: Illustrates how to control the logging verbosity of the `bun install` command. The `--verbose` flag enables debug logging, while the `--silent` flag disables all logging output.
source: docs/cli/install.md#_snippet_1

language: bash
code:
```
$ bun install --verbose # debug logging
$ bun install --silent  # no logging
```

---

title: Installing Global Packages - Bash
description: Shows how to install a package globally using the `-g` or `--global` flag with `bun install`. This is typically used for installing command-line tools that you want to access from anywhere in your system.
source: docs/cli/install.md#_snippet_7

language: bash
code:
```
$ bun install --global cowsay # or `bun install -g cowsay`
$ cowsay "Bun!"
```

---

title: Importing JSON and TOML - JavaScript/TypeScript
description: Illustrates how to import `*.json` and `*.toml` files directly into JavaScript or TypeScript code. This allows you to load configuration data or other structured information as plain JavaScript objects, improving code readability and maintainability.
source: docs/runtime/index.md#_snippet_1

language: typescript
code:
```
import pkg from "./package.json";
import bunfig from "./bunfig.toml";
```

---

title: Specifying Conditions for Package Resolution - CLI
description: Demonstrates how to use the `--conditions` flag with `bun build` and Bun's runtime to specify a list of conditions for resolving packages from the `package.json`'s `exports` field. This allows you to target specific environments or features during the build or runtime execution.
source: docs/runtime/modules.md#_snippet_0

language: shell
code:
```
# Use it with bun build:
$ bun build --conditions="react-server" --target=bun ./app/foo/route.js

# Use it with bun's runtime:
$ bun --conditions="react-server" ./app/foo/route.js
```

---

title: Specifying Conditions for Package Resolution - BunBuild API
description: Illustrates how to use the `conditions` option with `Bun.build` to programmatically specify conditions for package resolution. This allows for dynamic configuration of the build process based on specific conditions.
source: docs/runtime/modules.md#_snippet_1

language: javascript
code:
```
await Bun.build({
  conditions: ["react-server"],
  target: "bun",
  entryPoints: ["./app/foo/route.js"],
});
```

---

title: Remapping Import Paths with Paths Configuration - tsconfig
description: Demonstrates how the Bun runtime remaps import paths using the `compilerOptions.paths` field in `tsconfig.json`.  This allows for cleaner and more maintainable code by abstracting away the physical location of modules.
source: docs/runtime/modules.md#_snippet_2

language: jsonc
code:
```
{
  "compilerOptions": {
    "paths": {
      "config": ["./config.ts"],         // map specifier to file
      "components/*": ["components/*"],  // wildcard matching
    }
  }
}
```

---

title: Using Lines on a Completed Command - JavaScript
description: Demonstrates using `.lines()` on a completed command, allowing you to iterate over the output of a shell command line by line. This snippet combines `cat` and `grep` to search for a specific string in a file and prints each matching line.
source: docs/runtime/shell.md#_snippet_2

language: javascript
code:
```
import { $ } from "bun";

const search = "bun";

for await (let line of $`cat list.txt | grep ${search}`.lines()) {
  console.log(line);
}
```

---

title: Reading Output as a Blob - JavaScript
description: Demonstrates how to read the output of a shell command as a Blob using the `.blob()` method in Bun. This is useful when you need to handle the output as binary data or work with it as a file-like object.
source: docs/runtime/shell.md#_snippet_3

language: javascript
code:
```
import { $ } from "bun";

const result = await $`echo "Hello World!"`.blob();

console.log(result); // Blob(13) { size: 13, type: "text/plain" }
```

---

title: Packing a Package in Quiet Mode
description: Illustrates how to use the `--quiet` flag with `bun pm pack` to suppress verbose output, making it suitable for scripting and automation.  The example captures the generated tarball filename for further processing.
source: docs/cli/pm.md#_snippet_1

language: bash
code:
```
$ TARBALL=$(bun pm pack --quiet)
$ echo "Created: $TARBALL"
# Output: Created: my-package-1.0.0.tgz
```

---

title: Packing a Package to a Custom Destination
description: Shows how to use the `--destination` option with `bun pm pack` to specify the directory where the tarball will be saved. This allows for organizing build outputs into specific directories.
source: docs/cli/pm.md#_snippet_2

language: bash
code:
```
$ bun pm pack --destination ./dist
# Saves tarball in ./dist/ directory
```

---

title: Printing the Local Project's Bin Directory
description: Demonstrates how to use `bun pm bin` to print the path to the `bin` directory for the current project. This directory typically contains executable scripts installed by the project's dependencies.
source: docs/cli/pm.md#_snippet_3

language: bash
code:
```
$ bun pm bin
/path/to/current/project/node_modules/.bin
```

---

title: Printing the Global Bin Directory
description: Shows how to use the `-g` flag with `bun pm bin` to print the path to the global `bin` directory. This directory contains globally installed executable scripts.
source: docs/cli/pm.md#_snippet_4

language: bash
code:
```
$ bun pm bin -g
<$HOME>/.bun/bin
```

---

title: Listing Installed Dependencies
description: Demonstrates how to use `bun pm ls` to print a list of installed dependencies in the current project and their resolved versions. The output excludes nth-order dependencies by default.
source: docs/cli/pm.md#_snippet_5

language: bash
code:
```
$ bun pm ls
/path/to/project node_modules (135)
â”œâ”€â”€ eslint@8.38.0
â”œâ”€â”€ react@18.2.0
â”œâ”€â”€ react-dom@18.2.0
â”œâ”€â”€ typescript@5.0.4
â””â”€â”€ zod@3.21.4
```

---

title: Listing All Dependencies Including nth-Order
description: Illustrates how to use the `--all` flag with `bun pm ls` to print all installed dependencies, including nth-order dependencies. This provides a complete view of the dependency tree.
source: docs/cli/pm.md#_snippet_6

language: bash
code:
```
$ bun pm ls --all
/path/to/project node_modules (135)
â”œâ”€â”€ @eslint-community/eslint-utils@4.4.0
â”œâ”€â”€ @eslint-community/regexpp@4.5.0
â”œâ”€â”€ @eslint/eslintrc@2.0.2
â”œâ”€â”€ @eslint/js@8.38.0
â”œâ”€â”€ @nodelib/fs.scandir@2.1.5
â”œâ”€â”€ @nodelib/fs.stat@2.0.5
â”œâ”€â”€ @nodelib/fs.walk@1.2.8
â”œâ”€â”€ acorn@8.8.2
â”œâ”€â”€ acorn-jsx@5.3.2
â”œâ”€â”€ ajv@6.12.6
â”œâ”€â”€ ansi-regex@5.0.1
â”œâ”€â”€ ...
```

---

title: Running the whoami Command
description: Demonstrates how to use `bun pm whoami` to print your npm username. It requires that you are logged in with credentials in either `bunfig.toml` or `.npmrc`.
source: docs/cli/pm.md#_snippet_7

language: bash
code:
```
$ bun pm whoami
```

---

title: Generating the Lockfile Hash
description: Demonstrates how to generate and print the hash of the current lockfile using `bun pm hash`. This can be used to verify the integrity of the lockfile.
source: docs/cli/pm.md#_snippet_8

language: bash
code:
```
$ bun pm hash
```

---

title: Printing the String Used to Hash the Lockfile
description: Shows how to print the string used to hash the lockfile using `bun pm hash-string`.  This can be useful for debugging or understanding the hashing process.
source: docs/cli/pm.md#_snippet_9

language: bash
code:
```
$ bun pm hash-string
```

---

title: Printing the Stored Lockfile Hash
description: Illustrates how to print the hash stored in the current lockfile using `bun pm hash-print`.  This allows you to compare the current hash with a known good hash to detect changes.
source: docs/cli/pm.md#_snippet_10

language: bash
code:
```
$ bun pm hash-print
```

---

title: Printing Bun's Global Module Cache Path
description: Demonstrates how to print the path to Bun's global module cache using `bun pm cache`. This cache stores downloaded packages to speed up subsequent installations.
source: docs/cli/pm.md#_snippet_11

language: bash
code:
```
$ bun pm cache
```

---

title: Clearing Bun's Global Module Cache
description: Illustrates how to clear Bun's global module cache using `bun pm cache rm`. This can be useful for resolving issues related to corrupted or outdated cached packages.
source: docs/cli/pm.md#_snippet_12

language: bash
code:
```
$ bun pm cache rm
```

---

title: Migrating Lockfiles from Other Package Managers
description: Demonstrates how to use `bun pm migrate` to migrate another package manager's lockfile.  This command is intended to convert the lockfile without immediately installing any packages.
source: docs/cli/pm.md#_snippet_13

language: bash
code:
```
$ bun pm migrate
```

---

title: Printing Untrusted Dependencies with Scripts
description: Demonstrates how to print current untrusted dependencies with scripts using `bun pm untrusted`. This allows you to identify which dependencies have lifecycle scripts that were blocked during installation.
source: docs/cli/pm.md#_snippet_14

language: bash
code:
```
$ bun pm untrusted

./node_modules/@biomejs/biome @1.8.3
 Â» [postinstall]: node scripts/postinstall.js

These dependencies had their lifecycle scripts blocked during install.
```

---

title: Trusting Untrusted Dependencies
description: Demonstrates how to run scripts for untrusted dependencies and add them to `trustedDependencies` using `bun pm trust <names>`. This allows you to explicitly trust specific dependencies.
source: docs/cli/pm.md#_snippet_15

language: bash
code:
```
$ bun pm trust <names>
```

---

title: Printing the Default Trusted Dependencies List
description: Shows how to print the default trusted dependencies list using `bun pm default-trusted`.  This displays the list of dependencies that are trusted by default.
source: docs/cli/pm.md#_snippet_16

language: bash
code:
```
$ bun pm default-trusted
```

---

title: Displaying Package Version and Help
description: Demonstrates how to display the current package version and help information using `bun pm version`. This provides information on incrementing the version and available options.
source: docs/cli/pm.md#_snippet_17

language: bash
code:
```
$ bun pm version
bun pm version v$BUN_LATEST_VERSION (ca7428e9)
Current package version: v1.0.0

Increment:
  patch      1.0.0 â†’ 1.0.1
  minor      1.0.0 â†’ 1.1.0
  major      1.0.0 â†’ 2.0.0
  prerelease 1.0.0 â†’ 1.0.1-0
  prepatch   1.0.0 â†’ 1.0.1-0
  preminor   1.0.0 â†’ 1.1.0-0
  premajor   1.0.0 â†’ 2.0.0-0
  from-git   Use version from latest git tag
  1.2.3      Set specific version

Options:
  --no-git-tag-version Skip git operations
  --allow-same-version Prevents throwing error if version is the same
  --message=<val>, -m  Custom commit message, use %s for version substitution
  --preid=<val>        Prerelease identifier (i.e beta â†’ 1.0.1-beta.0)
  --force, -f          Bypass dirty git history check

Examples:
  $ bun pm version patch
  $ bun pm version 1.2.3 --no-git-tag-version
  $ bun pm version prerelease --preid beta --message "Release beta: %s"
```

---

title: Bumping the Package Version
description: Demonstrates how to bump the version in `package.json` using `bun pm version patch`. This updates the version number and, by default, creates a git commit and tag.
source: docs/cli/pm.md#_snippet_18

language: bash
code:
```
$ bun pm version patch
v1.0.1
```

---

title: Getting a Package Property Using bun pm pkg
description: Demonstrates getting single and multiple properties from the `package.json` using `bun pm pkg get`. Examples show retrieving the name, version, and nested properties.
source: docs/cli/pm.md#_snippet_19

language: bash
code:
```
$ bun pm pkg get name                               # single property
$ bun pm pkg get name version                       # multiple properties
$ bun pm pkg get                                    # entire package.json
$ bun pm pkg get scripts.build                      # nested property
```

---

title: Setting a Package Property Using bun pm pkg
description: Demonstrates setting single and multiple properties in `package.json` using `bun pm pkg set`. Includes usage with the `--json` flag for setting JSON values.
source: docs/cli/pm.md#_snippet_20

language: bash
code:
```
$ bun pm pkg set name="my-package"                  # simple property
$ bun pm pkg set scripts.test="jest" version=2.0.0  # multiple properties
$ bun pm pkg set {"private":"true"} --json          # JSON values with --json flag
```

---

title: Deleting a Package Property Using bun pm pkg
description: Demonstrates deleting properties from `package.json` using `bun pm pkg delete`. Examples showcase deleting single, multiple, and nested properties.
source: docs/cli/pm.md#_snippet_21

language: bash
code:
```
$ bun pm pkg delete description                     # single property
$ bun pm pkg delete scripts.test contributors[0]    # multiple/nested
```

---

title: Fixing Common Package Issues Using bun pm pkg
description: Demonstrates using `bun pm pkg fix` to automatically fix common issues in the `package.json` file. This can help ensure the file is well-formed and conforms to best practices.
source: docs/cli/pm.md#_snippet_22

language: bash
code:
```
$ bun pm pkg fix                                    # auto-fix common issues
```

---

title: Debugging with Inspect Flag
description: Illustrates the use of the `--inspect` flag when running code with Bun to enable debugging. It starts a WebSocket server for introspecting the running Bun process and provides a URL to connect a debugger.
source: docs/runtime/debugger.md#_snippet_1

language: shell
code:
```
$ bun --inspect server.ts
------------------ Bun Inspector ------------------
Listening at:
  ws://localhost:6499/0tqxs9exrgrm

Inspect in browser:
  https://debug.bun.sh/#localhost:6499/0tqxs9exrgrm
------------------ Bun Inspector ------------------
```

---

title: Using Inspect-brk Flag
description: Explains the `--inspect-brk` flag, which is similar to `--inspect` but injects a breakpoint at the first line of the script. This is useful for debugging scripts that run quickly and exit immediately.
source: docs/runtime/debugger.md#_snippet_2

language: text
code:
```
The `--inspect-brk` flag behaves identically to `--inspect`, except it automatically injects a breakpoint at the first line of the executed script. This is useful for debugging scripts that run quickly and exit immediately.
```

---

title: Using Inspect-wait Flag
description: Describes the `--inspect-wait` flag, which is similar to `--inspect` but pauses code execution until a debugger attaches. This is helpful for ensuring the debugger is connected before the script starts running.
source: docs/runtime/debugger.md#_snippet_3

language: text
code:
```
The `--inspect-wait` flag behaves identically to `--inspect`, except the code will not execute until a debugger has attached to the running process.
```

---

title: Specifying Port and URL for Debugger
description: Shows how to specify a port number, URL prefix, or both for the debugger using the `--inspect` flag. This allows customization of the debugger's endpoint.
source: docs/runtime/debugger.md#_snippet_4

language: shell
code:
```
$ bun --inspect=4000 server.ts
$ bun --inspect=localhost:4000 server.ts
$ bun --inspect=localhost:4000/prefix server.ts
```

---

title: Printing Fetch Requests as Curl Commands
description: Demonstrates how to print `fetch()` requests as `curl` commands by setting the `BUN_CONFIG_VERBOSE_FETCH` environment variable to `curl`. This is useful for replicating network requests in the terminal.
source: docs/runtime/debugger.md#_snippet_5

language: typescript
code:
```
process.env.BUN_CONFIG_VERBOSE_FETCH = "curl";

await fetch("https://example.com", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({ foo: "bar" }),
});
```

language: shell
code:
```
[fetch] $ curl --http1.1 "https://example.com/" -X POST -H "content-type: application/json" -H "Connection: keep-alive" -H "User-Agent: Bun/$BUN_LATEST_VERSION" -H "Accept: */*" -H "Host: example.com" -H "Accept-Encoding: gzip, deflate, br" --compressed -H "Content-Length: 13" --data-raw "{\"foo\":\"bar\"}"
[fetch] > HTTP/1.1 POST https://example.com/
[fetch] > content-type: application/json
[fetch] > Connection: keep-alive
[fetch] > User-Agent: Bun/$BUN_LATEST_VERSION
[fetch] > Accept: */*
[fetch] > Host: example.com
[fetch] > Accept-Encoding: gzip, deflate, br
[fetch] > Content-Length: 13

[fetch] < 200 OK
[fetch] < Accept-Ranges: bytes
[fetch] < Cache-Control: max-age=604800
[fetch] < Content-Type: text/html; charset=UTF-8
[fetch] < Date: Tue, 18 Jun 2024 05:12:07 GMT
[fetch] < Etag: "3147526947"
[fetch] < Expires: Tue, 25 Jun 2024 05:12:07 GMT
[fetch] < Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
[fetch] < Server: EOS (vny/044F)
[fetch] < Content-Length: 1256
```

---

title: Logging Fetch Requests and Responses
description: Shows how to print request and response information using `BUN_CONFIG_VERBOSE_FETCH` set to `true`. This is useful for debugging network requests made with `fetch()`.
source: docs/runtime/debugger.md#_snippet_6

language: typescript
code:
```
process.env.BUN_CONFIG_VERBOSE_FETCH = "true";

await fetch("https://example.com", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({ foo: "bar" }),
});
```

language: shell
code:
```
[fetch] > HTTP/1.1 POST https://example.com/
[fetch] > content-type: application/json
[fetch] > Connection: keep-alive
[fetch] > User-Agent: Bun/$BUN_LATEST_VERSION
[fetch] > Accept: */*
[fetch] > Host: example.com
[fetch] > Accept-Encoding: gzip, deflate, br
[fetch] > Content-Length: 13

[fetch] < 200 OK
[fetch] < Accept-Ranges: bytes
[fetch] < Cache-Control: max-age=604800
[fetch] < Content-Type: text/html; charset=UTF-8
[fetch] < Date: Tue, 18 Jun 2024 05:12:07 GMT
[fetch] < Etag: "3147526947"
[fetch] < Expires: Tue, 25 Jun 2024 05:12:07 GMT
[fetch] < Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
[fetch] < Server: EOS (vny/044F)
[fetch] < Content-Length: 1256
```

---

title: Implementing onStart Hook in Bun Plugin
description: Illustrates how to register a callback function using the `onStart` hook in a Bun plugin. The callback is executed when the bundler begins a new bundle, allowing for tasks such as logging or initialization.
source: docs/runtime/plugins.md#_snippet_1

language: typescript
code:
```
import { plugin } from "bun";

plugin({
  name: "onStart example",

  setup(build) {
    build.onStart(() => {
      console.log("Bundle started!");
    });
  },
});
```

---

title: Configuring Module Resolution with onResolve
description: Illustrates how to use the `onResolve` hook to modify module resolution in Bun. This example redirects imports starting with `images/` to the `./public/images/` directory, demonstrating how to customize module paths.
source: docs/runtime/plugins.md#_snippet_3

language: typescript
code:
```
import { plugin } from "bun";

plugin({
  name: "onResolve example",
  setup(build) {
    build.onResolve({ filter: /.*/, namespace: "file" }, args => {
      if (args.path.startsWith("images/")) {
        return {
          path: args.path.replace("images/", "./public/images/"),
        };
      }
    });
  },
});
```

---

title: Modifying Module Contents with onLoad
description: Demonstrates how to modify the contents of a module using the `onLoad` hook in Bun. This example creates a plugin that loads environment variables into a module, converting `process.env` into a JavaScript object.
source: docs/runtime/plugins.md#_snippet_4

language: typescript
code:
```
import { plugin } from "bun";

plugin({
  name: "env plugin",
  setup(build) {
    build.onLoad({ filter: /env/, namespace: "file" }, args => {
      return {
        contents: `export default ${JSON.stringify(process.env)}`,
        loader: "js",
      };
    });
  },
});
```

---

title: Encoding and Decoding Text
description: Illustrates encoding a string using `TextEncoder` and decoding it back using `TextDecoder`. These Web APIs are useful for handling text transformations in Bun.
source: docs/runtime/index.md#_snippet_1

language: javascript
code:
```
const encoder = new TextEncoder();
const decoder = new TextDecoder();

const text = "Hello, world!";
const encoded = encoder.encode(text);
const decoded = decoder.decode(encoded);

console.log(encoded);
console.log(decoded);
```

---

title: Setting and Clearing Timeout
description: Demonstrates how to use `setTimeout` and `clearTimeout` to execute code after a delay and cancel the execution, respectively. This is a standard web API that is useful for scheduling tasks in Bun.
source: docs/runtime/index.md#_snippet_2

language: javascript
code:
```
const timeoutId = setTimeout(() => {
  console.log("This will run after 1 second");
}, 1000);

clearTimeout(timeoutId);
```

---

title: Defining Intervals
description: Shows how to use `setInterval` to execute a function repeatedly with a fixed time delay between each call, and `clearInterval` to stop the repeated execution. These Web APIs enable you to create timed loops in Bun.
source: docs/runtime/index.md#_snippet_3

language: javascript
code:
```
const intervalId = setInterval(() => {
  console.log("This will run every 2 seconds");
}, 2000);

clearInterval(intervalId);
```

---

title: Writing to File with Bun Write
description: Illustrates how to write data to a file using `Bun.write`. This is a Bun-specific API for efficient file I/O.
source: docs/runtime/index.md#_snippet_5

language: javascript
code:
```
await Bun.write("output.txt", "Hello, Bun!");
```

---

title: Spawning Processes with Bun Spawn
description: Demonstrates how to spawn a child process using `Bun.spawn`. This Bun API allows you to execute external commands from within your Bun application.
source: docs/runtime/index.md#_snippet_6

language: javascript
code:
```
const { stdout, stderr, exitCode } = Bun.spawn(['ls', '-l']);
console.log(await new Response(stdout).text());
```

---

title: Batching WebSocket Operations Using Cork - TS
description: Illustrates how to batch a set of operations on a `WebSocket` connection using the `cork` method. This ensures that multiple messages are sent together, improving efficiency. The `message`, `open`, and `drain` callbacks are automatically corked.
source: docs/api/websockets.md#_snippet_1

language: ts
code:
```
ws.cork((ws) => {
  ws.send("first");
  ws.send("second");
  ws.send("third");
});
```

---

title: Showing Suppressed Command Output
description: Demonstrates the output from `bun run dev` with and without the `silent` option being enabled. The example highlights the difference in console output when the command is being run.
source: docs/runtime/bunfig.md#_snippet_12

language: sh
code:
```
$ bun run dev
> $ echo "Running \"dev\"..."
Running "dev"...
```

language: sh
code:
```
$ bun run dev
Running "dev"...
```

---

title: Implementing Hot Reloading with Global State
description: Shows how `bun --hot` reloads code while preserving global state.  It declares a global variable `count`, increments it on each reload, and logs the value.  This persists the `count` across reloads, unlike a full restart.
source: docs/runtime/hot.md#_snippet_4

language: typescript
code:
```
// make TypeScript happy
declare global {
  var count: number;
}

globalThis.count ??= 0;
console.log(`Reloaded ${globalThis.count} times`);
globalThis.count++;

// prevent `bun run` from exiting
setInterval(function () {}, 1000000);
```

---

title: Updating an HTTP Server With Hot Reloading
description: Illustrates updating an HTTP request handler with `bun --hot` without restarting the server. The code defines a `Bun.serve` handler that increments a global counter and returns it in the response, showing that the server updates without process restarts.
source: docs/runtime/hot.md#_snippet_5

language: typescript
code:
```
globalThis.count ??= 0;
globalThis.count++;

Bun.serve({
  fetch(req: Request) {
    return new Response(`Reloaded ${globalThis.count} times`);
  },
  port: 3000,
});
```

---

title: Closing a WebSocket Connection
description: Demonstrates using the `close()` method to terminate a `WebSocket` connection. This method allows specifying a status code and a reason message for the closure.
source: docs/api/websockets.md#_snippet_0

language: typescript
code:
```
`close(code?: number, message?: string): void`
```

---

title: Writing Response to File - JavaScript
description: Illustrates writing a `Response` object to a file using `Bun.write`. The `Response` is automatically converted to a `Blob` before being written to the file. This is useful for saving the content of a network request directly to disk.
source: docs/api/file.md#_snippet_1

language: javascript
code:
```
// Eventually, this will stream the response to disk but today it buffers
await Bun.write("index.html", await fetch("https://example.com"));
```

---

title: Setting Environment Variables Programmatically
description: Illustrates how to set environment variables programmatically within a TypeScript file using `process.env`. This allows dynamic configuration of the environment during runtime.
source: docs/runtime/env.md#_snippet_3

language: ts
code:
```
process.env.FOO = "hello";
```

---

title: Reading Environment Variables
description: Illustrates how to read environment variables using `process.env`, `Bun.env`, and `import.meta.env`. These are equivalent ways to access environment variables within Bun's runtime.
source: docs/runtime/env.md#_snippet_7

language: ts
code:
```
process.env.API_TOKEN; // => "secret"
Bun.env.API_TOKEN; // => "secret"
import.meta.env.API_TOKEN; // => "secret"
```

---

title: Importing and Using a Local Module - CommonJS
description: Demonstrates importing a function `hello` from a local module using CommonJS syntax (`require`). This example illustrates basic module usage within a JavaScript environment, showcasing how to structure and connect different parts of a simple application.
source: docs/runtime/modules.md#_snippet_2

language: ts
code:
```
const { hello } = require("./hello");

hello();
```

language: ts
code:
```
function hello() {
  console.log("Hello world!");
}

exports.hello = hello;
```

---

title: Requiring Modules with Optional Extensions - JavaScript
description: Demonstrates using `require()` to import modules with and without file extensions. This shows that Bun allows flexibility in specifying module paths, even supporting `.ts`, `.mjs`, and `.tsx` files directly.
source: docs/runtime/modules.md#_snippet_3

language: ts
code:
```
const { foo } = require("./foo"); // extensions are optional
const { bar } = require("./bar.mjs");
const { baz } = require("./baz.tsx");
```

---

title: Importing Modules with Optional Extensions - TypeScript
description: Demonstrates using `import` to import modules with and without file extensions. This shows that Bun allows flexibility in specifying module paths, supporting `.cjs` files directly.
source: docs/runtime/modules.md#_snippet_4

language: ts
code:
```
import { foo } from "./foo"; // extensions are optional
import bar from "./bar.ts";
import { stuff } from "./my-commonjs.cjs";
```

---

title: Ordering Versions with Bun Semver
description: Illustrates how to use `Bun.semver.order` to compare two version strings. The function returns `0` if the versions are equal, `1` if the first version is greater, and `-1` if the first version is less.  It then demonstrates how to sort an array of version strings using the semver function.
source: docs/api/semver.md#_snippet_1

language: typescript
code:
```
import { semver } from "bun";

semver.order("1.0.0", "1.0.0"); // 0
semver.order("1.0.0", "1.0.1"); // -1
semver.order("1.0.1", "1.0.0"); // 1

const unsorted = ["1.0.0", "1.0.1", "1.0.0-alpha", "1.0.0-beta", "1.0.0-rc"];
unsorted.sort(semver.order); // ["1.0.0-alpha", "1.0.0-beta", "1.0.0-rc", "1.0.0", "1.0.1"]
console.log(unsorted);
```

---

title: Testing Asynchronous Operations Using Done Callback with Bun:test
description: Illustrates testing asynchronous code using the `done` callback in `bun:test`. The `done` callback signals the completion of the asynchronous test.  It imports `expect` and `test` from `bun:test`.
source: docs/test/writing.md#_snippet_3

language: ts
code:
```
import { expect, test } from "bun:test";

test("2 * 2", done => {
  Promise.resolve(2 * 2).then(result => {
    expect(result).toEqual(4);
    done();
  });
});
```

---

title: Running Parametrized Tests with Test.each in Bun:test
description: Demonstrates how to run the same test with multiple sets of data using `test.each` in `bun:test`. The test is parametrized and runs once for each test case provided. The example shows using an array of arrays as test cases.
source: docs/test/writing.md#_snippet_13

language: ts
code:
```
const cases = [
  [1, 2, 3],
  [3, 4, 7],
];

test.each(cases)("%p + %p should be %p", (a, b, expected) => {
  expect(a + b).toBe(expected);
});
```

---

title: Creating Parametrized Suites with Describe.each in Bun:test
description: Illustrates creating a parametrized suite that runs once for each test case using `describe.each` in `bun:test`. The example shows using `describe.each` to create tests for different sets of data and performing multiple assertions within each test case.
source: docs/test/writing.md#_snippet_14

language: ts
code:
```
describe.each([
  [1, 2, 3],
  [3, 4, 7],
])("add(%i, %i)", (a, b, expected) => {
  test(`returns ${expected}`, () => {
    expect(a + b).toBe(expected);
  });

  test(`sum is greater than each value`, () => {
    expect(a + b).toBeGreaterThan(a);
    expect(a + b).toBeGreaterThan(b);
  });
});
```

---

title: Creating a Yaml Loader Plugin
description: Demonstrates how to create a Bun plugin that implements a loader for `.yaml` files. The plugin uses `js-yaml` to parse the file content and then returns it as a JavaScript object using the `object` loader.
source: docs/runtime/plugins.md#_snippet_2

language: ts
code:
```
import { plugin } from "bun";

await plugin({
  name: "YAML",
  async setup(build) {
    const { load } = await import("js-yaml");

    // when a .yaml file is imported...
    build.onLoad({ filter: /\.(yaml|yml)$/ }, async (args) => {

      // read and parse the file
      const text = await Bun.file(args.path).text();
      const exports = load(text) as Record<string, any>;

      // and returns it as a module
      return {
        exports,
        loader: "object", // special loader for JS objects
      };
    });
  },
});
```

---

title: Creating a Svelte Loader Plugin
description: Demonstrates how to create a Bun plugin that loads `.svelte` files. The plugin uses the `svelte/compiler` to compile the Svelte component and returns the compiled JavaScript code using the `js` loader.
source: docs/runtime/plugins.md#_snippet_5

language: ts
code:
```
import { plugin } from "bun";

await plugin({
  name: "svelte loader",
  async setup(build) {
    const { compile } = await import("svelte/compiler");

    // when a .svelte file is imported...
    build.onLoad({ filter: /\.svelte$/ }, async ({ path }) => {

      // read and compile it with the Svelte compiler
      const file = await Bun.file(path).text();
      const contents = compile(file, {
        filename: path,
        generate: "ssr",
      }).js.code;

      // and return the compiled source code as "js"
      return {
        contents,
        loader: "js",
      };
    });
  },
});
```

---

title: Configuring JSX Transformation - React
description: Demonstrates how the `jsx` compiler option in `tsconfig.json` or `jsconfig.json` controls the transformation of JSX syntax when set to `react`. It imports `createElement` from `react` and utilizes it to create the `Box` element with specified properties.
source: docs/runtime/jsx.md#_snippet_1

language: json
code:
```
{
  "jsx": "react"
}
```

language: tsx
code:
```
import { createElement } from "react";
createElement("Box", { width: 5 }, "Hello");
```

---

title: Configuring JSX Transformation - React JSX
description: Demonstrates how the `jsx` compiler option, when set to `react-jsx`, transforms JSX using the `jsx` function from `react/jsx-runtime`. It imports the `jsx` function and uses it to create the `Box` element.
source: docs/runtime/jsx.md#_snippet_2

language: json
code:
```
{
  "jsx": "react-jsx"
}
```

language: tsx
code:
```
import { jsx } from "react/jsx-runtime";
jsx("Box", { width: 5 }, "Hello");
```

---

title: Configuring JSX Transformation - React JSXDev
description: Demonstrates how the `jsx` compiler option transforms JSX using the `jsxDEV` function from `react/jsx-dev-runtime` when set to `react-jsxdev`. It shows importing the `jsxDEV` function and using it to create a `Box` element with additional development-related metadata.
source: docs/runtime/jsx.md#_snippet_3

language: json
code:
```
{
  "jsx": "react-jsxdev"
}
```

language: tsx
code:
```
import { jsxDEV } from "react/jsx-dev-runtime";
jsxDEV(
  "Box",
  { width: 5, children: "Hello" },
  undefined,
  false,
  undefined,
  this,
);
```

---

title: Loading Node-API Modules with Process Dlopen
description: Illustrates how to load a `.node` file using `process.dlopen`. This method provides more control over the module loading process, allowing you to explicitly define the `exports` object.
source: docs/api/node-api.md#_snippet_1

language: js
code:
```
let mod = { exports: {} };
process.dlopen(mod, "./my-node-module.node");
```

---

title: Prefetching DNS Entries Before Fetching - Node.js
description: Demonstrates prefetching a DNS entry for `bun.com` on port 443 using `dns.prefetch` before making a `fetch` request.  This avoids the initial DNS lookup latency when `fetch` is called. The import statement makes the `dns` module available.
source: docs/api/dns.md#_snippet_2

language: ts
code:
```
import { dns } from "bun";

dns.prefetch("bun.com", 443);
//
// ... sometime later ...
await fetch("https://bun.com");
```

---

title: Matching Single Character - TypeScript
description: Demonstrates how to use the `?` wildcard to match any single character in a glob pattern. The code defines a glob pattern `???.ts` and tests it against the strings `foo.ts` and `foobar.ts`.
source: docs/api/glob.md#_snippet_2

language: typescript
code:
```
const glob = new Glob("???.ts");
glob.match("foo.ts"); // => true
glob.match("foobar.ts"); // => false
```

---

title: Matching Zero or More Characters - TypeScript
description: Illustrates how to use the `*` wildcard to match zero or more characters, excluding path separators, in a glob pattern. The code defines a glob pattern `*.ts` and tests it against the strings `index.ts` and `src/index.ts`.
source: docs/api/glob.md#_snippet_3

language: typescript
code:
```
const glob = new Glob("*.ts");
glob.match("index.ts"); // => true
glob.match("src/index.ts"); // => false
```

---

title: Matching Any Number of Characters Including Slash - TypeScript
description: Demonstrates how to use the `**` wildcard to match any number of characters, including path separators. The code defines a glob pattern `**/*.ts` and tests it against `index.ts`, `src/index.ts`, and `src/index.js`.
source: docs/api/glob.md#_snippet_4

language: typescript
code:
```
const glob = new Glob("**/*.ts");
glob.match("index.ts"); // => true
glob.match("src/index.ts"); // => true
glob.match("src/index.js"); // => false
```

---

title: Matching Characters in Brackets - TypeScript
description: Illustrates how to match one of the characters contained in brackets, as well as character ranges, using glob patterns. The code defines a glob pattern `ba[rz].ts` and tests it against the strings `bar.ts`, `baz.ts`, and `bat.ts`.
source: docs/api/glob.md#_snippet_5

language: typescript
code:
```
const glob = new Glob("ba[rz].ts");
glob.match("bar.ts"); // => true
glob.match("baz.ts"); // => true
glob.match("bat.ts"); // => false
```

---

title: Matching Character Ranges and Negation - TypeScript
description: Demonstrates character ranges (e.g `[0-9]`, `[a-z]`) as well as the negation operators `^` or `!` to match anything _except_ the characters contained within the braces (e.g `[^ab]`, `[!a-z]`).
source: docs/api/glob.md#_snippet_6

language: typescript
code:
```
const glob = new Glob("ba[a-z][0-9][^4-9].ts");
glob.match("bar01.ts"); // => true
glob.match("baz83.ts"); // => true
glob.match("bat22.ts"); // => true
glob.match("bat24.ts"); // => false
glob.match("ba0a8.ts"); // => false
```

---

title: Matching Given Patterns - TypeScript
description: Illustrates how to use curly braces `{}` to match any of the given patterns. The code defines a glob pattern `{a,b,c}.ts` and tests it against the strings `a.ts`, `b.ts`, `c.ts`, and `d.ts`.
source: docs/api/glob.md#_snippet_7

language: typescript
code:
```
const glob = new Glob("{a,b,c}.ts");
glob.match("a.ts"); // => true
glob.match("b.ts"); // => true
glob.match("c.ts"); // => true
glob.match("d.ts"); // => false
```

---

title: Negating Result at Start of Pattern - TypeScript
description: Demonstrates how to negate the result at the start of a pattern using the `!` character. The code defines a glob pattern `!index.ts` and tests it against `index.ts` and `foo.ts`.
source: docs/api/glob.md#_snippet_8

language: typescript
code:
```
const glob = new Glob("!index.ts");
glob.match("index.ts"); // => false
glob.match("foo.ts"); // => true
```

---

title: Escaping Special Characters - TypeScript
description: Illustrates how to escape special characters using the backslash `\`. The code defines a glob pattern `\!index.ts` and tests it against `!index.ts` and `index.ts`.
source: docs/api/glob.md#_snippet_9

language: typescript
code:
```
const glob = new Glob("\\!index.ts");
glob.match("!index.ts"); // => true
glob.match("index.ts"); // => false
```

---

title: Reserving Database Connections in Bun SQL
description: Demonstrates how to reserve an exclusive connection from the pool using `sql.reserve()`. This creates a client that wraps a single connection for isolated operations. The connection must be released back to the pool using `reserved.release()` or the `Symbol.dispose` pattern after use.
source: docs/api/sql.md#_snippet_1

language: typescript
code:
```
// Get exclusive connection from pool
const reserved = await sql.reserve();

try {
  await reserved`INSERT INTO users (name) VALUES (${'Alice'})`;
} finally {
  // Important: Release connection back to pool
  reserved.release();
}

// Or using Symbol.dispose
{
  using reserved = await sql.reserve();
  await reserved`SELECT 1`;
} // Automatically released
```

---

title: Handling Large Numbers as Strings - Bun SQL
description: Demonstrates how Bun's SQL client handles large numbers that exceed the range of a 53-bit integer by returning them as strings. This prevents loss of precision when dealing with large numeric values from the database.
source: docs/api/sql.md#_snippet_3

language: typescript
code:
```
import { sql } from "bun";

const [{ x, y }] = await sql`SELECT 9223372036854777 as x, 12345 as y`;

console.log(typeof x, x); // "string" "9223372036854777"
console.log(typeof y, y); // "number" 12345
```

---

title: Configuring BigInt Output - Bun SQL
description: Illustrates how to configure the Bun SQL client to return large numbers as `BigInt` instead of strings by setting the `bigint` option to `true` during initialization. This allows direct use of `BigInt` for large numeric values.
source: docs/api/sql.md#_snippet_4

language: typescript
code:
```
const sql = new SQL({
  bigint: true,
});

const [{ x }] = await sql`SELECT 9223372036854777 as x`;

console.log(typeof x, x); // "bigint" 9223372036854777n
```

---

title: Converting to `Blob`
description: Demonstrates how to convert a `ReadableStream` to a `Blob` using the `Response` API. The `blob()` method of the `Response` object is used to perform the conversion.
source: docs/api/binary-data.md#_snippet_2

language: typescript
code:
```
new Response(stream).blob();
```

---

title: Splitting `ReadableStream` with Teeing
description: Illustrates how to split a `ReadableStream` into two independent streams using the `tee()` method.  This allows multiple consumers to read from the same stream concurrently.
source: docs/api/binary-data.md#_snippet_3

language: typescript
code:
```
const [a, b] = stream.tee();
```

---

title: Echoing Messages with ServerWebSocket
description: Demonstrates how to access the `ServerWebSocket` instance within a WebSocket handler and use its `.send()` method to echo back received messages to the client. This example illustrates basic message handling in a Bun WebSocket server.
source: docs/api/websockets.md#_snippet_2

language: typescript
code:
```
Bun.serve({
  fetch(req, server) {}, // upgrade logic
  websocket: {
    message(ws, message) {
      ws.send(message); // echo back the message
    },
  },
});
```

---

title: Passing Contextual Data to WebSocket Handlers
description: Demonstrates how to attach contextual data to a new WebSocket connection during the `.upgrade()` call, and accessing this data within the WebSocket handlers using the `ws.data` property. This allows you to pass information such as user authentication tokens or channel IDs to the WebSocket handlers.
source: docs/api/websockets.md#_snippet_4

language: typescript
code:
```
type WebSocketData = {
  createdAt: number;
  channelId: string;
  authToken: string;
};

// TypeScript: specify the type of `data`
Bun.serve<WebSocketData>({
  fetch(req, server) {
    const cookies = new Bun.CookieMap(req.headers.get("cookie")!);

    server.upgrade(req, {
      // this object must conform to WebSocketData
      data: {
        createdAt: Date.now(),
        channelId: new URL(req.url).searchParams.get("channelId"),
        authToken: cookies.get("X-Token"),
      },
    });

    return undefined;
  },
  websocket: {
    // handler called when a message is received
    async message(ws, message) {
      const user = getUserFromToken(ws.data.authToken);

      await saveMessageToDatabase({
        channel: ws.data.channelId,
        message: String(message),
        userId: user.id,
      });
    },
  },
});
```

---

title: Connecting to WebSocket Server With Custom Headers
description: Illustrates how to connect to a `ws://` or `wss://` server, creating an instance of `WebSocket` while setting custom headers directly in the constructor. Note that this is a Bun-specific extension of the `WebSocket` standard and won't work in browsers.
source: docs/api/websockets.md#_snippet_12

language: typescript
code:
```
const socket = new WebSocket("ws://localhost:3000", {
  headers: {
    // custom headers
  },
});
```

---

title: Matching Routes Using Request Objects
description: Illustrates how the `FileSystemRouter` can accept `Request` objects directly as input for the `.match()` method. The router uses the `url` property of the `Request` object to resolve the route, providing flexibility in handling route matching within a request-response lifecycle.
source: docs/api/file-system-router.md#_snippet_3

language: ts
code:
```
router.match(new Request("https://example.com/blog/my-cool-post"));
```

---

title: Reloading FileSystemRouter Directory Contents
description: Explains how to use the `.reload()` method to re-scan the directory contents. This is useful when the files in the directory have been changed and the router needs to update its internal representation of the file system.
source: docs/api/file-system-router.md#_snippet_4

language: ts
code:
```
router.reload();
```

---

title: Parsing Cookie Strings
description: Illustrates the usage of the `Cookie.parse` static method to create a `Cookie` instance from a cookie string.  This is useful for parsing cookies received in HTTP request headers.
source: docs/api/cookie.md#_snippet_1

language: ts
code:
```
class Cookie {
  static parse(cookieString: string): Cookie;
}
```

---

title: Creating Cookies From Name and Value
description: Illustrates the usage of the `Cookie.from` static method to create a `Cookie` instance with a name and value. The `Cookie.from` method simplifies creating cookies with a basic name/value pair, optionally including additional configuration options.
source: docs/api/cookie.md#_snippet_2

language: ts
code:
```
class Cookie {
  static from(name: string, value: string, options?: CookieInit): Cookie;
}
```

---

title: Setting Cookie Options
description: Demonstrates the different ways in which the `set` method of the `CookieMap` class is overloaded to allow setting cookie values and options.  It shows how to set both the name and value with options, or just options using the `CookieInit` interface.
source: docs/api/cookie.md#_snippet_4

language: ts
code:
```
class CookieMap implements Iterable<[string, string]> {
  set(name: string, value: string, options?: CookieInit): void;
  set(options: CookieInit): void;
}
```

---

title: Deleting Cookies Using CookieMap
description: Illustrates the use of the `delete` method in the `CookieMap` class, highlighting the different ways to delete cookies. The `delete` method offers flexibility by allowing deletion based on name, or name with specific domain and path, useful for precise cookie management.
source: docs/api/cookie.md#_snippet_5

language: ts
code:
```
interface CookieStoreDeleteOptions {
  name: string;
  domain?: string | null;
  path?: string;
}

class CookieMap implements Iterable<[string, string]> {
  delete(name: string): void;
  delete(options: CookieStoreDeleteOptions): void;
  delete(name: string, options: Omit<CookieStoreDeleteOptions, "name">): void;
}
```

---

title: Converting CookieMap to Headers
description: Demonstrates how to convert a `CookieMap` instance to an array of HTTP `Set-Cookie` headers using the `toSetCookieHeaders` method.  This is essential for including cookies in HTTP responses.
source: docs/api/cookie.md#_snippet_6

language: ts
code:
```
class CookieMap implements Iterable<[string, string]> {
  toSetCookieHeaders(): string[];
}
```

---

title: Iterating Through CookieMap
description: Demonstrates the use of iterator methods like `entries`, `keys`, `values`, and `forEach` to iterate over the key-value pairs in a `CookieMap`. This allows you to easily access and process cookie data.
source: docs/api/cookie.md#_snippet_7

language: ts
code:
```
class CookieMap implements Iterable<[string, string]> {
  entries(): IterableIterator<[string, string]>;
  keys(): IterableIterator<string>;
  values(): IterableIterator<string>;
  forEach(callback: (value: string, key: string, map: CookieMap) => void): void;
  [Symbol.iterator](): IterableIterator<[string, string]>;
}
```

---

title: Converting File URL to Path
description: Illustrates converting a `file://` URL to an absolute path using `Bun.fileURLToPath`. This function is useful for resolving file paths from URLs.
source: docs/api/utils.md#_snippet_1

language: ts
code:
```
const path = Bun.fileURLToPath(new URL("file:///foo/bar.txt"));
console.log(path); // "/foo/bar.txt"
```

---

title: Converting Path to File URL
description: Demonstrates converting an absolute path to a `file://` URL using `Bun.pathToFileURL`. This is useful for creating file URLs from file paths.
source: docs/api/utils.md#_snippet_2

language: ts
code:
```
const url = Bun.pathToFileURL("/foo/bar.txt");
console.log(url); // "file:///foo/bar.txt"
```

---

title: Compressing Data Using Gzip
description: Illustrates compressing a `Uint8Array` using zlib's GZIP algorithm with `Bun.gzipSync()`. This can be useful for reducing the size of data for storage or transmission.
source: docs/api/utils.md#_snippet_3

language: ts
code:
```
const buf = Buffer.from("hello".repeat(100)); // Buffer extends Uint8Array
const compressed = Bun.gzipSync(buf);

buf; // => Uint8Array(500)
compressed; // => Uint8Array(30)
```

---

title: Creating an Array Buffer
description: Demonstrates the creation of an `ArrayBuffer` with a specified byte length. An `ArrayBuffer` represents a raw buffer of binary data in memory.
source: docs/api/binary-data.md#_snippet_0

language: typescript
code:
```
// this buffer can store 8 bytes
const buf = new ArrayBuffer(8);
```

---

title: Slicing an Array Buffer
description: Illustrates how to create a slice (a new `ArrayBuffer`) from an existing `ArrayBuffer`.  The `slice()` method creates a new buffer that contains a portion of the original buffer's data.
source: docs/api/binary-data.md#_snippet_1

language: typescript
code:
```
const buf = new ArrayBuffer(8);
buf.byteLength; // => 8

const slice = buf.slice(0, 4); // returns new ArrayBuffer
slice.byteLength; // => 4
```

---

title: Creating a Direct ReadableStream - TypeScript
description: Demonstrates the creation of an optimized `ReadableStream` that avoids data copying and queue management.  Instead of `.enqueue()`, the `.write()` method is used to directly write data to the stream, and all chunk queueing is handled by the destination.
source: docs/api/streams.md#_snippet_2

language: ts
code:
```
const stream = new ReadableStream({
  type: "direct",
  pull(controller) {
    controller.write("hello");
    controller.write("world");
  },
});
```

---

title: Using Async Generator Functions with Response - TypeScript
description: Illustrates how to use an async generator function as a source for a `Response` object, creating a `ReadableStream` that yields data asynchronously. The `response.text()` method then consumes the stream and concatenates the yielded strings.
source: docs/api/streams.md#_snippet_3

language: ts
code:
```
const response = new Response(
  (async function* () {
    yield "hello";
    yield "world";
  })(),
);

await response.text(); // "helloworld"
```

---

title: Using Async Iterator with Response - TypeScript
description: Illustrates the use of `Symbol.asyncIterator` directly to create a `Response` object, creating a `ReadableStream` that yields data asynchronously. The `response.text()` method consumes the stream and concatenates the yielded strings.
source: docs/api/streams.md#_snippet_4

language: ts
code:
```
const response = new Response({
  [Symbol.asyncIterator]: async function* () {
    yield "hello";
    yield "world";
  },
});

await response.text(); // "helloworld"
```

---

title: Controlling Direct ReadableStream with Async Iterator - TypeScript
description: Demonstrates how to gain more granular control over a direct `ReadableStream` using `Symbol.asyncIterator`. The `yield` keyword returns the direct `ReadableStream` controller, allowing for manual control over the stream's lifecycle, such as calling `controller.end()`.
source: docs/api/streams.md#_snippet_5

language: ts
code:
```
const response = new Response({
  [Symbol.asyncIterator]: async function* () {
    const controller = yield "hello";
    await controller.end();
  },
});

await response.text(); // "hello"
```

---

title: Writing to an ArrayBufferSink - TypeScript
description: Demonstrates how to use `Bun.ArrayBufferSink` to incrementally write strings, and then retrieve the data as an `ArrayBuffer` using the `end` method. This is useful for constructing `ArrayBuffer` instances of unknown size without pre-allocation.
source: docs/api/streams.md#_snippet_6

language: ts
code:
```
const sink = new Bun.ArrayBufferSink();

sink.write("h");
sink.write("e");
sink.write("l");
sink.write("l");
sink.write("o");

sink.end();
// ArrayBuffer(5) [ 104, 101, 108, 108, 111 ]
```

---

title: Retrieving Data as Uint8Array - TypeScript
description: Demonstrates retrieving data as a `Uint8Array` instead of an `ArrayBuffer` by setting the `asUint8Array` option to `true` during `Bun.ArrayBufferSink` initialization. This allows you to work with typed arrays directly.
source: docs/api/streams.md#_snippet_7

language: ts
code:
```
const sink = new Bun.ArrayBufferSink();
sink.start({
+ asUint8Array: true
});

sink.write("h");
sink.write("e");
sink.write("l");
sink.write("l");
sink.write("o");

sink.end();
// Uint8Array(5) [ 104, 101, 108, 108, 111 ]
```

---

title: Writing Different Data Types to ArrayBufferSink - TypeScript
description: Illustrates the flexibility of the `.write()` method of `Bun.ArrayBufferSink`, which supports strings, typed arrays (`Uint8Array`), and `ArrayBuffer` instances. This allows for efficient accumulation of data from various sources into a single buffer.
source: docs/api/streams.md#_snippet_8

language: ts
code:
```
sink.write("h");
sink.write(new Uint8Array([101, 108]));
sink.write(Buffer.from("lo").buffer);

sink.end();
```

---

title: Flushing Data from ArrayBufferSink in Streaming Mode - TypeScript
description: Demonstrates using `Bun.ArrayBufferSink` in streaming mode by passing `stream: true` to the `start` method. The `.flush()` method returns the buffered data as an `ArrayBuffer` or `Uint8Array` (if `asUint8Array: true` was set) and clears the internal buffer, allowing for continuous writing and periodic retrieval of data.
source: docs/api/streams.md#_snippet_9

language: ts
code:
```
const sink = new Bun.ArrayBufferSink();
sink.start({
  stream: true,
});

sink.write("h");
sink.write("e");
sink.write("l");
sink.flush();
// ArrayBuffer(5) [ 104, 101, 108 ]

sink.write("l");
sink.write("o");
sink.flush();
// ArrayBuffer(5) [ 108, 111 ]
```

---

title: Setting High Water Mark for ArrayBufferSink - TypeScript
description: Shows how to manually set the size of the internal buffer in bytes for `Bun.ArrayBufferSink` by passing a value for `highWaterMark` during the `start` method. This pre-allocation can improve performance when the chunk size is small.
source: docs/api/streams.md#_snippet_10

language: ts
code:
```
const sink = new Bun.ArrayBufferSink();
sink.start({
  highWaterMark: 1024 * 1024, // 1 MB
});
```

---

title: Configuring Preload Scripts - TOML
description: Demonstrates how to configure `preload` scripts in `bunfig.toml`. This allows specifying scripts or plugins to execute before running a file or script with Bun. It is useful for registering plugins or setting up the environment before the main application code runs.
source: docs/runtime/bunfig.md#_snippet_0

language: toml
code:
```
# scripts to run before `bun run`-ing a file or script
# register plugins by adding them to this list
preload = ["./preload.ts"]
```

---

title: Configuring JSX Options - TOML
description: Illustrates how to configure JSX options in `bunfig.toml`. This allows customizing how Bun handles JSX syntax.  Settings such as `jsx`, `jsxFactory`, `jsxFragment`, and `jsxImportSource` can be defined to align with the desired JSX transformation behavior, similar to settings in `tsconfig.json`.
source: docs/runtime/bunfig.md#_snippet_1

language: toml
code:
```
jsx = "react"
jsxFactory = "h"
jsxFragment = "Fragment"
jsxImportSource = "react"
```

---

title: Configuring Test Root Directory - TOML
description: Illustrates configuring the root directory for tests in `bunfig.toml`. The `test.root` setting specifies the directory where Bun will search for test files. This is useful for organizing tests in a dedicated directory, such as `./__tests__`.
source: docs/runtime/bunfig.md#_snippet_8

language: toml
code:
```
[test]
root = "./__tests__"
```

---

title: Preloading Scripts for Tests - TOML
description: Demonstrates how to preload scripts specifically for `bun test` using the `test.preload` setting in `bunfig.toml`. This allows you to execute setup or initialization code before running your tests. This is commonly used for tasks like setting up mock environments or database connections.
source: docs/runtime/bunfig.md#_snippet_9

language: toml
code:
```
[test]
preload = ["./setup.ts"]
```

---

title: Enabling Coverage Reporting - TOML
description: Demonstrates enabling code coverage reporting in `bunfig.toml` using the `test.coverage` setting.  When enabled, Bun will generate coverage reports showing which parts of your code are covered by tests.  This is valuable for identifying areas that need more testing.
source: docs/runtime/bunfig.md#_snippet_11

language: toml
code:
```
[test]
coverage = false
```

---

title: Setting Coverage Threshold - TOML
description: Demonstrates setting a coverage threshold in `bunfig.toml` using the `test.coverageThreshold` setting. This allows you to enforce a minimum level of code coverage for your project. If the test suite does not meet or exceed this threshold, `bun test` will exit with a non-zero exit code.
source: docs/runtime/bunfig.md#_snippet_12

language: toml
code:
```
[test]

# to require 90% line-level and function-level coverage
coverageThreshold = 0.9
```

---

title: Setting Granular Coverage Thresholds - TOML
description: Demonstrates how to configure different coverage thresholds for line-wise, function-wise, and statement-wise coverage in `bunfig.toml` using the `test.coverageThreshold` setting. This allows fine-grained control over coverage requirements.
source: docs/runtime/bunfig.md#_snippet_13

language: toml
code:
```
[test]
coverageThreshold = { line = 0.7, function = 0.8, statement = 0.9 }
```

---

title: Setting Coverage Reporter - TOML
description: Demonstrates how to set the coverage reporter in `bunfig.toml` using the `test.coverageReporter` setting. By default, coverage reports are printed to the console. To get persistent reports, especially in CI environments, the `lcov` reporter can be used.
source: docs/runtime/bunfig.md#_snippet_16

language: toml
code:
```
[test]
coverageReporter  = ["text", "lcov"]  # default ["text"]
```

---

title: Setting Coverage Directory - TOML
description: Demonstrates how to set the directory where coverage reports will be saved using the `test.coverageDir` setting in `bunfig.toml`. This setting only works for persistent reporters like `lcov`.
source: docs/runtime/bunfig.md#_snippet_17

language: toml
code:
```
[test]
coverageDir = "path/to/somewhere"  # default "coverage"
```

---

title: Creating File References with File Descriptors or URLs - TypeScript
description: Demonstrates how to create `BunFile` references using numerical file descriptors or `file://` URLs.  This allows referencing files by descriptor or by URL in addition to the standard path-based method.
source: docs/api/file-io.md#_snippet_2

language: typescript
code:
```
Bun.file(1234);
Bun.file(new URL(import.meta.url)); // reference to the current file
```

---

title: Overriding Default MIME Type - TypeScript
description: Demonstrates how to override the default MIME type when creating a `BunFile` instance.  The second argument to `Bun.file` can be an options object with a `type` property, which sets the MIME type for the file.
source: docs/api/file-io.md#_snippet_4

language: typescript
code:
```
const notreal = Bun.file("notreal.json", { type: "application/json" });
notreal.type; // => "application/json;charset=utf-8"
```

---

title: Deleting Files Using BunFile - TypeScript
description: Shows how to delete a file using the `.delete()` method of a `BunFile` object. This function removes the file from the file system.
source: docs/api/file-io.md#_snippet_5

language: typescript
code:
```
await Bun.file("logs.json").delete();
```

---

title: Writing a String to Disk - TypeScript
description: Demonstrates writing a string to a file using `Bun.write`. The first argument is the destination file path, and the second argument is the string data to be written.
source: docs/api/file-io.md#_snippet_6

language: typescript
code:
```
const data = `It was the best of times, it was the worst of times.`;
await Bun.write("output.txt", data);
```

---

title: Copying Files - JavaScript
description: Illustrates how to copy a file to another location using `Bun.write` and `Bun.file`. It creates a `BunFile` instance for both the input and output files, and then copies the content of the input file to the output file using `Bun.write`.
source: docs/api/file-io.md#_snippet_7

language: javascript
code:
```
const input = Bun.file("input.txt");
const output = Bun.file("output.txt"); // doesn't exist yet!
await Bun.write(output, input);
```

---

title: Writing a Byte Array to Disk - TypeScript
description: Shows how to write a `Uint8Array` to a file using `Bun.write`.  It encodes a string into a `Uint8Array` using `TextEncoder` and then writes the byte array to the specified file.
source: docs/api/file-io.md#_snippet_8

language: typescript
code:
```
const encoder = new TextEncoder();
const data = encoder.encode("datadatadata"); // Uint8Array
await Bun.write("output.txt", data);
```

---

title: Writing File to Standard Output - TypeScript
description: Demonstrates how to write the contents of a file to `stdout` using `Bun.write`. This effectively pipes the file's contents to the console.
source: docs/api/file-io.md#_snippet_9

language: typescript
code:
```
const input = Bun.file("input.txt");
await Bun.write(Bun.stdout, input);
```

---

title: Writing HTTP Response Body to Disk - TypeScript
description: Illustrates how to fetch a resource via HTTP and write the response body to a file using `Bun.write`. It fetches the content from a URL using `fetch` and writes the response to the specified file.
source: docs/api/file-io.md#_snippet_10

language: typescript
code:
```
const response = await fetch("https://bun.com");
await Bun.write("index.html", response);
```

---

title: Creating a FileSink Instance - TypeScript
description: Demonstrates retrieving a `FileSink` instance from a `BunFile` using the `.writer()` method. `FileSink` allows for incremental writing to a file.
source: docs/api/file-io.md#_snippet_11

language: typescript
code:
```
const file = Bun.file("output.txt");
const writer = file.writer();
```

---

title: Incrementally Writing to a File - TypeScript
description: Illustrates how to incrementally write to a file using the `FileSink` API.  The `.write()` method adds data to the internal buffer.
source: docs/api/file-io.md#_snippet_12

language: typescript
code:
```
const file = Bun.file("output.txt");
const writer = file.writer();

writer.write("it was the best of times\n");
writer.write("it was the worst of times\n");
```

---

title: Reading Directories with readdir - TypeScript
description: Demonstrates how to read the contents of a directory using `readdir` from the `node:fs/promises` module. This example reads all files in the current directory.
source: docs/api/file-io.md#_snippet_14

language: typescript
code:
```
import { readdir } from "node:fs/promises";

// read all the files in the current directory
const files = await readdir(import.meta.dir);
```

---

title: Reading Directories Recursively with readdir - TypeScript
description: Illustrates how to recursively read the contents of a directory using `readdir` with the `recursive: true` option from the `node:fs/promises` module. This reads all files in the specified directory and its subdirectories.
source: docs/api/file-io.md#_snippet_15

language: typescript
code:
```
import { readdir } from "node:fs/promises";

// read all the files in the current directory, recursively
const files = await readdir("../", { recursive: true });
```

---

title: Creating Directories Recursively - TypeScript
description: Shows how to recursively create a directory using `mkdir` from the `node:fs/promises` module. The `recursive: true` option creates all parent directories as needed.
source: docs/api/file-io.md#_snippet_16

language: typescript
code:
```
import { mkdir } from "node:fs/promises";

await mkdir("path/to/dir", { recursive: true });
```

---

title: Managing Sessions with Redis
description: Demonstrates creating and retrieving user sessions using Redis. The `createSession` function generates a unique session ID, stores user data with an expiration time, and returns the session ID. The `getSession` function retrieves the session data based on the session ID, returning `null` if the session does not exist.
source: docs/api/redis.md#_snippet_1

language: typescript
code:
```
async function createSession(userId, data) {
  const sessionId = crypto.randomUUID();
  const key = `session:${sessionId}`;

  // Store session with expiration
  await redis.hmset(key, [
    "userId",
    userId.toString(),
    "created",
    Date.now().toString(),
    "data",
    JSON.stringify(data),
  ]);
  await redis.expire(key, 86400); // 24 hours

  return sessionId;
}

async function getSession(sessionId) {
  const key = `session:${sessionId}`;

  // Get session data
  const exists = await redis.exists(key);
  if (!exists) return null;

  const [userId, created, data] = await redis.hmget(key, [
    "userId",
    "created",
    "data",
  ]);

  return {
    userId: Number(userId),
    created: Number(created),
    data: JSON.parse(data),
  };
}
```

---

title: Resolving Module Specifiers Using import.meta - TypeScript
description: Illustrates how to resolve module specifiers to URLs using `import.meta.resolve` in Bun. This function is equivalent to `import.meta.resolve` in browsers and allows you to determine the full URL of a module based on its specifier.
source: docs/api/import-meta.md#_snippet_1

language: typescript
code:
```
import.meta.resolve("zod"); // => "file:///path/to/project/node_modules/zod/index.js"
```

---

title: Suppressing Output Using Quiet - JavaScript
description: Shows how to suppress the standard output of a shell command in Bun Shell using the `.quiet()` method.  This prevents the command's output from being printed to the console.
source: docs/runtime/shell.md#_snippet_2

language: js
code:
```
import { $ } from "bun";

await $`echo "Hello World!"`.quiet(); // No output
```

---

title: Accessing Command Output as Text - JavaScript
description: Demonstrates how to capture the standard output of a shell command as a string using the `.text()` method in Bun Shell. The `.text()` method also automatically calls `.quiet()` to suppress direct output to the console.
source: docs/runtime/shell.md#_snippet_3

language: js
code:
```
import { $ } from "bun";

// .text() automatically calls .quiet() for you
const welcome = await $`echo "Hello World!"`.text();

console.log(welcome); // Hello World!\n
```

---

title: Capturing Stdout and Stderr as Buffers - JavaScript
description: Explains how to access the standard output (`stdout`) and standard error (`stderr`) of a shell command as `Buffer` objects in Bun Shell.  It retrieves `stdout` and `stderr` after suppressing console output using `.quiet()`.
source: docs/runtime/shell.md#_snippet_4

language: js
code:
```
import { $ } from "bun";

const { stdout, stderr } = await $`echo "Hello!"`.quiet();

console.log(stdout); // Buffer(7) [ 72, 101, 108, 108, 111, 33, 10 ]
console.log(stderr); // Buffer(0) []
```

---

title: Handling Shell Errors - JavaScript
description: Illustrates how to handle errors thrown by shell commands in Bun Shell when they exit with a non-zero exit code.  It uses a `try...catch` block to catch the `ShellError` and access information like the exit code, standard output, and standard error.
source: docs/runtime/shell.md#_snippet_5

language: js
code:
```
import { $ } from "bun";

 try {
  const output = await $`something-that-may-fail`.text();
  console.log(output);
} catch (err) {
  console.log(`Failed with code ${err.exitCode}`);
  console.log(err.stdout.toString());
  console.log(err.stderr.toString());
}
```

---

title: Redirecting Output to Javascript Objects - JavaScript
description: Demonstrates redirecting the standard output of a shell command to a JavaScript `Buffer` object using the `>` operator in Bun Shell. The example redirects the output of `echo "Hello World!"` to the specified buffer.
source: docs/runtime/shell.md#_snippet_8

language: js
code:
```
import { $ } from "bun";

const buffer = Buffer.alloc(100);
await $`echo "Hello World!" > ${buffer}`;

console.log(buffer.toString()); // Hello World!\n
```

---

title: Redirecting Input From Javascript Objects - JavaScript
description: Illustrates redirecting the standard input of a shell command from a JavaScript `Response` object using the `<` operator in Bun Shell. It redirects the body of the `Response` object to the `cat` command, which then outputs the content.
source: docs/runtime/shell.md#_snippet_9

language: js
code:
```
import { $ } from "bun";

const response = new Response("hello i am a response body");

const result = await $`cat < ${response}`.text();

console.log(result); // hello i am a response body
```

---

title: Redirecting Stdin to File - JavaScript
description: Demonstrates how to redirect the standard input of a command from a file using the `<` operator in Bun Shell.  The `cat` command reads from `myfile.txt`.
source: docs/runtime/shell.md#_snippet_10

language: js
code:
```
import { $ } from "bun";

await $`cat < myfile.txt`;
```

---

title: Redirecting Stdout to File - JavaScript
description: Illustrates redirecting the standard output of a command to a file using the `>` operator in Bun Shell.  The `echo` command writes "bun!" to `greeting.txt`.
source: docs/runtime/shell.md#_snippet_11

language: js
code:
```
import { $ } from "bun";

await $`echo bun! > greeting.txt`;
```

---

title: Redirecting Stderr to File - JavaScript
description: Demonstrates redirecting the standard error of a command to a file using the `2>` operator in Bun Shell. The `bun run index.ts` command's errors are written to `errors.txt`.
source: docs/runtime/shell.md#_snippet_12

language: js
code:
```
import { $ } from "bun";

await $`bun run index.ts 2> errors.txt`;
```

---

title: Redirecting Stderr to Stdout - JavaScript
description: Shows how to redirect standard error to standard output using the `2>&1` operator in Bun Shell.  All output, including errors, from `bun run ./index.ts` will be available on standard output.
source: docs/runtime/shell.md#_snippet_13

language: js
code:
```
import { $ } from "bun";

// redirects stderr to stdout, so all output
// will be available on stdout
await $`bun run ./index.ts 2>&1`;
```

---

title: Redirecting Stdout to Stderr - JavaScript
description: Shows how to redirect standard output to standard error using the `1>&2` operator in Bun Shell.  All output from `bun run ./index.ts` will be available on standard error.
source: docs/runtime/shell.md#_snippet_14

language: js
code:
```
import { $ } from "bun";

// redirects stdout to stderr, so all output
// will be available on stderr
await $`bun run ./index.ts 1>&2`;
```

---

title: Piping Command Output - JavaScript
description: Demonstrates piping the output of one shell command to another using the `|` operator in Bun Shell. The example pipes the output of `echo "Hello World!"` to `wc -w` to count the number of words.
source: docs/runtime/shell.md#_snippet_15

language: js
code:
```
import { $ } from "bun";

const result = await $`echo "Hello World!" | wc -w`.text();

console.log(result); // 2\n
```

---

title: Piping with Javascript Objects - JavaScript
description: Illustrates piping the output from a JavaScript `Response` object to a shell command using the `|` operator in Bun Shell.  It pipes the body of the `Response` object to `wc -w` to count the number of words.
source: docs/runtime/shell.md#_snippet_16

language: js
code:
```
import { $ } from "bun";

const response = new Response("hello i am a response body");

const result = await $`cat < ${response} | wc -w`.text();

console.log(result); // 6\n
```

---

title: Using Command Substitution - JavaScript
description: Shows how to use command substitution to insert the output of one command into another using the `$(...)` syntax in Bun Shell. The example inserts the output of `git rev-parse HEAD` into an `echo` command.
source: docs/runtime/shell.md#_snippet_17

language: js
code:
```
import { $ } from "bun";

// Prints out the hash of the current commit
await $`echo Hash of current commit: $(git rev-parse HEAD)`;
```

---

title: Declaring Shell Variables with Command Substitution - JavaScript
description: Demonstrates declaring shell variables using command substitution in Bun Shell.  The output of `git rev-parse HEAD` is assigned to the `REV` variable and used in subsequent commands to build and tag a Docker image.
source: docs/runtime/shell.md#_snippet_18

language: js
code:
```
import { $ } from "bun";

await $`
  REV=$(git rev-parse HEAD)
  docker built -t myapp:$REV
  echo Done building docker image "myapp:$REV"
`;
```

---

title: Setting Environment Variables - JavaScript
description: Illustrates how to set environment variables within a Bun Shell command using the `FOO=value` syntax. The example sets the `FOO` environment variable and then accesses it using `process.env.FOO` within a `bun -e` command.
source: docs/runtime/shell.md#_snippet_19

language: js
code:
```
import { $ } from "bun";

await $`FOO=foo bun -e 'console.log(process.env.FOO)'`; // foo\n
```

---

title: Using String Interpolation for Environment Variables - JavaScript
description: Demonstrates using string interpolation to set environment variables in a Bun Shell command. The example sets `FOO` by concatenating strings and then accesses it using `process.env.FOO`.
source: docs/runtime/shell.md#_snippet_20

language: js
code:
```
import { $ } from "bun";

const foo = "bar123";

await $`FOO=${foo + "456"} bun -e 'console.log(process.env.FOO)'`; // bar123456\n
```

---

title: Escaping Shell Injection Attacks - JavaScript
description: Shows how Bun Shell escapes strings by default, preventing shell injection attacks. The example sets `FOO` to a string containing a potentially dangerous command and then demonstrates that it's treated as a literal string.
source: docs/runtime/shell.md#_snippet_21

language: js
code:
```
import { $ } from "bun";

const foo = "bar123; rm -rf /tmp";

await $`FOO=${foo} bun -e 'console.log(process.env.FOO)'`; // bar123; rm -rf /tmp\n
```

---

title: Changing Environment Variables for a Single Command - JavaScript
description: Illustrates how to change the environment variables for a single command using the `.env()` method in Bun Shell. This allows for overriding environment variables without affecting the global `process.env`.
source: docs/runtime/shell.md#_snippet_22

language: js
code:
```
import { $ } from "bun";

await $`echo $FOO`.env({ ...process.env, FOO: "bar" }); // bar
```

---

title: Changing Default Environment Variables - JavaScript
description: Demonstrates how to change the default environment variables for all commands using `$.env()` in Bun Shell. It shows how to set a global environment variable and then override it locally for a specific command.
source: docs/runtime/shell.md#_snippet_23

language: js
code:
```
import { $ } from "bun";

$.env({ FOO: "bar" });

// the globally-set $FOO
await $`echo $FOO`; // bar

// the locally-set $FOO
await $`echo $FOO`.env({ FOO: "baz" }); // baz
```

---

title: Resetting Environment Variables to Default - JavaScript
description: Illustrates how to reset the environment variables to the default `process.env` by calling `$.env()` with no arguments in Bun Shell. This effectively removes any globally set environment variables.
source: docs/runtime/shell.md#_snippet_24

language: js
code:
```
import { $ } from "bun";

$.env({ FOO: "bar" });

// the globally-set $FOO
await $`echo $FOO`; // bar

// the locally-set $FOO
await $`echo $FOO`.env(undefined); // ""
```

---

title: Changing the Working Directory - JavaScript
description: Demonstrates how to change the working directory of a command using the `.cwd()` method in Bun Shell.  The `pwd` command's output reflects the changed directory.
source: docs/runtime/shell.md#_snippet_25

language: js
code:
```
import { $ } from "bun";

await $`pwd`.cwd("/tmp"); // /tmp
```

---

title: Setting Default Working Directory - JavaScript
description: Shows how to change the default working directory for all commands using `$.cwd` in Bun Shell. It also shows how to override the default working directory for a specific command using `.cwd()`.
source: docs/runtime/shell.md#_snippet_26

language: js
code:
```
import { $ } from "bun";

$.cwd("/tmp");

// the globally-set working directory
await $`pwd`; // /tmp

// the locally-set working directory
await $`pwd`.cwd("/"); // /
```

---

title: Reading Output as String - JavaScript
description: Demonstrates how to read the output of a shell command as a string using the `.text()` method in Bun Shell. The standard output of `echo "Hello World!"` is captured and logged to the console.
source: docs/runtime/shell.md#_snippet_27

language: js
code:
```
import { $ } from "bun";

const result = await $`echo "Hello World!"`.text();

console.log(result); // Hello World!\n
```

---

title: Establishing UDP Connections - TypeScript
description: Illustrates how to establish a UDP "connection" using the `connect` option.  This restricts communication to a single peer and potentially improves performance.  The server defines the `data` handler, while the client connects and sends a message to the server.
source: docs/api/udp.md#_snippet_3

language: typescript
code:
```
const server = await Bun.udpSocket({
  socket: {
    data(socket, buf, port, addr) {
      console.log(`message from ${addr}:${port}:`);
      console.log(buf.toString());
    },
  },
});
const client = await Bun.udpSocket({
  connect: {
    port: server.port,
    hostname:
```

---

title: Configuring Database Connection Manually - TypeScript
description: Demonstrates how to configure a database connection manually by passing options to the `SQL` constructor. Includes options for connection details, connection pooling, SSL/TLS, and connection callbacks. These options allow fine-grained control over the database connection.
source: docs/api/sql.md#_snippet_1

language: typescript
code:
```
import { SQL } from "bun";

const db = new SQL({
  // Required
  url: "postgres://user:pass@localhost:5432/dbname",

  // Optional configuration
  hostname: "localhost",
  port: 5432,
  database: "myapp",
  username: "dbuser",
  password: "secretpass",

  // Connection pool settings
  max: 20, // Maximum connections in pool
  idleTimeout: 30, // Close idle connections after 30s
  maxLifetime: 0, // Connection lifetime in seconds (0 = forever)
  connectionTimeout: 30, // Timeout when establishing new connections

  // SSL/TLS options
  tls: true,
  // tls: {
  //   rejectUnauthorized: true,
  //   requestCert: true,
  //   ca: "path/to/ca.pem",
  //   key: "path/to/key.pem",
  //   cert: "path/to/cert.pem",
  //   checkServerIdentity(hostname, cert) {
  //     ...
  //   },
  // },

  // Callbacks
  onconnect: client => {
    console.log("Connected to database");
  },
  onclose: client => {
    console.log("Connection closed");
  },
});
```

---

title: Implementing Basic Transactions - TypeScript
description: Illustrates how to use `sql.begin` to start a new transaction, which reserves a dedicated connection for the duration of the transaction. The `BEGIN` command is sent automatically and the code will automatically `ROLLBACK` if any error occurs during the transaction. Shows a basic usage example with insert and update statements.
source: docs/api/sql.md#_snippet_3

language: typescript
code:
```
await sql.begin(async tx => {
  // All queries in this function run in a transaction
  await tx`INSERT INTO users (name) VALUES (${'Alice'})`;
  await tx`UPDATE accounts SET balance = balance - 100 WHERE user_id = 1`;

  // Transaction automatically commits if no errors are thrown
  // Rolls back if any error occurs
});
```

---

title: Pipelining Requests in a Transaction - TypeScript
description: Demonstrates how to pipeline requests in a transaction by returning an array of queries from the callback function of `sql.begin`. This approach allows efficient execution of multiple queries within a single transaction. Shows usage of insert and update statements.
source: docs/api/sql.md#_snippet_4

language: typescript
code:
```
await sql.begin(async tx => {
  return [
    tx`INSERT INTO users (name) VALUES (${'Alice'})`,
    tx`UPDATE accounts SET balance = balance - 100 WHERE user_id = 1`,
  ];
});
```

---

title: Serializing Objects to String with Inspect
description: Demonstrates using `Bun.inspect` to serialize a JavaScript object to a string, mimicking the output of `console.log`.  The example showcases its usage with both a simple object and a `Uint8Array`.
source: docs/api/utils.md#_snippet_3

language: ts
code:
```
const obj = { foo:
```

---

title: Customizing Inspect Output
description: Illustrates how to customize the output of `Bun.inspect` for a class using the `Bun.inspect.custom` symbol.  By defining a method with this symbol, you can control how instances of your class are represented when inspected.
source: docs/api/utils.md#_snippet_4

language: ts
code:
```
class Foo {
  [Bun.inspect.custom]() {
    return
```

---

title: Formatting Tabular Data
description: Shows how to format tabular data into a string using `Bun.inspect.table`, similar to `console.table`. The example demonstrates displaying all properties and a subset of properties and enabling ANSI colors.
source: docs/api/utils.md#_snippet_5

language: ts
code:
```
console.log(
  Bun.inspect.table([
    { a: 1, b: 2, c: 3 },
    { a: 4, b: 5, c: 6 },
    { a: 7, b: 8, c: 9 },
  ]),
);
//
// â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
// â”‚   â”‚ a â”‚ b â”‚ c â”‚
// â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤
// â”‚ 0 â”‚ 1 â”‚ 2 â”‚ 3 â”‚
// â”‚ 1 â”‚ 4 â”‚ 5 â”‚ 6 â”‚
// â”‚ 2 â”‚ 7 â”‚ 8 â”‚ 9 â”‚
// â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
```

language: ts
code:
```
console.log(
  Bun.inspect.table(
    [
      { a: 1, b: 2, c: 3 },
      { a: 4, b: 5, c: 6 },
    ],
    [
```

language: ts
code:
```
console.log(
  Bun.inspect.table(
    [
      { a: 1, b: 2, c: 3 },
      { a: 4, b: 5, c: 6 },
    ],
    {
      colors: true,
    },
  ),
);
```

---

title: Measuring Nanoseconds Since Process Start
description: Demonstrates using `Bun.nanoseconds()` to get the number of nanoseconds since the current Bun process started. This is useful for high-precision timing and benchmarking.
source: docs/api/utils.md#_snippet_6

language: ts
code:
```
Bun.nanoseconds();
// => 7288958
```

---

title: Converting ReadableStream to Binary Formats
description: Illustrates the usage of `Bun.readableStreamTo*()` functions to asynchronously convert a `ReadableStream`'s body into various binary formats.  This includes `ArrayBuffer`, `Uint8Array`, `Blob`, JSON object, string, array, and FormData objects.
source: docs/api/utils.md#_snippet_7

language: ts
code:
```
const stream = (await fetch(
```

---

title: Resolving File Paths and Module Specifiers
description: Demonstrates using `Bun.resolveSync()` to resolve a file path or module specifier using Bun's internal module resolution algorithm. The examples shows how to resolve relative to a project path, current working directory, and the directory containing the current file.
source: docs/api/utils.md#_snippet_8

language: ts
code:
```
Bun.resolveSync(
```

language: ts
code:
```
Bun.resolveSync(
```

language: ts
code:
```
Bun.resolveSync(
```

---

title: Serializing and Deserializing With BunJSC
description: Demonstrates using `serialize` and `deserialize` from the `bun:jsc` module to save a JavaScript value into an ArrayBuffer and back. This provides access to the underlying HTML Structured Clone Algorithm.
source: docs/api/utils.md#_snippet_9

language: js
code:
```
import { serialize, deserialize } from
```

---

title: Performing a Bulk Insert - TypeScript
description: Demonstrates how to perform a bulk insert into a PostgreSQL table using Bun's SQL client. This approach allows inserting multiple rows at once by passing an array of objects to the `sql` template literal.  Bun automatically expands the array into an `INSERT INTO ... VALUES ...` statement, improving efficiency for inserting multiple records.
source: docs/api/sql.md#_snippet_2

language: ts
code:
```
const users = [
  { name: "Alice", email: "alice@example.com" },
  { name: "Bob", email: "bob@example.com" },
  { name: "Charlie", email: "charlie@example.com" },
];

await sql`INSERT INTO users ${sql(users)}`;
```

---

title: Formatting Query Results as Arrays of Values - TypeScript
description: Demonstrates how to use the `sql``.values()` method to retrieve query results as arrays of values instead of objects using Bun's SQL client. This can be useful when dealing with duplicate column names or when a more compact data structure is preferred. The returned arrays maintain the order of the columns as defined in the query.
source: docs/api/sql.md#_snippet_4

language: ts
code:
```
const rows = await sql`SELECT * FROM users`.values();
console.log(rows);
```

language: ts
code:
```
[
  ["Alice", "alice@example.com"],
  ["Bob", "bob@example.com"],
];
```

---

title: Building Conditional Queries - TypeScript
description: Demonstrates how to build conditional queries using Bun's SQL client, allowing for flexible queries based on runtime conditions. By utilizing the `sql()` helper and conditional logic, optional `WHERE` clauses can be dynamically added to the query.  This creates adaptable queries that adjust to your application's needs.
source: docs/api/sql.md#_snippet_7

language: ts
code:
```
// Optional WHERE clauses
const filterAge = true;
const minAge = 21;
const ageFilter = sql`AND age > ${minAge}`;
await sql`
  SELECT * FROM users
  WHERE active = ${true}
  ${filterAge ? ageFilter : sql``}
`;
```

---

title: Creating Dynamic Value Lists for Where In Queries - TypeScript
description: Demonstrates how to create dynamic value lists for `WHERE IN` queries using Bun's SQL client. The `sql()` helper allows you to pass an array of values to the query, which is then safely expanded into the `IN` clause.  This enables building flexible queries that filter based on a variable number of values.
source: docs/api/sql.md#_snippet_9

language: ts
code:
```
await sql`SELECT * FROM users WHERE id IN ${sql([1, 2, 3])}`;

const users = [
  { id: 1, name: "Alice" },
  { id: 2, name: "Bob" },
  { id: 3, name: "Charlie" },
];
await sql`SELECT * FROM users WHERE id IN ${sql(users, "id")}`;
```

---

title: Executing and Cancelling Queries - TypeScript
description: Demonstrates how to execute and cancel queries using Bun's SQL client.  The `execute()` method starts the query execution, and the `cancel()` method can be used to stop a query that is currently running. Bun's SQL is lazy, which means it will only start executing when awaited or executed with `.execute()`.
source: docs/api/sql.md#_snippet_13

language: ts
code:
```
const query = await sql`SELECT * FROM users`.execute();
setTimeout(() => query.cancel(), 100);
await query;
```

---

title: Handling ArrayBuffer Size Constraints with Typed Arrays
description: Illustrates the `RangeError` that occurs when trying to create a `Uint32Array` from an `ArrayBuffer` whose length is not a multiple of the element size (4 bytes). This error highlights the constraint that the `ArrayBuffer`'s length must be divisible by the element size of the typed array.
source: docs/api/binary-data.md#_snippet_1

language: ts
code:
```
const buf = new ArrayBuffer(10);
const arr = new Uint32Array(buf);
//          ^  RangeError: ArrayBuffer length minus the byteOffset
//             is not a multiple of the element size
```

---

title: Creating Typed Array from ArrayBuffer Slice
description: Shows how to create a typed array (`Uint32Array`) that views only a slice of an `ArrayBuffer` by specifying a `byteOffset` and `length`. This allows using only a portion of the `ArrayBuffer` when the entire buffer is not needed or doesn't align with the typed array's element size.
source: docs/api/binary-data.md#_snippet_2

language: ts
code:
```
// create typed array from ArrayBuffer slice
const buf = new ArrayBuffer(10);
const arr = new Uint32Array(buf, 0, 2);

/*
  buf    _ _ _ _ _ _ _ _ _ _    10 bytes
  arr   [_______,_______]       2 4-byte elements
*/

arr.byteOffset; // 0
arr.length; // 2
```

---

title: Using Common Array Methods with Typed Arrays
description: Demonstrates that typed arrays support common array methods like `filter`, `map`, `reduce`, `forEach`, `every`, `find`, `includes`, and `indexOf`. This makes typed arrays easy to use when performing data transformations or queries.
source: docs/api/binary-data.md#_snippet_5

language: ts
code:
```
const arr = new Uint8Array([0, 1, 2, 3, 4, 5, 6, 7]);

// supports common array methods
arr.filter(n => n > 128); // Uint8Array(1) [255]
arr.map(n => n * 2); // Uint8Array(8) [0, 2, 4, 6, 8, 10, 12, 14]
arr.reduce((acc, n) => acc + n, 0); // 28
arr.forEach(n => console.log(n)); // 0 1 2 3 4 5 6 7
arr.every(n => n < 10); // true
arr.find(n => n > 5); // 6
arr.includes(5); // true
arr.indexOf(5); // 5
```

---

title: Converting Uint8Array to Base64 and Hex
description: Illustrates how to convert a `Uint8Array` to a base64 or hex string representation using the `toBase64()` and `toHex()` methods, respectively. It also demonstrates the reverse operation using `Uint8Array.fromBase64()` and `Uint8Array.fromHex()`.  These methods are available in Bun and some other JavaScript engines.
source: docs/api/binary-data.md#_snippet_6

language: ts
code:
```
new Uint8Array([1, 2, 3, 4, 5]).toBase64(); // "AQIDBA=="
Uint8Array.fromBase64("AQIDBA=="); // Uint8Array(4) [1, 2, 3, 4, 5 ]

new Uint8Array([255, 254, 253, 252, 251]).toHex(); // "fffefdfcfb=="
Uint8Array.fromHex("fffefdfcfb"); // Uint8Array(5) [255, 254, 253, 252, 251]
```

---

title: Working With Buffer (Node.js API)
description: Illustrates how to create a `Buffer` from a string, access its length, read and write individual bytes, and convert it back to a string. The `Buffer` API, originally from Node.js, is now often implemented as a subclass of `Uint8Array`.
source: docs/api/binary-data.md#_snippet_8

language: ts
code:
```
const buf = Buffer.from("hello world");
// => Buffer(11) [ 104, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100 ]

buf.length; // => 11
buf[0]; // => 104, ascii for 'h'
buf.writeUInt8(72, 0); // => ascii for 'H'

console.log(buf.toString());
// => Hello world
```

---

title: Creating a Blob Instance
description: Demonstrates how to create a `Blob` object from an array of string or binary parts, and setting the `type` property, which represents the MIME type of the data in the `Blob`.  Blobs are commonly used to represent file-like objects in JavaScript.
source: docs/api/binary-data.md#_snippet_9

language: ts
code:
```
const blob = new Blob(["<html>Hello</html>"], {
  type: "text/html",
});

blob.type; // => text/html
blob.size; // => 19
```

---

title: Reading Blob Contents Asynchronously
description: Shows how to asynchronously read the contents of a `Blob` in different formats using the `text()`, `bytes()`, `arrayBuffer()`, and `stream()` methods. This demonstrates the flexibility of retrieving blob data for various use cases.
source: docs/api/binary-data.md#_snippet_11

language: ts
code:
```
await blob.text(); // => <html><body>hello</body></html>
await blob.bytes(); // => Uint8Array (copies contents)
await blob.arrayBuffer(); // => ArrayBuffer (copies contents)
await blob.stream(); // => ReadableStream
```

---

title: Overriding Loader Option During Transformation - TypeScript
description: Shows how to override the default `loader` specified in the `Bun.Transpiler` constructor.  A second argument to `.transformSync()` sets the loader, allowing for on-the-fly language specification.
source: docs/api/transpiler.md#_snippet_2

language: typescript
code:
```
transpiler.transformSync("<div>hi!</div>", "tsx");
```

---

title: Specifying Loader During Asynchronous Transformation - TypeScript
description: Shows how to specify the loader type when using the asynchronous `transform` method. This overrides the default loader set in the `Bun.Transpiler` constructor.
source: docs/api/transpiler.md#_snippet_4

language: typescript
code:
```
await transpiler.transform("<div>hi!</div>", "tsx");
```

---

title: Getting a Cookie by Name
description: Demonstrates how to retrieve a cookie's value using the `get` method of a `Bun.CookieMap` instance.  It shows how to safely access the cookie value, handling the case where the cookie might not exist (returning `null`).
source: docs/api/cookie.md#_snippet_2

language: typescript
code:
```
// Get by name
const cookie = cookies.get("session");

if (cookie != null) {
  console.log(cookie);
}
```

---

title: Checking for Cookie Existence
description: Illustrates checking if a cookie with a specific name exists in a `Bun.CookieMap` using the `has` method. This is useful for conditional logic based on the presence of a cookie.
source: docs/api/cookie.md#_snippet_3

language: typescript
code:
```
// Check if cookie exists
if (cookies.has("session")) {
  // Cookie exists
}
```

---

title: Setting Cookies in a Map
description: Demonstrates different ways to set cookies in a `Bun.CookieMap` using the `set` method: by name and value, with an options object (`CookieInit`), and with a `Bun.Cookie` instance.  The options object allows for setting cookie attributes like `maxAge` and `secure`.
source: docs/api/cookie.md#_snippet_4

language: typescript
code:
```
// Set by name and value
cookies.set("session", "abc123");

// Set using options object
cookies.set({
  name: "theme",
  value: "dark",
  maxAge: 3600,
  secure: true,
});

// Set using Cookie instance
const cookie = new Bun.Cookie("visited", "true");
cookies.set(cookie);
```

---

title: Deleting Cookies from a Map
description: Demonstrates how to delete cookies from a `Bun.CookieMap` using the `delete` method, both by name and with a `CookieStoreDeleteOptions` object for specifying domain and path. This is crucial for managing cookie expiration and security.
source: docs/api/cookie.md#_snippet_5

language: typescript
code:
```
// Delete by name using default domain and path.
cookies.delete("session");

// Delete with domain/path options.
cookies.delete({
  name: "session",
  domain: "example.com",
  path: "/admin",
});
```

---

title: Generating Set-Cookie Headers
description: Demonstrates how to generate an array of `Set-Cookie` headers from a `Bun.CookieMap` using `toSetCookieHeaders()`.  This is primarily useful when integrating with HTTP servers other than `Bun.serve()` where cookie changes are not automatically applied to response headers. It shows an example with Node.js's `http` module.
source: docs/api/cookie.md#_snippet_7

language: javascript
code:
```
import { createServer } from "node:http";
import { CookieMap } from "bun";

const server = createServer((req, res) => {
  const cookieHeader = req.headers.cookie || "";
  const cookies = new CookieMap(cookieHeader);

  cookies.set("view-count", Number(cookies.get("view-count") || "0") + 1);
  cookies.delete("session");

  res.writeHead(200, {
    "Content-Type": "text/plain",
    "Set-Cookie": cookies.toSetCookieHeaders(),
  });
  res.end(`Found ${cookies.size} cookies`);
});

server.listen(3000, () => {
  console.log("Server running at http://localhost:3000/");
});
```

---

title: Iterating over Cookies in a Map
description: Illustrates the various methods for iterating over cookies within a `Bun.CookieMap`, including `for...of` with `entries()`, `keys()`, `values()`, and `forEach`. These methods provide flexibility for accessing and processing cookie data.
source: docs/api/cookie.md#_snippet_8

language: typescript
code:
```
// Iterate over [name, cookie] entries
for (const [name, value] of cookies) {
  console.log(`${name}: ${value}`);
}

// Using entries()
for (const [name, value] of cookies.entries()) {
  console.log(`${name}: ${value}`);
}

// Using keys()
for (const name of cookies.keys()) {
  console.log(name);
}

// Using values()
for (const value of cookies.values()) {
  console.log(value);
}

// Using forEach
cookies.forEach((value, name) => {
  console.log(`${name}: ${value}`);
});
```

---

title: Checking if a Cookie is Expired
description: Illustrates how to check if a `Bun.Cookie` has expired using the `isExpired()` method.  It covers cookies with an `expires` date in the past, a `maxAge` that hasn't elapsed, and session cookies without explicit expiration.
source: docs/api/cookie.md#_snippet_11

language: typescript
code:
```
// Expired cookie (Date in the past)
const expiredCookie = new Bun.Cookie("name", "value", {
  expires: new Date(Date.now() - 1000),
});
console.log(expiredCookie.isExpired()); // true

// Valid cookie (Using maxAge instead of expires)
const validCookie = new Bun.Cookie("name", "value", {
  maxAge: 3600, // 1 hour in seconds
});
console.log(validCookie.isExpired()); // false

// Session cookie (no expiration)
const sessionCookie = new Bun.Cookie("name", "value");
console.log(sessionCookie.isExpired()); // false
```

---

title: Serializing a Cookie to a String
description: Demonstrates how to serialize a `Bun.Cookie` instance into a string representation suitable for use in a `Set-Cookie` HTTP header using the `serialize()` or `toString()` methods.  This converts the cookie into the correct format for sending in a response.
source: docs/api/cookie.md#_snippet_12

language: typescript
code:
```
const cookie = new Bun.Cookie("session", "abc123", {
  domain: "example.com",
  path: "/admin",
  expires: new Date(Date.now() + 86400000),
  secure: true,
  httpOnly: true,
  sameSite: "strict",
});

console.log(cookie.serialize());
// => "session=abc123; Domain=example.com; Path=/admin; Expires=Sun, 19 Mar 2025 15:03:26 GMT; Secure; HttpOnly; SameSite=strict"
console.log(cookie.toString());
// => "session=abc123; Domain=example.com; Path=/admin; Expires=Sun, 19 Mar 2025 15:03:26 GMT; Secure; HttpOnly; SameSite=strict"
```

---

title: Converting a Cookie to JSON
description: Demonstrates how to convert a `Bun.Cookie` instance into a plain JavaScript object suitable for JSON serialization using the `toJSON()` method. It preserves the cookie's attributes, making it easy to store or transmit the cookie data as a JSON string.
source: docs/api/cookie.md#_snippet_13

language: typescript
code:
```
const cookie = new Bun.Cookie("session", "abc123", {
  secure: true,
  httpOnly: true,
});

const json = cookie.toJSON();
// => {
//   name: "session",
//   value: "abc123",
//   path: "/",
//   secure: true,
//   httpOnly: true,
//   sameSite: "lax",
//   partitioned: false
// }

// Works with JSON.stringify
const jsonString = JSON.stringify(cookie);
```

---

title: Parsing a Cookie String
description: Demonstrates how to parse a cookie string into a `Bun.Cookie` instance using the static `Cookie.parse()` method. This allows you to easily extract cookie attributes from a string representation.
source: docs/api/cookie.md#_snippet_14

language: typescript
code:
```
const cookie = Bun.Cookie.parse("name=value; Path=/; Secure; SameSite=Lax");

console.log(cookie.name); // "name"
console.log(cookie.value); // "value"
console.log(cookie.path); // "/"
console.log(cookie.secure); // true
console.log(cookie.sameSite); // "lax"
```

---

title: Creating a Cookie Using a Factory Method
description: Demonstrates how to create a `Bun.Cookie` instance using the static `Cookie.from()` factory method.  This provides a convenient way to instantiate cookies with specified options.
source: docs/api/cookie.md#_snippet_15

language: typescript
code:
```
const cookie = Bun.Cookie.from("session", "abc123", {
  httpOnly: true,
  secure: true,
  maxAge: 3600,
});
```

---

title: Accessing Bun Version
description: Exposes the version of the Bun runtime via `Bun.version`. This can be useful for conditional logic based on available features or bug fixes in specific Bun versions.
source: docs/api/utils.md#_snippet_0

language: typescript
code:
```
Bun.version;
// => "0.6.4"
```

---

title: Accessing Bun Revision
description: Shows the git commit hash of the Bun runtime via `Bun.revision`. This can be helpful for debugging or identifying specific builds.
source: docs/api/utils.md#_snippet_1

language: typescript
code:
```
Bun.revision;
// => "f02561530fda1ee9396f51c8bc99b38716e38296"
```

---

title: Pausing Execution Asynchronously
description: Illustrates the use of `Bun.sleep()` to pause the execution of an asynchronous function for a specified number of milliseconds or until a specific `Date`. It returns a `Promise` that resolves after the specified time.
source: docs/api/utils.md#_snippet_3

language: typescript
code:
```
console.log("hello");
await Bun.sleep(1000);
console.log("hello one second later!");
```

language: typescript
code:
```
const oneSecondInFuture = new Date(Date.now() + 1000);

console.log("hello");
await Bun.sleep(oneSecondInFuture);
console.log("hello one second later!");
```

---

title: Pausing Execution Synchronously
description: Shows how to use `Bun.sleepSync()` to block the current thread for a specified number of milliseconds. This is a synchronous, blocking operation.
source: docs/api/utils.md#_snippet_4

language: typescript
code:
```
console.log("hello");
Bun.sleepSync(1000); // blocks thread for one second
console.log("hello one second later!");
```

---

title: Finding Executable Path
description: Demonstrates how to find the absolute path to an executable using `Bun.which()`, similar to the `which` command in a terminal. It uses the `PATH` environment variable by default.
source: docs/api/utils.md#_snippet_5

language: typescript
code:
```
const ls = Bun.which("ls");
console.log(ls); // "/usr/bin/ls"
```

---

title: Opening File In Editor
description: Illustrates how to open a file in your default editor using `Bun.openInEditor()`. Bun auto-detects the editor using `$VISUAL` or `$EDITOR` environment variables.
source: docs/api/utils.md#_snippet_12

language: typescript
code:
```
const currentFile = import.meta.url;
Bun.openInEditor(currentFile);
```

---

title: Performing Deep Equals Comparison
description: Illustrates how to use `Bun.deepEquals()` to recursively check if two objects are equivalent. It's similar to `expect().toEqual()` in `bun:test`.
source: docs/api/utils.md#_snippet_15

language: typescript
code:
```
const foo = { a: 1, b: 2, c: { d: 3 } };

// true
Bun.deepEquals(foo, { a: 1, b: 2, c: { d: 3 } });

// false
Bun.deepEquals(foo, { a: 1, b: 2, c: { d: 4 } });
```

---

title: Escaping HTML String
description: Shows how to escape specific characters in a string using `Bun.escapeHTML()`.  It is optimized for performance with large inputs.
source: docs/api/utils.md#_snippet_18

language: typescript
code:
```
Bun.escapeHTML(value: string | object | number | boolean): string
```

---

title: Calculating String Width
description: Demonstrates how to calculate the column width of a string for terminal display using `Bun.stringWidth()`.  It supports ANSI escape codes, emoji, and wide characters.
source: docs/api/utils.md#_snippet_19

language: typescript
code:
```
Bun.stringWidth("hello"); // => 5
Bun.stringWidth("\u001b[31mhello\u001b[0m"); // => 5
Bun.stringWidth("\u001b[31mhello\u001b[0m", { countAnsiEscapeCodes: true }); // => 12
```

---

title: Reading Data From a Pointer With DataView - Bun:ffi
description: Demonstrates how to read data from a pointer using a `DataView`. This method is suitable for long-lived pointers. The example reads four `Uint8` values from the memory pointed to by `myPtr`.
source: docs/api/ffi.md#_snippet_2

language: typescript
code:
```
import { toArrayBuffer } from "bun:ffi";
let myDataView = new DataView(toArrayBuffer(myPtr, 0, 32));

console.log(
  myDataView.getUint8(0, true),
  myDataView.getUint8(1, true),
  myDataView.getUint8(2, true),
  myDataView.getUint8(3, true),
);
```

---

title: Reading Data From a Pointer With Read - Bun:ffi
description: Illustrates how to read data from a pointer using the `read` function from `bun:ffi`. This method is faster than `DataView` for short-lived pointers because it avoids creating a `DataView` or `ArrayBuffer`. The example reads four `Uint8` values from memory using `read.u8`.
source: docs/api/ffi.md#_snippet_3

language: typescript
code:
```
import { read } from "bun:ffi";

console.log(
  // ptr, byteOffset
  read.u8(myPtr, 0),
  read.u8(myPtr, 1),
  read.u8(myPtr, 2),
  read.u8(myPtr, 3),
);
```

---

title: Passing a Pointer to FFI Functions - Bun:ffi
description: Demonstrates how to pass a `TypedArray` as a pointer to an FFI function using `dlopen` from `bun:ffi`. The `encode_png` function expects a pointer, width, and height.  The example shows how to create a `Uint8ClampedArray` and pass it to the `encode_png` function.
source: docs/api/ffi.md#_snippet_5

language: typescript
code:
```
import { dlopen, FFIType } from "bun:ffi";

const {
  symbols: { encode_png },
} = dlopen(myLibraryPath, {
  encode_png: {
    // FFIType's can be specified as strings too
    args: ["ptr", "u32", "u32"],
    returns: FFIType.ptr,
  },
});

const pixels = new Uint8ClampedArray(128 * 128 * 4);
pixels.fill(254);
pixels.subarray(0, 32 * 32 * 2).fill(0);

const out = encode_png(
  // pixels will be passed as a pointer
  pixels,

  128,
  128,
);
```

---

title: Reading Output Pointers - Bun:ffi
description: Demonstrates how to read data from an output pointer returned by an FFI function.  It assumes the output is 0-terminated, creates a `Uint8Array` from the pointer using `toArrayBuffer`, and then writes it to a file using `Bun.write`.
source: docs/api/ffi.md#_snippet_7

language: typescript
code:
```
const out = encode_png(
  // pixels will be passed as a pointer
  pixels,

  // dimensions:
  128,
  128,
);

// assuming it is 0-terminated, it can be read like this:
let png = new Uint8Array(toArrayBuffer(out));

// save it to disk:
await Bun.write("out.png", png);
```

---

title: Reading from Stdin Using Console - TypeScript
description: Illustrates how to use the `console` object as an `AsyncIterable` in Bun to sequentially read lines from `process.stdin`. This is useful for creating interactive command-line applications that require user input.
source: docs/api/console.md#_snippet_1

language: ts
code:
```
for await (const line of console) {
  console.log(line);
}
```

---

title: Controlling the TCP Server
description: Demonstrates how to control a TCP server created with `Bun.listen`. It shows how to stop the server from listening, optionally closing active connections, and how to allow Bun to exit even if the server is still listening using `unref()`.
source: docs/api/tcp.md#_snippet_4

language: typescript
code:
```
const server = Bun.listen({
  /* config*/
});

// stop listening
// parameter determines whether active connections are closed
server.stop(true);

// let Bun process exit even if server is still listening
server.unref();
```

---

title: Enabling TLS on the Client
description: Demonstrates how to require TLS for a client connection using `Bun.connect`. Specifying `tls: true` in the configuration enables secure communication with the server.
source: docs/api/tcp.md#_snippet_6

language: typescript
code:
```
// The client
const socket = await Bun.connect({
  // ... config
  tls: true,
});
```

---

title: Creating S3Client Objects
description: Illustrates how to create a `S3Client` instance with explicit credentials.  This allows explicit configuration rather than relying on environment variables.
source: docs/api/s3.md#_snippet_5

language: typescript
code:
```
import { S3Client } from "bun";

const client = new S3Client({
  accessKeyId: "your-access-key",
  secretAccessKey: "your-secret-key",
  bucket: "my-bucket",
  // sessionToken: "..."
  endpoint: "https://s3.us-east-1.amazonaws.com",
  // endpoint: "https://<account-id>.r2.cloudflarestorage.com", // Cloudflare R2
  // endpoint: "http://localhost:9000", // MinIO
});

// Write using a Response
await file.write(new Response("Hello World!"));

// Presign a URL
const url = file.presign({
  expiresIn: 60 * 60 * 24, // 1 day
  acl: "public-read",
});

// Delete the file
await file.delete();
```

---

title: Writing Files to S3 - S3Client Prototype
description: Demonstrates using the `write` method on an `S3Client` instance to upload a file. Shows writing both a string and a `Response` object to S3.
source: docs/api/s3.md#_snippet_6

language: typescript
code:
```
const client = new Bun.S3Client({
  accessKeyId: "your-access-key",
  secretAccessKey: "your-secret-key",
  endpoint: "https://s3.us-east-1.amazonaws.com",
  bucket: "my-bucket",
});
await client.write("my-file.txt", "Hello World!");
await client.write("my-file.txt", new Response("Hello World!"));

// equivalent to
// await client.file("my-file.txt").write("Hello World!");
```

---

title: Deleting Files From S3 - S3Client Prototype
description: Demonstrates using the `delete` method on an `S3Client` instance to remove a file from S3. Provides an example of how to call the delete method.
source: docs/api/s3.md#_snippet_7

language: typescript
code:
```
const client = new Bun.S3Client({
  accessKeyId: "your-access-key",
  secretAccessKey: "your-secret-key",
  bucket: "my-bucket",
});

await client.delete("my-file.txt");
// equivalent to
// await client.file("my-file.txt").delete();
```

---

title: Checking File Existence - S3Client Prototype
description: Demonstrates how to check if a file exists in S3 using the `exists` method of an `S3Client` instance. Explains how to check existence with `client.exists`.
source: docs/api/s3.md#_snippet_8

language: typescript
code:
```
const client = new Bun.S3Client({
  accessKeyId: "your-access-key",
  secretAccessKey: "your-secret-key",
  bucket: "my-bucket",
});

const exists = await client.exists("my-file.txt");
// equivalent to
// const exists = await client.file("my-file.txt").exists();
```

---

title: Reading Partial Ranges - S3File Slice
description: Illustrates how to read a partial range of bytes from an S3 file using the `slice` method. It creates a partial `S3File` and reads its contents as a `Uint8Array` and a string.
source: docs/api/s3.md#_snippet_9

language: typescript
code:
```
const partial = s3file.slice(0, 1024);

// Read the partial range as a Uint8Array
const bytes = await partial.bytes();

// Read the partial range as a string
const text = await partial.text();
```

---

title: Deleting Files From S3 - S3File Unlink
description: Demonstrates how to delete a file from S3 using the `delete` method of an `S3File` instance. Provides two equivalent ways to delete the file.
source: docs/api/s3.md#_snippet_10

language: typescript
code:
```
await s3file.delete();
// await s3File.unlink();
```

---

title: Listing Objects in an S3 Bucket - TypeScript
description: Demonstrates how to list objects in an S3 bucket using `S3Client.list`. It shows how to list all objects, list objects with a prefix and maximum keys, and handle truncated results using `startAfter` to retrieve subsequent batches.
source: docs/api/s3.md#_snippet_2

language: typescript
code:
```
import { S3Client } from "bun";

const credentials = {
  accessKeyId: "your-access-key",
  secretAccessKey: "your-secret-key",
  bucket: "my-bucket",
  // endpoint: "https://s3.us-east-1.amazonaws.com",
  // endpoint: "https://<account-id>.r2.cloudflarestorage.com", // Cloudflare R2
};

// List (up to) 1000 objects in the bucket
const allObjects = await S3Client.list(null, credentials);

// List (up to) 500 objects under `uploads/` prefix, with owner field for each object
const uploads = await S3Client.list({
  prefix: 'uploads/',
  maxKeys: 500,
  fetchOwner: true,
}, credentials);

// Check if more results are available
if (uploads.isTruncated) {
  // List next batch of objects under `uploads/` prefix
  const moreUploads = await S3Client.list({
    prefix: 'uploads/',
    maxKeys: 500,
    startAfter: uploads.contents!.at(-1).key
    fetchOwner: true,
  }, credentials);
}
```

---

title: Checking for Existence of S3 Files - TypeScript
description: Demonstrates using `S3Client.exists` and `s3file.exists()` to check if an S3 file exists. The first snippet shows the static method, and the second uses the `S3File` instance.
source: docs/api/s3.md#_snippet_3

language: typescript
code:
```
import { S3Client } from "bun";

const credentials = {
  accessKeyId: "your-access-key",
  secretAccessKey: "your-secret-key",
  bucket: "my-bucket",
  // endpoint: "https://s3.us-east-1.amazonaws.com",
  // endpoint: "https://<account-id>.r2.cloudflarestorage.com", // Cloudflare R2
};

const exists = await S3Client.exists("my-file.txt", credentials);
```

language: typescript
code:
```
import { s3 } from "bun";

const s3file = s3.file("my-file.txt", {
  ...credentials,
});
const exists = await s3file.exists();
```

---

title: Getting Size of an S3 File - TypeScript
description: Demonstrates how to efficiently check the size of an S3 file without downloading it, using `S3Client.size`. This is useful for determining file sizes before performing further operations.
source: docs/api/s3.md#_snippet_4

language: typescript
code:
```
import { S3Client } from "bun";

const credentials = {
  accessKeyId: "your-access-key",
  secretAccessKey: "your-secret-key",
  bucket: "my-bucket",
  // endpoint: "https://s3.us-east-1.amazonaws.com",
  // endpoint: "https://<account-id>.r2.cloudflarestorage.com", // Cloudflare R2
};

const bytes = await S3Client.size("my-file.txt", credentials);
```

---

title: Retrieving Metadata of S3 Files - TypeScript
description: Illustrates how to get the size, etag, and other metadata of an S3 file using the `S3Client.stat` method. It's useful for retrieving information about a file without downloading its contents.
source: docs/api/s3.md#_snippet_5

language: typescript
code:
```
import { S3Client } from "bun";

const credentials = {
  accessKeyId: "your-access-key",
  secretAccessKey: "your-secret-key",
  bucket: "my-bucket",
  // endpoint: "https://s3.us-east-1.amazonaws.com",
  // endpoint: "https://<account-id>.r2.cloudflarestorage.com", // Cloudflare R2
};

const stat = await S3Client.stat("my-file.txt", credentials);
// {
//   etag: "\"7a30b741503c0b461cc14157e2df4ad8\"",
//   lastModified: 2025-01-07T00:19:10.000Z,
//   size: 1024,
//   type: "text/plain;charset=utf-8",
// }
```

---

title: Deleting S3 Files - TypeScript
description: Demonstrates how to delete an S3 file using the `S3Client.delete` static method. Also shows that `S3Client.unlink` is an alias for `S3Client.delete`.
source: docs/api/s3.md#_snippet_6

language: typescript
code:
```
import { S3Client } from "bun";

const credentials = {
  accessKeyId: "your-access-key",
  secretAccessKey: "your-secret-key",
  bucket: "my-bucket",
  // endpoint: "https://s3.us-east-1.amazonaws.com",
};

await S3Client.delete("my-file.txt", credentials);
// equivalent to
// await new S3Client(credentials).delete("my-file.txt");

// S3Client.unlink is alias of S3Client.delete
await S3Client.unlink("my-file.txt", credentials);
```

---

title: Accessing S3 Files with s3:// Protocol - TypeScript
description: Illustrates how to use the `s3://` protocol with `fetch` and `Bun.file()` to access S3 files. It shows how to pass S3 options such as credentials and headers to the `fetch` and `Bun.file` functions.
source: docs/api/s3.md#_snippet_7

language: typescript
code:
```
const response = await fetch("s3://my-bucket/my-file.txt");
const file = Bun.file("s3://my-bucket/my-file.txt");
```

language: typescript
code:
```
const response = await fetch("s3://my-bucket/my-file.txt", {
  s3: {
    accessKeyId: "your-access-key",
    secretAccessKey: "your-secret-key",
    endpoint: "https://s3.us-east-1.amazonaws.com",
  },
  headers: {
    "range": "bytes=0-1023",
  },
});
```

---

title: Defining Exposed Symbols with `cc`
description: Defines how to specify the symbols (functions and variables) to expose to JavaScript when compiling C code with `bun:ffi`'s `cc` function. The `symbols` object maps symbol names to their argument types and return type using `FFIType`.
source: docs/api/cc.md#_snippet_4

language: typescript
code:
```
type Symbols = {
  [key: string]: {
    args: FFIType[];
    returns: FFIType;
  };
};
```

---

title: Specifying C Source with `cc`
description: Explains how to specify the C source file to compile with `bun:ffi`'s `cc` function. The `source` property accepts a file path (string), URL, or BunFile object pointing to the C source code.
source: docs/api/cc.md#_snippet_5

language: typescript
code:
```
type Source = string | URL | BunFile;

cc({
  source: "hello.c",
  symbols: {
    hello: {
      args: [],
      returns: "int",
    },
  },
});
```

---

title: Iterating Through Results Incrementally - Using Iterate
description: Illustrates how to use `.iterate()` to incrementally return query results. This is useful for processing large result sets one row at a time, avoiding loading all results into memory, which can improve performance and reduce memory usage. The `@@iterator` protocol is also supported.
source: docs/api/sqlite.md#_snippet_1

language: typescript
code:
```
const query = db.query("SELECT * FROM foo");
for (const row of query.iterate()) {
  console.log(row);
}
```

language: typescript
code:
```
const query = db.query("SELECT * FROM foo");
for (const row of query) {
  console.log(row);
}
```

---

title: Fetching Query Results - As Array of Arrays
description: Demonstrates how to use `values()` to retrieve query results as an array of arrays. This provides a simple way to access the raw data returned by the query without object overhead, useful when you need only the values and not named columns.
source: docs/api/sqlite.md#_snippet_2

language: typescript
code:
```
const query = db.query(`select $message;`);
query.values({ $message: "Hello world" });

query.values(2);
// [
//   [ "Iron Man", 2008 ],
//   [ "The Avengers", 2012 ],
//   [ "Ant-Man: Quantumania", 2023 ],
// ]
```

---

title: Querying With Positional Parameters
description: Illustrates how to execute queries using numbered (positional) parameters denoted by `?1`, `?2`, etc.  Values are bound in the order they appear. This provides an alternative to named parameters.
source: docs/api/sqlite.md#_snippet_6

language: typescript
code:
```
const query = db.query("SELECT ?1, ?2");
const results = query.all("hello", "goodbye");
```

language: typescript
code:
```
[
  {
    "?1": "hello",
    "?2": "goodbye"
  }
]
```

---

title: Executing Transactions With Arguments
description: Demonstrates executing a transaction, passing arguments to the wrapped function, and handling the return value. The example shows how a transaction is automatically begun and committed, and rolled back if exceptions are thrown.
source: docs/api/sqlite.md#_snippet_11

language: typescript
code:
```
const insert = db.prepare("INSERT INTO cats (name) VALUES ($name)");
const insertCats = db.transaction(cats => {
  for (const cat of cats) insert.run(cat);
  return cats.length;
});

const count = insertCats([
  { $name: "Keanu" },
  { $name: "Salem" },
  { $name: "Crookshanks" },
]);

console.log(`Inserted ${count} cats`);
```

---

title: Getting RGBA Channels as Object
description: Demonstrates how to extract the red, green, blue, and alpha channels as an object using `Bun.color` with the `"{rgba}"` option. The `a` channel is a decimal number between `0` and `1`.
source: docs/api/color.md#_snippet_6

language: ts
code:
```
Bun.color("hsl(0, 0%, 50%)", "{rgba}"); // { r: 128, g: 128, b: 128, a: 1 }
Bun.color("red", "{rgba}"); // { r: 255, g: 0, b: 0, a: 1 }
Bun.color(0xff0000, "{rgba}"); // { r: 255, g: 0, b: 0, a: 1 }
Bun.color({ r: 255, g: 0, b: 0 }, "{rgba}"); // { r: 255, g: 0, b: 0, a: 1 }
Bun.color([255, 0, 0], "{rgba}"); // { r: 255, g: 0, b: 0, a: 1 }
```

---

title: Getting RGB Channels as Object
description: Demonstrates how to extract the red, green, and blue channels as an object using `Bun.color` with the `"{rgb}"` option. The resulting object does not include the alpha channel.
source: docs/api/color.md#_snippet_7

language: ts
code:
```
Bun.color("hsl(0, 0%, 50%)", "{rgb}"); // { r: 128, g: 128, b: 128 }
Bun.color("red", "{rgb}"); // { r: 255, g: 0, b: 0 }
Bun.color(0xff0000, "{rgb}"); // { r: 255, g: 0, b: 0 }
Bun.color({ r: 255, g: 0, b: 0 }, "{rgb}"); // { r: 255, g: 0, b: 0 }
Bun.color([255, 0, 0], "{rgb}"); // { r: 255, g: 0, b: 0 }
```

---

title: Getting RGBA Channels as Array
description: Illustrates how to extract the red, green, blue, and alpha channels as an array using `Bun.color` with the `"[rgba]"` option. All values are integers between `0` and `255`.
source: docs/api/color.md#_snippet_8

language: ts
code:
```
Bun.color("hsl(0, 0%, 50%)", "[rgba]"); // [128, 128, 128, 255]
Bun.color("red", "[rgba]"); // [255, 0, 0, 255]
Bun.color(0xff0000, "[rgba]"); // [255, 0, 0, 255]
Bun.color({ r: 255, g: 0, b: 0 }, "[rgba]"); // [255, 0, 0, 255]
Bun.color([255, 0, 0], "[rgba]"); // [255, 0, 0, 255]
```

---

title: Getting RGB Channels as Array
description: Demonstrates how to extract the red, green, and blue channels as an array using `Bun.color` with the `"[rgb]"` option. The resulting array does not include the alpha channel.
source: docs/api/color.md#_snippet_9

language: ts
code:
```
Bun.color("hsl(0, 0%, 50%)", "[rgb]"); // [128, 128, 128]
Bun.color("red", "[rgb]"); // [255, 0, 0]
Bun.color(0xff0000, "[rgb]"); // [255, 0, 0]
Bun.color({ r: 255, g: 0, b: 0 }, "[rgb]"); // [255, 0, 0]
Bun.color([255, 0, 0], "[rgb]"); // [255, 0, 0]
```

---

title: Opening a Database in Readonly Mode
description: Shows how to open a SQLite database in `readonly` mode using the `readonly` option in the `Database` constructor. This prevents accidental data modifications. The example demonstrates opening `mydb.sqlite` in read-only mode.
source: docs/api/sqlite.md#_snippet_3

language: ts
code:
```
import { Database } from "bun:sqlite";
const db = new Database("mydb.sqlite", { readonly: true });
```

---

title: Creating a Database if it Doesn't Exist
description: Illustrates how to ensure a SQLite database file is created if it doesn't already exist using the `create` option in the `Database` constructor. This simplifies initial database setup. The example demonstrates creating `mydb.sqlite` if it is missing.
source: docs/api/sqlite.md#_snippet_4

language: ts
code:
```
import { Database } from "bun:sqlite";
const db = new Database("mydb.sqlite", { create: true });
```

---

title: Loading a Database via ES Module Import
description: Demonstrates how to load a SQLite database using an ES module import with the `type: sqlite` attribute. This provides a concise way to initialize a database. The example shows how it is equivalent to using the `Database` constructor directly.
source: docs/api/sqlite.md#_snippet_6

language: ts
code:
```
import db from "./mydb.sqlite" with { "type": "sqlite" };

console.log(db.query("select * from users LIMIT 1").get());
```

language: ts
code:
```
import { Database } from "bun:sqlite";
const db = new Database("./mydb.sqlite");
```

---

title: Ensuring Database Closure with `using` Statement
description: Demonstrates how to use the `using` statement to ensure that a database connection is automatically closed when the block is exited. This helps to manage resources and prevent leaks. The example shows using `using` with both the `Database` and `query` objects.
source: docs/api/sqlite.md#_snippet_8

language: ts
code:
```
import { Database } from "bun:sqlite";

{
  using db = new Database("mydb.sqlite");
  using query = db.query("select 'Hello world' as message;");
  console.log(query.get()); // => { message: "Hello world" }
}
```

---

title: Preparing a SQL Query
description: Illustrates how to prepare a SQL query using the `db.query()` method, which creates a cached `Statement` instance. The prepared statement is then ready for execution. The example shows creating a simple query to select a message.
source: docs/api/sqlite.md#_snippet_10

language: ts
code:
```
const query = db.query(`select "Hello world" as message`);
```

---

title: Creating a Prepared Query with Parameters
description: Illustrates how to create prepared queries with parameters using numerical (`?1`) and named (`$param`) placeholders. Parameters allow dynamic values to be bound when the query is executed. The example shows creating queries with both types of parameters.
source: docs/api/sqlite.md#_snippet_12

language: ts
code:
```
const query = db.query(`SELECT ?1, ?2;`);
const query = db.query(`SELECT $param1, $param2;`);
```

---

title: Binding Values to a Statement
description: Demonstrates how to bind values to a prepared statement using an object with named parameters or positional parameters. The values are bound when methods like `.all()` are called. The examples show binding with both named and positional parameters.
source: docs/api/sqlite.md#_snippet_13

language: ts
code:
```
const query = db.query(`select $message;`);
query.all({ $message: "Hello world" });
```

language: ts
code:
```
const query = db.query(`select ?1;`);
query.all("Hello world");
```

---

title: Retrieving All Results as an Array
description: Illustrates how to execute a query and retrieve all results as an array of objects using the `.all()` method. The example shows running a query and retrieving the result as an array containing the message.
source: docs/api/sqlite.md#_snippet_15

language: ts
code:
```
const query = db.query(`select $message;`);
query.all({ $message: "Hello world" });
// => [{ message: "Hello world" }]
```

---

title: Retrieving the First Result as an Object
description: Demonstrates how to execute a query and retrieve the first result as an object using the `.get()` method. If there are no results, it will return `undefined`. The example shows retrieving a single message from the database.
source: docs/api/sqlite.md#_snippet_16

language: ts
code:
```
const query = db.query(`select $message;`);
query.get({ $message: "Hello world" });
// => { $message: "Hello world" }
```

---

title: Running a Query Without Results
description: Explains how to execute a query that doesn't return results, such as a `CREATE TABLE` statement, using the `.run()` method.  `.run()` returns `undefined`. The snippet shows creating a table.
source: docs/api/sqlite.md#_snippet_17

language: ts
code:
```
const query = db.query(`create table foo;`);
query.run();
// {
//   lastInsertRowid: 0,
//   changes: 0,
// }
```

---

title: Creating an S3Client Instance
description: Illustrates how to create an instance of `Bun.S3Client` to interact with S3, showing both the default usage with environment variables and explicit credential setting. The code also shows how to specify different S3-compatible endpoints like Cloudflare R2, DigitalOcean Spaces, and MinIO.
source: docs/api/s3.md#_snippet_1

language: typescript
code:
```
import { S3Client } from "bun";

const client = new S3Client({
  accessKeyId: "your-access-key",
  secretAccessKey: "your-secret-key",
  bucket: "my-bucket",
  // sessionToken: "..."
  // acl: "public-read",
  // endpoint: "https://s3.us-east-1.amazonaws.com",
  // endpoint: "https://<account-id>.r2.cloudflarestorage.com", // Cloudflare R2
  // endpoint: "https://<region>.digitaloceanspaces.com", // DigitalOcean Spaces
  // endpoint: "http://localhost:9000", // MinIO
});

// Bun.s3 is a global singleton that is equivalent to `new Bun.S3Client()`
```

---

title: Working with S3 Files Using the File Method
description: Demonstrates how to obtain a lazy reference to a file on S3 using the `file` method of `S3Client`. It highlights that this method is synchronous and doesn't initiate network requests until a method requiring network access is invoked.
source: docs/api/s3.md#_snippet_2

language: typescript
code:
```
// A lazy reference to a file on S3
const s3file: S3File = client.file("123.json");
```

---

title: Reading Files from S3
description: Illustrates how to read files from S3 using the `S3File` object, which extends the `Blob` API. It shows how to read an `S3File` as text, JSON, or an ArrayBuffer, as well as how to get a partial slice of the file and stream it.
source: docs/api/s3.md#_snippet_3

language: typescript
code:
```
// Read an S3File as text
const text = await s3file.text();

// Read an S3File as JSON
const json = await s3file.json();

// Read an S3File as an ArrayBuffer
const buffer = await s3file.arrayBuffer();

// Get only the first 1024 bytes
const partial = await s3file.slice(0, 1024).text();

// Stream the file
const stream = s3file.stream();
for await (const chunk of stream) {
  console.log(chunk);
}
```

---

title: Writing and Uploading Files to S3
description: Demonstrates various ways to write and upload files to S3 using the `s3file.write` method, including writing a string, a Buffer, a Response, and specifying content type. It also shows how to use a writer for streaming and `Bun.write` for simple writing.
source: docs/api/s3.md#_snippet_4

language: typescript
code:
```
// Write a string (replacing the file)
await s3file.write("Hello World!");

// Write a Buffer (replacing the file)
await s3file.write(Buffer.from("Hello World!"));

// Write a Response (replacing the file)
await s3file.write(new Response("Hello World!"));

// Write with content type
await s3file.write(JSON.stringify({ name: "John", age: 30 }), {
  type: "application/json",
});

// Write using a writer (streaming)
const writer = s3file.writer({ type: "application/json" });
writer.write("Hello");
writer.write(" World!");
await writer.end();

// Write using Bun.write
await Bun.write(s3file, "Hello World!");
```

---

title: Writing Large Files to S3 Using Streams
description: Illustrates how to write large files to S3 using streaming capabilities, including automatic multipart uploads and retry mechanisms. The example configures retry attempts, queue size, and part size for efficient large file uploads.
source: docs/api/s3.md#_snippet_5

language: typescript
code:
```
// Write a large file
const bigFile = Buffer.alloc(10 * 1024 * 1024); // 10MB
const writer = s3file.writer({
  // Automatically retry on network errors up to 3 times
  retry: 3,

  // Queue up to 10 requests at a time
  queueSize: 10,

  // Upload in 5 MB chunks
  partSize: 5 * 1024 * 1024,
});
for (let i = 0; i < 10; i++) {
  writer.write(bigFile);
  await writer.flush();
}
await writer.end();
```

---

title: Generating Presigned URLs for S3 Files
description: Demonstrates how to generate presigned URLs for S3 files, allowing secure uploading to S3 without exposing credentials. The example shows how to set expiration times and specify the content type.
source: docs/api/s3.md#_snippet_6

language: typescript
code:
```
import { s3 } from "bun";

// Generate a presigned URL that expires in 24 hours (default)
const download = s3.presign("my-file.txt"); // GET, text/plain, expires in 24 hours

const upload = s3.presign("my-file", {
  expiresIn: 3600, // 1 hour
  method: "PUT",
  type: "application/json", // No extension for inferring, so we can specify the content type to be JSON
});

// You can call .presign() if on a file reference, but avoid doing so
// unless you already have a reference (to avoid memory usage).
const myFile = s3.file("my-file.txt");
const presignedFile = myFile.presign({
  expiresIn: 3600, // 1 hour
});
```

---

title: Setting ACLs on Presigned URLs
description: Illustrates how to set Access Control Lists (ACLs) on presigned URLs for S3 files, controlling who can access the object. The example sets the `public-read` ACL, making the object readable by the public.
source: docs/api/s3.md#_snippet_7

language: typescript
code:
```
const url = s3file.presign({
  acl: "public-read",
  expiresIn: 3600,
});
```

---

title: Configuring Expiration and Method for Presigned URLs
description: Demonstrates how to configure the expiration time and HTTP method for presigned URLs using the `expiresIn` and `method` options. The example sets the expiration time to one hour and specifies the PUT method.
source: docs/api/s3.md#_snippet_8

language: typescript
code:
```
const url = s3file.presign({
  method: "PUT",
  // method: "DELETE",
  // method: "GET",
  // method: "HEAD",
  // method: "POST",
  // method: "PUT",
});
```

---

title: Redirecting to a Presigned URL Using Response
description: Illustrates how to quickly redirect users to a presigned URL for an S3 file using a `Response` object. This method avoids downloading the file to the server, saving memory, time, and bandwidth.
source: docs/api/s3.md#_snippet_9

language: typescript
code:
```
const response = new Response(s3file);
console.log(response);
```

---

title: Configuring S3Client for AWS S3
description: Demonstrates how to configure the `S3Client` to work with AWS S3, either by specifying the `endpoint` or the `region`. It provides the necessary configurations for connecting to AWS S3.
source: docs/api/s3.md#_snippet_10

language: typescript
code:
```
import { S3Client } from "bun";

// AWS S3
const s3 = new S3Client({
  accessKeyId: "access-key",
  secretAccessKey: "secret-key",
  bucket: "my-bucket",
  // endpoint: "https://s3.us-east-1.amazonaws.com",
  // region: "us-east-1",
});
```

---

title: Configuring S3Client for Google Cloud Storage
description: Illustrates how to configure the `S3Client` to work with Google Cloud Storage by setting the `endpoint` to `https://storage.googleapis.com`. This enables the use of Bun's S3 client with Google Cloud Storage.
source: docs/api/s3.md#_snippet_11

language: typescript
code:
```
import { S3Client } from "bun";

// Google Cloud Storage
const gcs = new S3Client({
  accessKeyId: "access-key",
  secretAccessKey: "secret-key",
  bucket: "my-bucket",
  endpoint: "https://storage.googleapis.com",
});
```

---

title: Defining Bun Spawn API and Types - TypeScript
description: Defines the TypeScript interfaces for the `Bun.spawn` and `Bun.spawnSync` APIs. This includes the `SpawnOptions`, `Subprocess`, `SyncSubprocess`, and `ResourceUsage` interfaces, which detail the options, properties, and methods associated with spawning and managing child processes in Bun.
source: docs/api/spawn.md#_snippet_1

language: typescript
code:
```
interface Bun {
  spawn(command: string[], options?: SpawnOptions.OptionsObject): Subprocess;
  spawnSync(
    command: string[],
    options?: SpawnOptions.OptionsObject,
  ): SyncSubprocess;

  spawn(options: { cmd: string[] } & SpawnOptions.OptionsObject): Subprocess;
  spawnSync(
    options: { cmd: string[] } & SpawnOptions.OptionsObject,
  ): SyncSubprocess;
}

namespace SpawnOptions {
  interface OptionsObject {
    cwd?: string;
    env?: Record<string, string | undefined>;
    stdio?: [Writable, Readable, Readable];
    stdin?: Writable;
    stdout?: Readable;
    stderr?: Readable;
    onExit?(
      subprocess: Subprocess,
      exitCode: number | null,
      signalCode: number | null,
      error?: ErrorLike,
    ): void | Promise<void>;
    ipc?(message: any, subprocess: Subprocess): void;
    serialization?: "json" | "advanced";
    windowsHide?: boolean;
    windowsVerbatimArguments?: boolean;
    argv0?: string;
    signal?: AbortSignal;
    timeout?: number;
    killSignal?: string | number;
    maxBuffer?: number;
  }

  type Readable =
    | "pipe"
    | "inherit"
    | "ignore"
    | null // equivalent to "ignore"
    | undefined // to use default
    | BunFile
    | ArrayBufferView
    | number;

  type Writable =
    | "pipe"
    | "inherit"
    | "ignore"
    | null // equivalent to "ignore"
    | undefined // to use default
    | BunFile
    | ArrayBufferView
    | number
    | ReadableStream
    | Blob
    | Response
    | Request;
}

interface Subprocess extends AsyncDisposable {
  readonly stdin: FileSink | number | undefined;
  readonly stdout: ReadableStream<Uint8Array> | number | undefined;
  readonly stderr: ReadableStream<Uint8Array> | number | undefined;
  readonly readable: ReadableStream<Uint8Array> | number | undefined;
  readonly pid: number;
  readonly exited: Promise<number>;
  readonly exitCode: number | null;
  readonly signalCode: NodeJS.Signals | null;
  readonly killed: boolean;

  kill(exitCode?: number | NodeJS.Signals): void;
  ref(): void;
  unref(): void;

  send(message: any): void;
  disconnect(): void;
  resourceUsage(): ResourceUsage | undefined;
}

interface SyncSubprocess {
  stdout: Buffer | undefined;
  stderr: Buffer | undefined;
  exitCode: number;
  success: boolean;
  resourceUsage: ResourceUsage;
  signalCode?: string;
  exitedDueToTimeout?: true;
  pid: number;
}

interface ResourceUsage {
  contextSwitches: {
    voluntary: number;
    involuntary: number;
  };

  cpuTime: {
    user: number;
    system: number;
    total: number;
  };
  maxRSS: number;

  messages: {
    sent: number;
    received: number;
  };
  ops: {
    in: number;
    out: number;
  };
  shmSize: number;
  signalCount: number;
  swapCount: number;
}

type Signal =
  | "SIGABRT"
  | "SIGALRM"
  | "SIGBUS"
  | "SIGCHLD"
  | "SIGCONT"
  | "SIGFPE"
  | "SIGHUP"
  | "SIGILL"
  | "SIGINT"
  | "SIGIO"
  | "SIGIOT"
  | "SIGKILL"
  | "SIGPIPE"
  | "SIGPOLL"
  | "SIGPROF"
  | "SIGPWR"
  | "SIGQUIT"
  | "SIGSEGV"
  | "SIGSTKFLT"
  | "SIGSTOP"
  | "SIGSYS"
  | "SIGTERM"
  | "SIGTRAP"
  | "SIGTSTP"
  | "SIGTTIN"
  | "SIGTTOU"
  | "SIGUNUSED"
  | "SIGURG"
  | "SIGUSR1"
  | "SIGUSR2"
  | "SIGVTALRM"
  | "SIGWINCH"
  | "SIGXCPU"
  | "SIGXFSZ"
  | "SIGBREAK"
  | "SIGLOST"
  | "SIGINFO";
```

---

title: Creating a Worker From a Blob URL
description: Illustrates creating a worker from a `blob:` URL using `Blob` and `URL.createObjectURL`. The worker simply echoes back the message it receives.
source: docs/api/workers.md#_snippet_5

language: js
code:
```
const blob = new Blob(
  [
    `
  self.onmessage = (event: MessageEvent) => postMessage(event.data)`,
  ],
  {
    type: "application/typescript",
  },
);
const url = URL.createObjectURL(blob);
const worker = new Worker(url);
```

---

title: Creating a Worker From a File URL
description: Illustrates creating a worker from a `file:` URL using `File` and `URL.createObjectURL`.  The worker simply echoes back the message it receives.
source: docs/api/workers.md#_snippet_6

language: js
code:
```
const file = new File(
  [
    `
  self.onmessage = (event: MessageEvent) => postMessage(event.data)`,
  ],
  "worker.ts",
);
const url = URL.createObjectURL(file);
const worker = new Worker(url);
```

---

title: Terminating a Worker Instance
description: Shows how to terminate a `Worker` instance forcefully using `worker.terminate()`. This will cause the worker to exit as soon as possible.
source: docs/api/workers.md#_snippet_10

language: ts
code:
```
const worker = new Worker(new URL("worker.ts", import.meta.url).href);

// ...some time later
worker.terminate();
```

---

title: Checking If in Main Thread
description: Demonstrates how to check if the code is running in the main thread using `Bun.isMainThread`.  This is useful for conditionally running code based on the thread context.
source: docs/api/workers.md#_snippet_16

language: ts
code:
```
if (Bun.isMainThread) {
  console.log("I'm the main thread");
} else {
  console.log("I'm in a worker");
}
```

---

title: Using JSON Output in Bun Audit
description: Demonstrates how to use the `--json` flag with `bun audit` to print the raw JSON response from the registry. This is useful for programmatically processing the audit results.
source: docs/install/audit.md#_snippet_3

language: bash
code:
```
$ bun audit --json
```

---

title: Filtering Workspaces During Installation
description: Demonstrates how to use the `--filter` flag with `bun install` to selectively install dependencies for specific workspaces in a monorepo. This allows developers to target particular packages for dependency updates, improving efficiency when working with large projects.
source: docs/install/workspaces.md#_snippet_2

language: bash
code:
```
# Install dependencies for all workspaces starting with `pkg-` except for `pkg-c`
$ bun install --filter "pkg-*" --filter "!pkg-c"

# Paths can also be used. This is equivalent to the command above.
$ bun install --filter "./packages/pkg-*" --filter "!pkg-c" # or --filter "!./packages/pkg-c"
```

---

title: Adding Trusted Dependencies
description: Illustrates how to add `node-sass` to the `trustedDependencies` array in `package.json`. Adding a package to `trustedDependencies` tells Bun to execute lifecycle scripts for that package during installation.
source: docs/install/lifecycle.md#_snippet_1

language: json-diff
code:
```
  {
    "name": "my-app",
    "version": "1.0.0",
+   "trustedDependencies": ["node-sass"]
  }
```

---

title: Writing Response to a File Using Bun Write
description: Illustrates how to efficiently write a response body to a file on disk using `Bun.write`. This method is useful for quickly saving the contents of a response to a file.
source: docs/api/fetch.md#_snippet_4

language: typescript
code:
```
import { write } from "bun";

await write("output.txt", response);
```

---

title: Managing Redis Client Connection Lifecycle - Bun
description: Demonstrates how the Redis client automatically manages connections and shows how to explicitly control the connection lifecycle using `connect()` and `close()` methods. This allows for fine-grained control over when connections are established and terminated, optimizing resource usage.
source: docs/api/redis.md#_snippet_2

language: ts
code:
```
// No connection is made until a command is executed
const client = new RedisClient();

// First command initiates the connection
await client.set("key", "value");

// Connection remains open for subsequent commands
await client.get("key");

// Explicitly close the connection when done
client.close();
```

language: ts
code:
```
const client = new RedisClient();

// Explicitly connect
await client.connect();

// Run commands
await client.set("key", "value");

// Disconnect when done
client.close();
```

---

title: Performing String Operations in Redis - Bun
description: Illustrates common string operations in Redis, including setting, getting, deleting, and checking the existence of keys, as well as setting and retrieving the time-to-live (TTL) for keys. This showcases fundamental data manipulation with strings in Redis using Bun.
source: docs/api/redis.md#_snippet_3

language: ts
code:
```
// Set a key
await redis.set("user:1:name", "Alice");

// Get a key
const name = await redis.get("user:1:name");

// Delete a key
await redis.del("user:1:name");

// Check if a key exists
const exists = await redis.exists("user:1:name");

// Set expiration (in seconds)
await redis.set("session:123", "active");
await redis.expire("session:123", 3600); // expires in 1 hour

// Get time to live (in seconds)
const ttl = await redis.ttl("session:123");
```

---

title: Executing Numeric Operations in Redis - Bun
description: Demonstrates how to perform numeric operations in Redis, specifically incrementing and decrementing counters. This provides basic functionality for managing numerical data within Redis using the Bun client.
source: docs/api/redis.md#_snippet_4

language: ts
code:
```
// Set initial value
await redis.set("counter", "0");

// Increment by 1
await redis.incr("counter");

// Decrement by 1
await redis.decr("counter");
```

---

title: Managing Hash Operations in Redis - Bun
description: Illustrates how to perform hash operations in Redis, including setting and retrieving multiple fields in a hash, incrementing a numeric field, and incrementing a float field. This shows how to work with more complex data structures using the Bun Redis client.
source: docs/api/redis.md#_snippet_5

language: ts
code:
```
// Set multiple fields in a hash
await redis.hmset("user:123", [
  "name",
  "Alice",
  "email",
  "alice@example.com",
  "active",
  "true",
]);

// Get multiple fields from a hash
const userFields = await redis.hmget("user:123", ["name", "email"]);
console.log(userFields); // ["Alice", "alice@example.com"]

// Increment a numeric field in a hash
await redis.hincrby("user:123", "visits", 1);

// Increment a float field in a hash
await redis.hincrbyfloat("user:123", "score", 1.5);
```

---

title: Performing Set Operations in Redis - Bun
description: Demonstrates how to execute set operations in Redis, including adding and removing members, checking membership, retrieving all members, and randomly selecting or popping members. These are core set operations with the Bun Redis client.
source: docs/api/redis.md#_snippet_6

language: ts
code:
```
// Add member to set
await redis.sadd("tags", "javascript");

// Remove member from set
await redis.srem("tags", "javascript");

// Check if member exists in set
const isMember = await redis.sismember("tags", "javascript");

// Get all members of a set
const allTags = await redis.smembers("tags");

// Get a random member
const randomTag = await redis.srandmember("tags");

// Pop (remove and return) a random member
const poppedTag = await redis.spop("tags");
```

---

title: Connecting With Supported URL Formats - Bun
description: Demonstrates the various URL formats supported by the Redis client, including standard Redis URLs, URLs with authentication, database numbers, TLS connections, Unix socket connections, and TLS over Unix sockets.  This offers flexibility in how the client is configured based on network and security requirements.
source: docs/api/redis.md#_snippet_12

language: ts
code:
```
// Standard Redis URL
new RedisClient("redis://localhost:6379");
new RedisClient("redis://localhost:6379");

// With authentication
new RedisClient("redis://username:password@localhost:6379");

// With database number
new RedisClient("redis://localhost:6379/0");

// TLS connections
new RedisClient("rediss://localhost:6379");
new RedisClient("rediss://localhost:6379");
new RedisClient("redis+tls://localhost:6379");
new RedisClient("redis+tls://localhost:6379");

// Unix socket connections
new RedisClient("redis+unix:///path/to/socket");
new RedisClient("redis+unix:///path/to/socket");

// TLS over Unix socket
new RedisClient("redis+tls+unix:///path/to/socket");
new RedisClient("redis+tls+unix:///path/to/socket");
```

---

title: Handling Errors With Redis - Bun
description: Demonstrates how to handle errors thrown by the Redis client, including checking the error code to identify specific error scenarios such as connection closed or authentication failure.  This enables robust error handling and appropriate responses to different Redis client issues.
source: docs/api/redis.md#_snippet_13

language: ts
code:
```
try {
  await redis.get("non-existent-key");
} catch (error) {
  if (error.code === "ERR_REDIS_CONNECTION_CLOSED") {
    console.error("Connection to Redis server was closed");
  } else if (error.code === "ERR_REDIS_AUTHENTICATION_FAILED") {
    console.error("Authentication failed");
  } else {
    console.error("Unexpected error:", error);
  }
}
```

---

title: Converting a Null-Terminated String Pointer
description: Illustrates how to convert a null-terminated string pointer obtained from a C library into a JavaScript string using `CString`. It explains the usage of the `CString` constructor and highlights that the `CString` instance is a clone, allowing safe usage even after the original pointer is freed.
source: docs/api/ffi.md#_snippet_4

language: typescript
code:
```
const myString = new CString(ptr);
```

---

title: Converting a String Pointer With Known Length
description: Shows how to create a JavaScript string from a C string pointer when the length is known, using the `CString` constructor with byteOffset and byteLength. It emphasizes that the new string is a clone, ensuring it's safe to use even after the original pointer is freed.
source: docs/api/ffi.md#_snippet_5

language: typescript
code:
```
const myString = new CString(ptr, 0, byteLength);
```

---

title: Safely Freeing Memory With CString
description: Demonstrates the correct way to free memory allocated to a C string after converting it to a JavaScript string using `CString`. It emphasizes that since `CString` creates a clone, it is safe to use the JavaScript string even after the original pointer has been freed by the native library.
source: docs/api/ffi.md#_snippet_6

language: typescript
code:
```
my_library_free(myString.ptr);

// this is safe because myString is a clone
console.log(myString);
```

---

title: Calling Function Pointers Using CFunction
description: Explains how to call a function pointer obtained from a native library using `CFunction`. It demonstrates how to create a `CFunction` instance with the correct return type, argument types, and pointer, and then call it like a regular JavaScript function.
source: docs/api/ffi.md#_snippet_7

language: typescript
code:
```
import { CFunction } from "bun:ffi";

let myNativeLibraryGetVersion = /* somehow, you got this pointer */

const getVersion = new CFunction({
  returns: "cstring",
  args: [],
  ptr: myNativeLibraryGetVersion,
});
getVersion();
```

---

title: Linking Multiple Function Pointers with linkSymbols
description: Shows how to use `linkSymbols` to define and link multiple function pointers at once.  The example sets up functions to get the major, minor, and patch versions, demonstrating that the names in `linkSymbols` can be different from the original function names. An invalid pointer will crash the program.
source: docs/api/ffi.md#_snippet_8

language: typescript
code:
```
import { linkSymbols } from "bun:ffi";

// getVersionPtrs defined elsewhere
const [majorPtr, minorPtr, patchPtr] = getVersionPtrs();

const lib = linkSymbols({
  // Unlike with dlopen(), the names here can be whatever you want
  getMajor: {
    returns: "cstring",
    args: [],

    // Since this doesn't use dlsym(), you have to provide a valid ptr
    // That ptr could be a number or a bigint
    // An invalid pointer will crash your program.
    ptr: majorPtr,
  },
  getMinor: {
    returns: "cstring",
    args: [],
    ptr: minorPtr,
  },
  getPatch: {
    returns: "cstring",
    args: [],
    ptr: patchPtr,
  },
});

const [major, minor, patch] = [
  lib.symbols.getMajor(),
  lib.symbols.getMinor(),
  lib.symbols.getPatch(),
];
```

---

title: Using JSCallback for Native Callbacks
description: Demonstrates how to create a JavaScript callback function that can be passed to a C/FFI function using `JSCallback`.  The C/FFI function calls into the JavaScript code, and when the `JSCallback` is no longer needed, `close()` should be called to free the memory.
source: docs/api/ffi.md#_snippet_9

language: typescript
code:
```
import { dlopen, JSCallback, ptr, CString } from "bun:ffi";

const {
  symbols: { search },
  close,
} = dlopen("libmylib", {
  search: {
    returns: "usize",
    args: ["cstring", "callback"],
  },
});

const searchIterator = new JSCallback(
  (ptr, length) => /hello/.test(new CString(ptr, length)),
  {
    returns: "bool",
    args: ["ptr", "usize"],
  },
);

const str = Buffer.from("wwutwutwutwutwutwutwutwutwutwutut\0", "utf8");
if (search(ptr(str), searchIterator)) {
  // found a match!
}

// Sometime later:
setTimeout(() => {
  searchIterator.close();
  close();
}, 5000);
```

---

title: Hashing and Verifying Passwords Synchronously
description: Illustrates the synchronous versions of `Bun.password.hash` and `Bun.password.verify`, namely `hashSync` and `verifySync`. It emphasizes that while these functions offer synchronous execution, their computationally intensive nature may impact application performance.
source: docs/api/hashing.md#_snippet_3

language: typescript
code:
```
const password = "super-secure-pa$$word";

const hash = Bun.password.hashSync(password, {
  /* config */
});

const isMatch = Bun.password.verifySync(password, hash);
// => true
```

---

title: Hashing Data with Wyhash Algorithm
description: Demonstrates how to use `Bun.hash` with a string input to generate a 64-bit hash using the Wyhash algorithm. It showcases the basic usage of `Bun.hash` with a string and highlights that an integer seed can be optionally provided to further customize the hash generation.
source: docs/api/hashing.md#_snippet_4

language: typescript
code:
```
Bun.hash("some data here");
// 11562320457524636935n
```

---

title: Hashing Various Data Types with Bunhash
description: Illustrates how `Bun.hash` can be used with different data types like `TypedArray`, `DataView`, `ArrayBuffer`, or `SharedArrayBuffer` as input. It emphasizes that `Bun.hash` can handle binary data directly, providing flexibility in hashing different types of data structures.
source: docs/api/hashing.md#_snippet_5

language: typescript
code:
```
const arr = new Uint8Array([1, 2, 3, 4]);

Bun.hash("some data here");
Bun.hash(arr);
Bun.hash(arr.buffer);
Bun.hash(new DataView(arr.buffer));
```

---

title: Hashing Data with Seed Value Using Bunhash
description: Demonstrates how to use `Bun.hash` with an integer seed as the second parameter to customize the hash generation. Using a seed allows for generating different hash values for the same input, useful in scenarios where reproducible but different hashes are needed.
source: docs/api/hashing.md#_snippet_6

language: typescript
code:
```
Bun.hash("some data here", 1234);
// 15724820720172937558n
```

---

title: Using Different Hashing Algorithms on Bunhash
description: Demonstrates how to access and use various hashing algorithms available as properties on `Bun.hash`, such as `wyhash`, `crc32`, `adler32`, `cityHash32`, `cityHash64`, `xxHash32`, `xxHash64`, `xxHash3`, `murmur32v3`, `murmur32v2`, `murmur64v2`, and `rapidhash`. It highlights that each algorithm returns either a number for 32-bit hashes or a bigint for 64-bit hashes.
source: docs/api/hashing.md#_snippet_7

language: typescript
code:
```
Bun.hash.wyhash("data", 1234); // equivalent to Bun.hash()
Bun.hash.crc32("data", 1234);
Bun.hash.adler32("data", 1234);
Bun.hash.cityHash32("data", 1234);
Bun.hash.cityHash64("data", 1234);
Bun.hash.xxHash32("data", 1234);
Bun.hash.xxHash64("data", 1234);
Bun.hash.xxHash3("data", 1234);
Bun.hash.murmur32v3("data", 1234);
Bun.hash.murmur32v2("data", 1234);
Bun.hash.murmur64v2("data", 1234);
Bun.hash.rapidhash("data", 1234);
```

---

title: Computing Hashes Incrementally Using CryptoHasher
description: Illustrates how to create a `Bun.CryptoHasher` instance, update it with data using `.update()`, and then compute the final hash using `.digest()`. The example uses the `sha256` algorithm and shows the basic workflow for incrementally hashing data.
source: docs/api/hashing.md#_snippet_8

language: typescript
code:
```
const hasher = new Bun.CryptoHasher("sha256");
hasher.update("hello world");
hasher.digest();
// Uint8Array(32) [ <byte>, <byte>, ... ]
```

---

title: Updating CryptoHasher with Multiple Data Types
description: Demonstrates that the `update` method of `Bun.CryptoHasher` can accept different data types, including `string`, `TypedArray`, and `ArrayBuffer`. It illustrates the flexibility in feeding data to the hasher from various sources.
source: docs/api/hashing.md#_snippet_9

language: typescript
code:
```
const hasher = new Bun.CryptoHasher("sha256");

hasher.update("hello world");
hasher.update(new Uint8Array([1, 2, 3]));
hasher.update(new ArrayBuffer(10));
```

---

title: Specifying String Encoding When Updating CryptoHasher
description: Illustrates how to specify the encoding when updating a `Bun.CryptoHasher` instance with a string. It shows examples using 'hex', 'base64', and 'latin1' encodings, demonstrating the ability to handle different string formats.
source: docs/api/hashing.md#_snippet_10

language: typescript
code:
```
hasher.update("hello world"); // defaults to utf8
hasher.update("hello world", "hex");
hasher.update("hello world", "base64");
hasher.update("hello world", "latin1");
```

---

title: Retrieving Digest Output in Different Formats
description: Demonstrates how to retrieve the digest output from `Bun.CryptoHasher` in different formats: as a `Uint8Array`, a base64-encoded string, or a hexadecimal-encoded string. It showcases the flexibility in obtaining the hash in a format suitable for various applications.
source: docs/api/hashing.md#_snippet_11

language: typescript
code:
```
const hasher = new Bun.CryptoHasher("sha256");
hasher.update("hello world");

hasher.digest();
// => Uint8Array(32) [ 185, 77, 39, 185, 147, ... ]
```

language: typescript
code:
```
hasher.digest("base64");
// => "uU0nuZNNPgilLlLX2n2r+sSE7+N6U4DukIj3rOLvzek="

hasher.digest("hex");
// => "b94d27b9934d3e08a52e52d7da7dabfac484efe37a5380ee9088f7ace2efcde9"
```

---

title: Writing Digest Output to a TypedArray
description: Illustrates how to write the digest output from `Bun.CryptoHasher` directly into a pre-existing `TypedArray` instance. This approach can be beneficial in performance-sensitive applications by avoiding unnecessary memory allocation.
source: docs/api/hashing.md#_snippet_12

language: typescript
code:
```
const arr = new Uint8Array(32);

hasher.digest(arr);

console.log(arr);
// => Uint8Array(32) [ 185, 77, 39, 185, 147, ... ]
```

---

title: Computing HMAC Digests Using CryptoHasher
description: Demonstrates how to compute an HMAC digest using `Bun.CryptoHasher` by passing a secret key to the constructor. The example showcases updating the hasher with data and then generating the HMAC digest in hexadecimal format.
source: docs/api/hashing.md#_snippet_13

language: typescript
code:
```
const hasher = new Bun.CryptoHasher("sha256", "secret-key");
hasher.update("hello world");
console.log(hasher.digest("hex"));
// => "095d5a21fe6d0646db223fdf3de6436bb8dfb2fab0b51677ecf6441fcf5f2a67"
```

---

title: Copying and Updating CryptoHasher for HMAC
description: Illustrates the usage of `.copy()` and `.update()` methods for HMAC `Bun.CryptoHasher` instances. A copy of the hasher is created, updated with additional data, and its digest computed, while the original hasher's digest remains unchanged, demonstrating isolated hash computations.
source: docs/api/hashing.md#_snippet_14

language: typescript
code:
```
const hasher = new Bun.CryptoHasher("sha256", "secret-key");
hasher.update("hello world");

const copy = hasher.copy();
copy.update("!");
console.log(copy.digest("hex"));
// => "3840176c3d8923f59ac402b7550404b28ab11cb0ef1fa199130a5c37864b5497"

console.log(hasher.digest("hex"));
// => "095d5a21fe6d0646db223fdf3de6436bb8dfb2fab0b51677ecf6441fcf5f2a67"
```

---

title: Generating a Lockfile Without Installing - CLI
description: Demonstrates how to generate a `bun.lock` file without installing dependencies to `node_modules` using the `--lockfile-only` flag. This command saves the lockfile to disk, even if it is already up-to-date with the `package.json` file.
source: docs/install/lockfile.md#_snippet_0

language: bash
code:
```
$ bun install --lockfile-only
```

---

title: Installing Without Creating a Lockfile - CLI
description: Illustrates how to install dependencies without generating a `bun.lock` file. This is achieved by using the `--no-save` flag during the `bun install` process.
source: docs/install/lockfile.md#_snippet_1

language: bash
code:
```
$ bun install --no-save
```

---

title: Installing with Yarn Lockfile Alongside Bun Lockfile - CLI Flag
description: Demonstrates how to generate a `yarn.lock` file in addition to the default `bun.lock` file during installation. The `--yarn` flag is used with the `bun install` command to achieve this.
source: docs/install/lockfile.md#_snippet_2

language: bash
code:
```
$ bun install --yarn
```

---

title: Creating an HTTP Server Using Node:http
description: Illustrates how to create a simple HTTP server using the `node:http` module. It imports the `http` module, creates a server that sends 'Hello World!' as a response, and listens on port 8080.
source: docs/ecosystem/express.md#_snippet_1

language: ts
code:
```
import * as http from "node:http";

http
  .createServer(function (req, res) {
    res.write("Hello World!");
    res.end();
  })
  .listen(8080);
```

---

title: Showing Input Types for HTMLRewriter - TS
description: Illustrates how `HTMLRewriter` can accept different input types for the HTML content to be transformed. The code demonstrates the usage of `Response`, `string`, `ArrayBuffer`, `Blob`, and `Bun.file` as valid input types, showcasing the flexibility of the API.
source: docs/api/html-rewriter.md#_snippet_1

language: ts
code:
```
// From Response
rewriter.transform(new Response("<div>content</div>"));

// From string
rewriter.transform("<div>content</div>");

// From ArrayBuffer
rewriter.transform(new TextEncoder().encode("<div>content</div>").buffer);

// From Blob
rewriter.transform(new Blob(["<div>content</div>"]));

// From File
rewriter.transform(Bun.file("index.html"));
```

---

title: Handling Elements, Text, and Comments with HTMLRewriter - TS
description: Demonstrates how to use element handlers with `HTMLRewriter` to modify HTML elements, text nodes, and comments. The example shows how to set attributes, append content, replace text, and remove comments using the `element`, `text`, and `comments` methods.
source: docs/api/html-rewriter.md#_snippet_2

language: ts
code:
```
rewriter.on("div.content", {
  // Handle elements
  element(element) {
    element.setAttribute("class", "new-content");
    element.append("<p>New content</p>", { html: true });
  },
  // Handle text nodes
  text(text) {
    text.replace("new text");
  },
  // Handle comments
  comments(comment) {
    comment.remove();
  },
});
```

---

title: Selecting HTML Elements Using CSS Selectors - TS
description: Demonstrates a wide range of CSS selectors supported by the `on()` method of `HTMLRewriter`. The example covers tag selectors, class selectors, ID selectors, attribute selectors, combinators, pseudo-classes, and the universal selector, showcasing the flexibility in targeting specific HTML elements.
source: docs/api/html-rewriter.md#_snippet_4

language: ts
code:
```
// Tag selectors
rewriter.on("p", handler);

// Class selectors
rewriter.on("p.red", handler);

// ID selectors
rewriter.on("h1#header", handler);

// Attribute selectors
rewriter.on("p[data-test]", handler); // Has attribute
rewriter.on('p[data-test="one"]', handler); // Exact match
rewriter.on('p[data-test="one" i]', handler); // Case-insensitive
rewriter.on('p[data-test="one" s]', handler); // Case-sensitive
rewriter.on('p[data-test~="two"]', handler); // Word match
rewriter.on('p[data-test^="a"]', handler); // Starts with
rewriter.on('p[data-test$="1"]', handler); // Ends with
rewriter.on('p[data-test*="b"]', handler); // Contains
rewriter.on('p[data-test|="a"]', handler); // Dash-separated

// Combinators
rewriter.on("div span", handler); // Descendant
rewriter.on("div > span", handler); // Direct child

// Pseudo-classes
rewriter.on("p:nth-child(2)", handler);
rewriter.on("p:first-child", handler);
rewriter.on("p:nth-of-type(2)", handler);
rewriter.on("p:first-of-type", handler);
rewriter.on("p:not(:first-child)", handler);

// Universal selector
rewriter.on("*", handler);
```

---

title: Manipulating HTML Elements with Element Operations - TS
description: Demonstrates various element operations available in `HTMLRewriter`, such as setting and removing attributes, manipulating content, positioning elements, and handling end tags. The example showcases method chaining and provides details on properties like `tagName`, `namespaceURI`, and `selfClosing`.
source: docs/api/html-rewriter.md#_snippet_5

language: ts
code:
```
rewriter.on("div", {
  element(el) {
    // Attributes
    el.setAttribute("class", "new-class").setAttribute("data-id", "123");

    const classAttr = el.getAttribute("class"); // "new-class"
    const hasId = el.hasAttribute("id"); // boolean
    el.removeAttribute("class");

    // Content manipulation
    el.setInnerContent("New content"); // Escapes HTML by default
    el.setInnerContent("<p>HTML content</p>", { html: true }); // Parses HTML
    el.setInnerContent(""); // Clear content

    // Position manipulation
    el.before("Content before")
      .after("Content after")
      .prepend("First child")
      .append("Last child");

    // HTML content insertion
    el.before("<span>before</span>", { html: true })
      .after("<span>after</span>", { html: true })
      .prepend("<span>first</span>", { html: true })
      .append("<span>last</span>", { html: true });

    // Removal
    el.remove(); // Remove element and contents
    el.removeAndKeepContent(); // Remove only the element tags

    // Properties
    console.log(el.tagName); // Lowercase tag name
    console.log(el.namespaceURI); // Element's namespace URI
    console.log(el.selfClosing); // Whether element is self-closing (e.g. <div />)
    console.log(el.canHaveContent); // Whether element can contain content (false for void elements like <br>)
    console.log(el.removed); // Whether element was removed

    // Attributes iteration
    for (const [name, value] of el.attributes) {
      console.log(name, value);
    }

    // End tag handling
    el.onEndTag(endTag => {
      endTag.before("Before end tag");
      endTag.after("After end tag");
      endTag.remove(); // Remove the end tag
      console.log(endTag.name); // Tag name in lowercase
    });
  },
});
```

---

title: Manipulating Text Content with Text Operations - TS
description: Demonstrates how to use text operations in `HTMLRewriter` to modify text content. The example shows how to access text content, check the position of text chunks, and use methods like `before`, `after`, `replace`, and `remove` to manipulate the text.
source: docs/api/html-rewriter.md#_snippet_6

language: ts
code:
```
rewriter.on("p", {
  text(text) {
    // Content
    console.log(text.text); // Text content
    console.log(text.lastInTextNode); // Whether this is the last chunk
    console.log(text.removed); // Whether text was removed

    // Manipulation
    text.before("Before text").after("After text").replace("New text").remove();

    // HTML content insertion
    text
      .before("<span>before</span>", { html: true })
      .after("<span>after</span>", { html: true })
      .replace("<span>replace</span>", { html: true });
  },
});
```

---

title: Manipulating Comments with Comment Operations - TS
description: Demonstrates how to use comment operations in `HTMLRewriter` to modify HTML comments. The example shows how to access and set comment text, and use methods like `before`, `after`, `replace`, and `remove` to manipulate the comments.
source: docs/api/html-rewriter.md#_snippet_7

language: ts
code:
```
rewriter.on("*", {
  comments(comment) {
    // Content
    console.log(comment.text); // Comment text
    comment.text = "New comment text"; // Set comment text
    console.log(comment.removed); // Whether comment was removed

    // Manipulation
    comment
      .before("Before comment")
      .after("After comment")
      .replace("New comment")
      .remove();

    // HTML content insertion
    comment
      .before("<span>before</span>", { html: true })
      .after("<span>after</span>", { html: true })
      .replace("<span>replace</span>", { html: true });
  },
});
```

---

title: Handling Document-Level Events with Document Handlers - TS
description: Demonstrates how to use document handlers in `HTMLRewriter` to handle document-level events. The example shows how to handle doctype declarations, text nodes, comments, and the document end event, illustrating the usage of `doctype`, `text`, `comments`, and `end` methods.
source: docs/api/html-rewriter.md#_snippet_8

language: ts
code:
```
rewriter.onDocument({
  // Handle doctype
  doctype(doctype) {
    console.log(doctype.name); // "html"
    console.log(doctype.publicId); // public identifier if present
    console.log(doctype.systemId); // system identifier if present
  },
  // Handle text nodes
  text(text) {
    console.log(text.text);
  },
  // Handle comments
  comments(comment) {
    console.log(comment.text);
  },
  // Handle document end
  end(end) {
    end.append("<!-- Footer -->", { html: true });
  },
});
```

---

title: Configuring Options For Specific Registry - npmrc
description: Demonstrates how to configure options, specifically authentication tokens, usernames, and passwords, for a specific registry using the `//<registry_url>/:<key>=<value>` format in `.npmrc`. This allows Bun to authenticate with private registries, enabling access to scoped packages or internal modules.
source: docs/install/npmrc.md#_snippet_2

language: ini
code:
```
# set an auth token for the registry
# ${...} is a placeholder for environment variables
//http://localhost:4873/:_authToken=${NPM_TOKEN}


# or you could set a username and password
# note that the password is base64 encoded
//http://localhost:4873/:username=myusername

//http://localhost:4873/:_password=${NPM_PASSWORD}

# or use _auth, which is your username and password
# combined into a single string, which is then base 64 encoded
//http://localhost:4873/:_auth=${NPM_AUTH}
```

---

title: Illustrating Prop Punning with JSX - TSX
description: Illustrates the use of JSX prop punning, a shorthand syntax for assigning a variable to a prop with the same name. This example shows how to pass the `className` variable as a prop to the `div` element using both the traditional and punning syntaxes.
source: docs/ecosystem/react.md#_snippet_1

language: tsx
code:
```
function Div(props: {className: string;}) {
  const {className} = props;

  // without punning
  return <div className={className} />;
  // with punning
  return <div {className} />;
}
```

---

title: Server-Side Rendering React Component - TSX
description: Demonstrates server-side rendering (SSR) of a React component using Bun's HTTP server API. The code imports `renderToReadableStream` from `react-dom/server`, defines a simple React component, and uses `Bun.serve` to create an HTTP server that renders the component to an HTML stream.  The stream is then returned as the response with the correct `Content-Type` header.
source: docs/ecosystem/react.md#_snippet_2

language: tsx
code:
```
import {renderToReadableStream} from 'react-dom/server';

function Component(props: {message: string}) {
  return (
    <body>
      <h1 style={{color: 'red'}}>{props.message}</h1>
    </body>
  );
}

Bun.serve({
  port: 4000,
  async fetch() {
    const stream = await renderToReadableStream(
      <Component message="Hello from server!" />
    );
    return new Response(stream, {
      headers: {'Content-Type': 'text/html'},
    });
  },
});
```

---

title: Creating a ReadableStream
description: Demonstrates how to create a simple `ReadableStream` with predefined chunks of data. This stream enqueues 'hello' and 'world' before closing, providing a basic example of stream creation.
source: docs/api/binary-data.md#_snippet_2

language: typescript
code:
```
const stream = new ReadableStream({
  start(controller) {
    controller.enqueue("hello");
    controller.enqueue("world");
    controller.close();
  },
});
```

---

title: Iterating Over a ReadableStream
description: Illustrates reading data from a `ReadableStream` using a `for await` loop. Each chunk of data is logged to the console, demonstrating how to consume data from a stream in a non-blocking manner.
source: docs/api/binary-data.md#_snippet_3

language: typescript
code:
```
for await (const chunk of stream) {
  console.log(chunk);
  // => "hello"
  // => "world"
}
```

---

title: Creating a TypedArray from ArrayBuffer
description: Shows how to create a `Uint8Array` (a type of `TypedArray`) from an existing `ArrayBuffer`. This creates a view of the underlying buffer, allowing you to access the data as an array of unsigned 8-bit integers.
source: docs/api/binary-data.md#_snippet_4

language: typescript
code:
```
new Uint8Array(buf);
```

---

title: Creating a DataView from ArrayBuffer
description: Demonstrates creating a `DataView` from an `ArrayBuffer`. This allows you to read and write different data types at any byte offset within the buffer.
source: docs/api/binary-data.md#_snippet_5

language: typescript
code:
```
new DataView(buf);
```

---

title: Creating a Buffer from ArrayBuffer
description: Illustrates creating a Node.js `Buffer` from an `ArrayBuffer`. The first example creates a buffer over the entire `ArrayBuffer`, while the second creates a buffer over a slice of the `ArrayBuffer` from index 0 up to (but not including) index 10.
source: docs/api/binary-data.md#_snippet_6

language: typescript
code:
```
// create Buffer over entire ArrayBuffer
Buffer.from(buf);

// create Buffer over a slice of the ArrayBuffer
Buffer.from(buf, 0, 10);
```

---

title: Decoding an ArrayBuffer to String
description: Shows how to decode an `ArrayBuffer` into a string using the UTF-8 encoding. A `TextDecoder` is used to convert the buffer into a human-readable string.
source: docs/api/binary-data.md#_snippet_7

language: typescript
code:
```
new TextDecoder().decode(buf);
```

---

title: Converting ArrayBuffer to Number Array
description: Demonstrates converting an `ArrayBuffer` to an array of numbers by first creating a `Uint8Array` view of the buffer. `Array.from` is then used to create a new array containing the byte values.
source: docs/api/binary-data.md#_snippet_8

language: typescript
code:
```
Array.from(new Uint8Array(buf));
```

---

title: Creating a Blob from ArrayBuffer
description: Illustrates creating a `Blob` from an `ArrayBuffer` with a specified MIME type. The `Blob` constructor takes an array containing the buffer and an options object for setting metadata.
source: docs/api/binary-data.md#_snippet_9

language: typescript
code:
```
new Blob([buf], { type: "text/plain" });
```

---

title: Creating a ReadableStream from ArrayBuffer
description: Demonstrates creating a `ReadableStream` from an `ArrayBuffer` by enqueuing the entire buffer as a single chunk. The `start` method of the stream controller is used to enqueue the data and close the stream.
source: docs/api/binary-data.md#_snippet_10

language: typescript
code:
```
new ReadableStream({
  start(controller) {
    controller.enqueue(buf);
    controller.close();
  },
});
```

---

title: Creating a Chunked ReadableStream from ArrayBuffer
description: Illustrates creating a chunked `ReadableStream` from an `ArrayBuffer`. It first creates a `Uint8Array` view of the buffer, then enqueues chunks of a specified size (1024 bytes) until the entire buffer has been enqueued.
source: docs/api/binary-data.md#_snippet_11

language: typescript
code:
```
const view = new Uint8Array(buf);
const chunkSize = 1024;

new ReadableStream({
  start(controller) {
    for (let i = 0; i < view.length; i += chunkSize) {
      controller.enqueue(view.slice(i, i + chunkSize));
    }
    controller.close();
  },
});
```

---

title: Getting ArrayBuffer from TypedArray
description: Demonstrates how to retrieve the underlying `ArrayBuffer` from a `TypedArray` instance. This accesses the buffer that the `TypedArray` is a view of.
source: docs/api/binary-data.md#_snippet_12

language: typescript
code:
```
arr.buffer;
```

---

title: Creating DataView from TypedArray
description: Illustrates how to create a `DataView` from a `TypedArray`. The `DataView` shares the same underlying buffer as the `TypedArray`, allowing for reading and writing different data types at specific byte offsets.
source: docs/api/binary-data.md#_snippet_13

language: typescript
code:
```
new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
```

---

title: Creating Buffer from TypedArray
description: Demonstrates creating a Node.js `Buffer` from a `TypedArray`. This creates a new `Buffer` instance containing a copy of the data from the `TypedArray`.
source: docs/api/binary-data.md#_snippet_14

language: typescript
code:
```
Buffer.from(arr);
```

---

title: Decoding TypedArray to String
description: Shows how to decode a `TypedArray` into a UTF-8 string using `TextDecoder`. This converts the byte data in the array into a human-readable string.
source: docs/api/binary-data.md#_snippet_15

language: typescript
code:
```
new TextDecoder().decode(arr);
```

---

title: Converting TypedArray to Number Array
description: Demonstrates converting a `TypedArray` to a regular JavaScript array of numbers using `Array.from()`. This creates a new array containing the numeric values from the `TypedArray`.
source: docs/api/binary-data.md#_snippet_16

language: typescript
code:
```
Array.from(arr);
```

---

title: Creating Blob from TypedArray
description: Illustrates how to create a `Blob` from a `TypedArray`'s underlying `ArrayBuffer`, only if the `TypedArray` is a view of its entire backing buffer. This is useful when you want to treat the `TypedArray` data as a file-like object.
source: docs/api/binary-data.md#_snippet_17

language: typescript
code:
```
// only if arr is a view of its entire backing TypedArray
new Blob([arr.buffer], { type: "text/plain" });
```

---

title: Creating ReadableStream from TypedArray
description: Demonstrates how to create a `ReadableStream` from a `TypedArray` by enqueuing the entire array as a single chunk.  This is useful for streaming the content of the `TypedArray`.
source: docs/api/binary-data.md#_snippet_18

language: typescript
code:
```
new ReadableStream({
  start(controller) {
    controller.enqueue(arr);
    controller.close();
  },
});
```

---

title: Creating Chunked ReadableStream from TypedArray
description: Illustrates creating a chunked `ReadableStream` from a `TypedArray`. The array is divided into smaller chunks, and each chunk is enqueued into the stream. This can improve performance when dealing with large arrays.
source: docs/api/binary-data.md#_snippet_19

language: typescript
code:
```
new ReadableStream({
  start(controller) {
    for (let i = 0; i < arr.length; i += chunkSize) {
      controller.enqueue(arr.slice(i, i + chunkSize));
    }
    controller.close();
  },
});
```

---

title: Getting ArrayBuffer from DataView
description: Demonstrates retrieving the underlying `ArrayBuffer` from a `DataView` instance. This accesses the buffer that the `DataView` is providing a view of.
source: docs/api/binary-data.md#_snippet_20

language: typescript
code:
```
view.buffer;
```

---

title: Creating TypedArray from DataView
description: Shows how to create a `TypedArray` (specifically a `Uint8Array`, `Uint16Array`, or `Uint32Array`) from a `DataView`. The `byteLength` of the `DataView` must be a multiple of the `BYTES_PER_ELEMENT` of the `TypedArray`.
source: docs/api/binary-data.md#_snippet_21

language: typescript
code:
```
new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
new Uint16Array(view.buffer, view.byteOffset, view.byteLength / 2);
new Uint32Array(view.buffer, view.byteOffset, view.byteLength / 4);
// etc...
```

---

title: Creating Buffer from DataView
description: Demonstrates creating a Node.js `Buffer` from a `DataView`. The `Buffer` will contain a copy of the data from the specified region of the underlying `ArrayBuffer`.
source: docs/api/binary-data.md#_snippet_22

language: typescript
code:
```
Buffer.from(view.buffer, view.byteOffset, view.byteLength);
```

---

title: Decoding DataView to String
description: Shows how to decode a `DataView` into a UTF-8 string using `TextDecoder`. This converts the byte data in the `DataView` to a readable string.
source: docs/api/binary-data.md#_snippet_23

language: typescript
code:
```
new TextDecoder().decode(view);
```

---

title: Converting DataView to Number Array
description: Demonstrates converting a `DataView` to a regular JavaScript array of numbers using `Array.from()`. This creates a new array containing the numeric values from the `DataView`.
source: docs/api/binary-data.md#_snippet_24

language: typescript
code:
```
Array.from(view);
```

---

title: Creating Blob from DataView
description: Illustrates how to create a `Blob` from a `DataView`'s underlying `ArrayBuffer`.  This creates a `Blob` containing a copy of the data.
source: docs/api/binary-data.md#_snippet_25

language: typescript
code:
```
new Blob([view.buffer], { type: "text/plain" });
```

---

title: Creating ReadableStream from DataView
description: Demonstrates how to create a `ReadableStream` from a `DataView`. This enqueues the `DataView`'s underlying buffer and closes the stream.
source: docs/api/binary-data.md#_snippet_26

language: typescript
code:
```
new ReadableStream({
  start(controller) {
    controller.enqueue(view.buffer);
    controller.close();
  },
});
```

---

title: Creating Chunked ReadableStream from DataView
description: Illustrates creating a chunked `ReadableStream` from a `DataView`. The underlying `ArrayBuffer` is divided into smaller chunks, and each chunk is enqueued into the stream.
source: docs/api/binary-data.md#_snippet_27

language: typescript
code:
```
new ReadableStream({
  start(controller) {
    for (let i = 0; i < view.byteLength; i += chunkSize) {
      controller.enqueue(view.buffer.slice(i, i + chunkSize));
    }
    controller.close();
  },
});
```

---

title: Getting ArrayBuffer from Buffer
description: Demonstrates how to retrieve the underlying `ArrayBuffer` from a Node.js `Buffer` instance. The `buffer` property provides direct access to the `ArrayBuffer`.
source: docs/api/binary-data.md#_snippet_28

language: typescript
code:
```
buf.buffer;
```

---

title: Creating TypedArray from Buffer
description: Demonstrates creating a `Uint8Array` (a type of `TypedArray`) from a Node.js `Buffer`. The `Uint8Array` provides a view of the `Buffer`'s data as unsigned 8-bit integers.
source: docs/api/binary-data.md#_snippet_29

language: typescript
code:
```
new Uint8Array(buf);
```

---

title: Creating DataView from Buffer
description: Shows how to create a `DataView` from a Node.js `Buffer`. The `DataView` provides a way to read and write different data types at any byte offset within the `Buffer`.
source: docs/api/binary-data.md#_snippet_30

language: typescript
code:
```
new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
```

---

title: Converting Buffer to String
description: Illustrates different methods to convert a Node.js `Buffer` to a string using various encodings, including UTF-8, base64, and hexadecimal.
source: docs/api/binary-data.md#_snippet_31

language: typescript
code:
```
buf.toString();

buf.toString("base64");

buf.toString("hex");
```

---

title: Converting Buffer to Number Array
description: Demonstrates converting a Node.js `Buffer` to a JavaScript array of numbers using `Array.from`. Each byte in the `Buffer` is represented as a number in the resulting array.
source: docs/api/binary-data.md#_snippet_32

language: typescript
code:
```
Array.from(buf);
```

---

title: Creating Blob from Buffer
description: Illustrates how to create a `Blob` from a Node.js `Buffer`.  This creates a `Blob` containing a copy of the data in the `Buffer`.
source: docs/api/binary-data.md#_snippet_33

language: typescript
code:
```
new Blob([buf], { type: "text/plain" });
```

---

title: Creating ReadableStream from Buffer
description: Demonstrates how to create a `ReadableStream` from a Node.js `Buffer`.  This enqueues the entire `Buffer` into the stream as a single chunk.
source: docs/api/binary-data.md#_snippet_34

language: typescript
code:
```
new ReadableStream({
  start(controller) {
    controller.enqueue(buf);
    controller.close();
  },
});
```

---

title: Creating Chunked ReadableStream from Buffer
description: Illustrates creating a chunked `ReadableStream` from a Node.js `Buffer`. The `Buffer` is divided into smaller chunks, and each chunk is enqueued into the stream.
source: docs/api/binary-data.md#_snippet_35

language: typescript
code:
```
new ReadableStream({
  start(controller) {
    for (let i = 0; i < buf.length; i += chunkSize) {
      controller.enqueue(buf.slice(i, i + chunkSize));
    }
    controller.close();
  },
});
```

---

title: Converting Blob to ArrayBuffer
description: Shows how to convert a `Blob` to an `ArrayBuffer` using the `blob.arrayBuffer()` method. This method returns a promise that resolves with the `ArrayBuffer` containing the data from the `Blob`.
source: docs/api/binary-data.md#_snippet_36

language: typescript
code:
```
await blob.arrayBuffer();
```

---

title: Converting Blob to TypedArray
description: Demonstrates converting a `Blob` to a `Uint8Array` using the `blob.bytes()` method.  This method returns a promise that resolves with the `Uint8Array` containing the data from the `Blob`.
source: docs/api/binary-data.md#_snippet_37

language: typescript
code:
```
await blob.bytes();
```

---

title: Creating DataView from Blob
description: Illustrates how to create a `DataView` from a `Blob` by first converting the `Blob` to an `ArrayBuffer` and then creating a `DataView` from the `ArrayBuffer`.
source: docs/api/binary-data.md#_snippet_38

language: typescript
code:
```
new DataView(await blob.arrayBuffer());
```

---

title: Creating Buffer from Blob
description: Illustrates creating a Node.js `Buffer` from a `Blob`. This involves first converting the `Blob` to an `ArrayBuffer` and then creating the `Buffer` from the `ArrayBuffer`.
source: docs/api/binary-data.md#_snippet_39

language: typescript
code:
```
Buffer.from(await blob.arrayBuffer());
```

---

title: Converting Blob to String
description: Shows how to convert a `Blob` to a string using `blob.text()`. This method returns a promise that resolves with the string representation of the `Blob`'s content.
source: docs/api/binary-data.md#_snippet_40

language: typescript
code:
```
await blob.text();
```

---

title: Converting Blob to Number Array
description: Demonstrates how to convert a `Blob` to a JavaScript array of numbers.  This involves first converting the `Blob` to a `Uint8Array` using `blob.bytes()` and then converting the `Uint8Array` to a number array.
source: docs/api/binary-data.md#_snippet_41

language: typescript
code:
```
Array.from(await blob.bytes());
```

---

title: Creating ReadableStream from Blob
description: Illustrates how to create a `ReadableStream` from a `Blob` using `blob.stream()`. This allows for streaming the content of the `Blob` without loading the entire `Blob` into memory.
source: docs/api/binary-data.md#_snippet_42

language: typescript
code:
```
blob.stream();
```

---

title: Converting ReadableStream to ArrayBuffer
description: Demonstrates two methods for converting a `ReadableStream` to an `ArrayBuffer`: using `new Response(stream).arrayBuffer()` and `Bun.readableStreamToArrayBuffer(stream)`. The Bun-specific function is generally more efficient.
source: docs/api/binary-data.md#_snippet_43

language: typescript
code:
```
// with Response
new Response(stream).arrayBuffer();

// with Bun function
Bun.readableStreamToArrayBuffer(stream);
```

---

title: Converting ReadableStream to Uint8Array
description: Illustrates two methods for converting a `ReadableStream` to a `Uint8Array`: using `new Response(stream).bytes()` and `Bun.readableStreamToBytes(stream)`. The Bun-specific function is generally more efficient.
source: docs/api/binary-data.md#_snippet_44

language: typescript
code:
```
// with Response
new Response(stream).bytes();

// with Bun function
Bun.readableStreamToBytes(stream);
```

---

title: Creating TypedArray from ReadableStream
description: Demonstrates how to create a `TypedArray` (specifically an `Int8Array`) from a `ReadableStream`. This is achieved by first converting the stream to an `ArrayBuffer` using either `Response` or a Bun-specific function, and then creating the `TypedArray` from the buffer.
source: docs/api/binary-data.md#_snippet_45

language: typescript
code:
```
// with Response
const buf = await new Response(stream).arrayBuffer();
new Int8Array(buf);

// with Bun function
new Int8Array(Bun.readableStreamToArrayBuffer(stream));
```

---

title: Creating DataView from ReadableStream
description: Illustrates how to create a `DataView` from a `ReadableStream`. This is achieved by first converting the stream to an `ArrayBuffer` using either `Response` or a Bun-specific function, and then creating the `DataView` from the buffer.
source: docs/api/binary-data.md#_snippet_46

language: typescript
code:
```
// with Response
const buf = await new Response(stream).arrayBuffer();
new DataView(buf);

// with Bun function
new DataView(Bun.readableStreamToArrayBuffer(stream));
```

---

title: Creating Buffer from ReadableStream
description: Demonstrates how to create a Node.js `Buffer` from a `ReadableStream`. The `ReadableStream` is first converted to an `ArrayBuffer` using either the `Response` API or a Bun-specific function, then the `Buffer` is created from the `ArrayBuffer`.
source: docs/api/binary-data.md#_snippet_47

language: typescript
code:
```
// with Response
const buf = await new Response(stream).arrayBuffer();
Buffer.from(buf);

// with Bun function
Buffer.from(Bun.readableStreamToArrayBuffer(stream));
```

---

title: Converting ReadableStream to String
description: Illustrates converting a `ReadableStream` to a UTF-8 string using either `new Response(stream).text()` or `Bun.readableStreamToText(stream)`. The Bun-specific function is typically more efficient.
source: docs/api/binary-data.md#_snippet_48

language: typescript
code:
```
// with Response
await new Response(stream).text();

// with Bun function
await Bun.readableStreamToText(stream);
```

---

title: Defining a Singular Version Catalog
description: Demonstrates the use of a single default catalog named `catalog` for commonly used dependencies in `package.json`. References use the simple `catalog:` syntax.
source: docs/install/catalogs.md#_snippet_2

language: json
code:
```
   "catalog": {
     "react": "^19.0.0",
     "react-dom": "^19.0.0"
   }
```

language: json
code:
```
   "dependencies": {
     "react": "catalog:"
   }
```

---

title: Defining Multiple Named Version Catalogs
description: Illustrates the configuration of multiple named catalogs within the `catalogs` object in `package.json`. These allow for organizing and grouping dependencies. References use `catalog:<name>` syntax.
source: docs/install/catalogs.md#_snippet_3

language: json
code:
```
   "catalogs": {
     "testing": {
       "jest": "30.0.0"
     },
     "ui": {
       "tailwind": "4.0.0"
     }
   }
```

language: json
code:
```
   "dependencies": {
     "jest": "catalog:testing",
     "tailwind": "catalog:ui"
   }
```

---

title: Consuming React Monorepo Catalogs
description: Illustrates how to reference the dependencies defined in root package.json in various child packages like `app`, `@monorepo/ui`, and `@monorepo/utils` using the `catalog:` protocol. This ensures consistent versioning across the monorepo.
source: docs/install/catalogs.md#_snippet_5

language: json
code:
```
{
  "name": "app",
  "dependencies": {
    "react": "catalog:",
    "react-dom": "catalog:",
    "react-router-dom": "catalog:",
    "@monorepo/ui": "workspace:*",
    "@monorepo/utils": "workspace:*"
  },
  "devDependencies": {
    "webpack": "catalog:build",
    "babel": "catalog:build",
    "jest": "catalog:testing",
    "react-testing-library": "catalog:testing"
  }
}
```

language: json
code:
```
{
  "name": "@monorepo/ui",
  "dependencies": {
    "react": "catalog:",
    "react-dom": "catalog:"
  },
  "devDependencies": {
    "jest": "catalog:testing",
    "react-testing-library": "catalog:testing"
  }
}
```

language: json
code:
```
{
  "name": "@monorepo/utils",
  "dependencies": {
    "react": "catalog:"
  },
  "devDependencies": {
    "jest": "catalog:testing"
  }
}
```

---

title: Understanding Isolated Install Directory Structure
description: Shows the two-tier directory structure created by isolated installs, where packages are installed in versioned directories within `node_modules/.bun/`. Top-level `node_modules` contains symlinks pointing to the central store. This prevents phantom dependencies and ensures deterministic resolution.
source: docs/install/isolated.md#_snippet_2

language: text
code:
```
node_modules/
â”œâ”€â”€ .bun/                          # Central package store
â”‚   â”œâ”€â”€ package@1.0.0/             # Versioned package installations
â”‚   â”‚   â””â”€â”€ node_modules/
â”‚   â”‚       â””â”€â”€ package/           # Actual package files
â”‚   â”œâ”€â”€ @scope+package@2.1.0/      # Scoped packages (+ replaces /)
â”‚   â”‚   â””â”€â”€ node_modules/
â”‚   â”‚       â””â”€â”€ @scope/
â”‚   â”‚           â””â”€â”€ package/
â”‚   â””â”€â”€ ...
â””â”€â”€ package-name -> .bun/package@1.0.0/node_modules/package  # Symlinks
```

---

title: Migrating from npm or Yarn to Bun Isolated Installs
description: Shows the steps to migrate from npm or Yarn to Bun using isolated installs, including removing existing `node_modules` directories, lockfiles, and then installing dependencies with the `--linker isolated` flag. This ensures a clean transition to Bun's isolated dependency management.
source: docs/install/isolated.md#_snippet_5

language: bash
code:
```
# Remove existing node_modules and lockfiles
$ rm -rf node_modules package-lock.json yarn.lock

# Install with isolated linker
$ bun install --linker isolated
```

---

title: Migrating from pnpm to Bun Isolated Installs
description: Illustrates how to migrate from pnpm to Bun's isolated installs. It involves removing the `node_modules` directory and `pnpm-lock.yaml` file before installing dependencies using Bun with the `--linker isolated` flag. This facilitates a smooth transition to Bun's dependency management approach, which uses symlinks in `node_modules`.
source: docs/install/isolated.md#_snippet_6

language: bash
code:
```
# Remove pnpm files
$ rm -rf node_modules pnpm-lock.yaml

# Install with Bun's isolated linker
$ bun install --linker isolated
```

---

title: Logging CSS Module Class Names
description: Illustrates how importing a CSS module file creates an object with class names as keys and unique identifiers as values. The `console.log` statements print these objects to the console, showing the mapping between the original class names and their unique, scoped identifiers.
source: docs/bundler/css_modules.md#_snippet_1

language: tsx
code:
```
import styles from "./styles.module.css";
import otherStyles from "./other-styles.module.css";

console.log(styles);
console.log(otherStyles);
```

language: ts
code:
```
{
  button: "button_123";
}

{
  button: "button_456";
}
```

---

title: Composing CSS Classes
description: Demonstrates how to reuse style rules across multiple classes using the `composes` property in CSS modules. This allows for inheriting styles from one class to another, simplifying CSS maintenance and reducing redundancy.
source: docs/bundler/css_modules.md#_snippet_2

language: css
code:
```
/* styles.module.css */
.button {
  composes: background;
  color: red;
}

.background {
  background-color: blue;
}
```

---

title: Composing CSS Classes from a Separate Module
description: Illustrates how to compose styles from another CSS module file using the `composes` property.  This promotes modularity and reusability by allowing styles to be shared across different modules.
source: docs/bundler/css_modules.md#_snippet_3

language: css
code:
```
/* background.module.css */
.background {
  background-color: blue;
}

/* styles.module.css */
.button {
  composes: background from "./background.module.css";
  color: red;
}
```

---

title: Setting Custom Headers Using Headers API
description: Demonstrates how to set custom HTTP headers using the `Headers` object in Bun's `fetch` API. This allows you to add or modify headers for requests, such as custom authorization or content type specifications.
source: docs/api/fetch.md#_snippet_2

language: typescript
code:
```
const headers = new Headers();
headers.append(
```

language: typescript
code:
```
const response = await fetch("http://example.com", {
  headers,
});
```

---

title: Fetching From an S3 Bucket
description: Demonstrates how to fetch objects from an S3 bucket directly using Bun's `fetch` API with the `s3://` protocol.  The example uses environment variables, or explicit credentials, for authentication.
source: docs/api/fetch.md#_snippet_11

language: typescript
code:
```
// Using environment variables for credentials
const response = await fetch("s3://my-bucket/path/to/object");

// Or passing credentials explicitly
const response = await fetch("s3://my-bucket/path/to/object", {
  s3: {
    accessKeyId: "YOUR_ACCESS_KEY",
    secretAccessKey: "YOUR_SECRET_KEY",
    region: "us-east-1",
  },
});
```

---

title: Fetching Local Files Using File Protocol
description: Demonstrates fetching local files using the `file:` protocol with Bun's `fetch` API. The example shows accessing a text file and reading its content, and illustrates automatic path normalization on Windows.
source: docs/api/fetch.md#_snippet_12

language: typescript
code:
```
const response = await fetch("file:///path/to/file.txt");
const text = await response.text();
```

language: typescript
code:
```
// Both work on Windows
const response = await fetch("file:///C:/path/to/file.txt");
const response2 = await fetch("file:///c:/path\\to/file.txt");
```

---

title: Fetching Data URLs
description: Illustrates how to fetch data URLs using Bun's `fetch` API. The example demonstrates fetching a base64 encoded string, decoding it, and reading the content.
source: docs/api/fetch.md#_snippet_13

language: typescript
code:
```
const response = await fetch("data:text/plain;base64,SGVsbG8sIFdvcmxkIQ==");
const text = await response.text(); // "Hello, World!"
```

---

title: Fetching Blob URLs
description: Shows how to fetch blobs using URLs created by `URL.createObjectURL()` with Bun's `fetch` API. This allows fetching in-memory data represented as a Blob.
source: docs/api/fetch.md#_snippet_14

language: typescript
code:
```
const blob = new Blob(["Hello, World!"], { type: "text/plain" });
const url = URL.createObjectURL(blob);
const response = await fetch(url);
```

---

title: Defining Build with Specific Values - CLI
description: Demonstrates the syntax difference between `esbuild` and `bun build` for defining build configurations. In `bun build`, the colon is omitted when assigning values to flags like `--define`.
source: docs/bundler/vs-esbuild.md#_snippet_0

language: bash
code:
```
$ esbuild --define:foo=bar
$ bun build --define foo=bar
```

---

title: Externalizing Packages in Builds - CLI
description: Illustrates how to externalize packages during the build process using both `esbuild` and `bun build`. Notice the colon is omitted in `bun build` when specifying the external package.
source: docs/bundler/vs-esbuild.md#_snippet_1

language: bash
code:
```
$ esbuild --external:react
$ bun build --external react
```

---

title: Specifying Loader Syntax - CLI
description: Demonstrates the syntax differences between `esbuild` and `bun build` when specifying loaders for different file extensions.  `bun build` requires a colon between the extension and the loader, unlike `esbuild`.
source: docs/bundler/vs-esbuild.md#_snippet_2

language: bash
code:
```
$ esbuild app.ts --bundle --loader:.svg=text
$ bun build app.ts --loader .svg:text
```

---

title: Configuring Asset Naming - TS
description: Demonstrates how to configure asset naming in `Bun.build` using the `naming.asset` option.  The `[ext]` placeholder must be explicitly included to preserve file extensions in the output.
source: docs/bundler/vs-esbuild.md#_snippet_3

language: typescript
code:
```
Bun.build({
  entrypoints: ["./index.tsx"],
  naming: {
    asset: "[name].[ext]",
  },
});
```

---

title: Configuring Chunk Naming - TS
description: Demonstrates how to configure chunk naming in `Bun.build` using the `naming.chunk` option. The `[ext]` placeholder must be explicitly included to preserve file extensions in the output.
source: docs/bundler/vs-esbuild.md#_snippet_4

language: typescript
code:
```
Bun.build({
  entrypoints: ["./index.tsx"],
  naming: {
    chunk: "[name].[ext]",
  },
});
```

---

title: Configuring Granular Naming Options - TS
description: Demonstrates how to configure granular naming options using `Bun.build`. It showcases how the `naming` key can be a string or an object, allowing for the configuration of `entry`, `asset`, and `chunk` naming.
source: docs/bundler/vs-esbuild.md#_snippet_5

language: typescript
code:
```
Bun.build({
  entrypoints: ["./index.tsx"],
  // when string, this is equivalent to entryNames
  naming: "[name].[ext]",

  // granular naming options
  naming: {
    entry: "[name].[ext]",
    asset: "[name].[ext]",
    chunk: "[name].[ext]",
  },
});
```

---

title: Configuring Minification - TS
description: Illustrates how to configure minification options in `Bun.build`.  The `minify` option can be set to `true` to enable all minification features, or it can be an object to configure specific minification features like `identifiers`, `syntax`, and `whitespace`.
source: docs/bundler/vs-esbuild.md#_snippet_6

language: typescript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  // enable all minification
  minify: true

  // granular options
  minify: {
    identifiers: true,
    syntax: true,
    whitespace: true
  }
})
```

---

title: Defining Bun Plugin
description: Demonstrates how to define a Bun plugin, which requires a `name` and a `setup` function. The `setup` function receives a `builder` object, which can be used to hook into the bundling process.
source: docs/bundler/vs-esbuild.md#_snippet_7

language: typescript
code:
```
import type { BunPlugin } from "bun";

const myPlugin: BunPlugin = {
  name: "my-plugin",
  setup(builder) {
    // define plugin
  },
};
```

---

title: Using Bun Plugin Builder API
description: Illustrates how to use the `onResolve` and `onLoad` methods on the `builder` object within a Bun plugin. These methods allow you to hook into the bundling process and modify how modules are resolved and loaded.
source: docs/bundler/vs-esbuild.md#_snippet_8

language: typescript
code:
```
import type { BunPlugin } from "bun";
const myPlugin: BunPlugin = {
  name: "my-plugin",
  setup(builder) {
    builder.onResolve(
      {
        /* onResolve.options */
      },
      args => {
        return {
          /* onResolve.results */
        };
      },
    );
    builder.onLoad(
      {
        /* onLoad.options */
      },
      args => {
        return {
          /* onLoad.results */
        };
      },
    );
  },
};
```

---

title: Configuring Subprocesses with Parameters
description: Illustrates how to configure a subprocess using the parameters object in `Bun.spawn()`. It sets the working directory, environment variables, and defines an exit handler. It also shows how to access the process ID of the subprocess.
source: docs/api/spawn.md#_snippet_1

language: typescript
code:
```
const proc = Bun.spawn(["bun", "--version"], {
  cwd: "./path/to/subdir", // specify a working directory
  env: { ...process.env, FOO: "bar" }, // specify environment variables
  onExit(proc, exitCode, signalCode, error) {
    // exit handler
  },
});

proc.pid; // process ID of subprocess
```

---

title: Providing Input to a Subprocess Using `fetch`
description: Demonstrates how to pipe the content from a `fetch` request to the `stdin` of a subprocess. This example fetches the content of a file from GitHub and sends it to the `cat` command, which then outputs the content to `stdout`.
source: docs/api/spawn.md#_snippet_2

language: typescript
code:
```
const proc = Bun.spawn(["cat"], {
  stdin: await fetch(
    "https://raw.githubusercontent.com/oven-sh/bun/main/examples/hashing.js",
  ),
});

const text = await proc.stdout.text();
console.log(text); // "const input = \"hello world\".repeat(400); ..."
```

---

title: Writing Incrementally to a Subprocess's Input Stream
description: Illustrates how to incrementally write data to the `stdin` of a subprocess using the `pipe` option. The example demonstrates writing string and binary data, flushing the buffer, and closing the input stream.
source: docs/api/spawn.md#_snippet_3

language: typescript
code:
```
const proc = Bun.spawn(["cat"], {
  stdin: "pipe", // return a FileSink for writing
});

// enqueue string data
proc.stdin.write("hello");

// enqueue binary data
const enc = new TextEncoder();
proc.stdin.write(enc.encode(" world!"));

// send buffered data
proc.stdin.flush();

// close the input stream
proc.stdin.end();
```

---

title: Piping Data from a ReadableStream to `stdin`
description: Shows how to pipe data from a JavaScript `ReadableStream` directly to the `stdin` of a subprocess. The example creates a `ReadableStream` that enqueues two strings and then closes, piping to `cat`.
source: docs/api/spawn.md#_snippet_4

language: typescript
code:
```
const stream = new ReadableStream({
  start(controller) {
    controller.enqueue("Hello from ");
    controller.enqueue("ReadableStream!");
    controller.close();
  },
});

const proc = Bun.spawn(["cat"], {
  stdin: stream,
  stdout: "pipe",
});

const output = await new Response(proc.stdout).text();
console.log(output); // "Hello from ReadableStream!"
```

---

title: Reading Output from Subprocess Streams
description: Demonstrates how to read from the `stdout` stream of a subprocess. It retrieves the Bun version using `Bun.spawn` and then reads the output as text.
source: docs/api/spawn.md#_snippet_5

language: typescript
code:
```
const proc = Bun.spawn(["bun", "--version"]);
const text = await proc.stdout.text();
console.log(text); // => "$BUN_LATEST_VERSION\n"
```

---

title: Handling Process Exits
description: Illustrates how to use the `onExit` callback to listen for a process exiting.  Also demonstrates how to access properties like `killed`, `exitCode`, and `signalCode` after process termination.
source: docs/api/spawn.md#_snippet_6

language: typescript
code:
```
const proc = Bun.spawn(["bun", "--version"], {
  onExit(proc, exitCode, signalCode, error) {
    // exit handler
  },
});
```

language: typescript
code:
```
const proc = Bun.spawn(["bun", "--version"]);

await proc.exited; // resolves when process exit
proc.killed; // boolean - was the process killed?
proc.exitCode; // null | number
proc.signalCode; // null | "SIGABRT" | "SIGALRM" | ...
```

---

title: Killing a Process
description: Demonstrates how to kill a spawned process using `proc.kill()`. It shows how to kill with a default signal, a specified signal code, and a signal name. `proc.unref()` detaches the child process from the parent.
source: docs/api/spawn.md#_snippet_7

language: typescript
code:
```
const proc = Bun.spawn(["bun", "--version"]);
proc.kill();
proc.killed; // true

proc.kill(15); // specify a signal code
proc.kill("SIGTERM"); // specify a signal name
```

language: typescript
code:
```
const proc = Bun.spawn(["bun", "--version"]);
proc.unref();
```

---

title: Spawning Synchronously with `Bun.spawnSync()`
description: Shows how to use `Bun.spawnSync()`, which is the synchronous (blocking) equivalent of `Bun.spawn()`. The example executes the `echo` command and prints the output to the console. Note that `stdout` and `stderr` are instances of `Buffer` instead of `ReadableStream`.
source: docs/api/spawn.md#_snippet_16

language: typescript
code:
```
const proc = Bun.spawnSync(["echo", "hello"]);

console.log(proc.stdout.toString());
// => "hello\n"
```

---

title: Defining Bun Request Interface
description: Illustrates the `BunRequest` interface, which extends the standard `Request` interface. It provides access to route parameters through the `params` property and cookies through the `cookies` property.
source: docs/api/http.md#_snippet_1

language: typescript
code:
```
// Simplified for brevity
interface BunRequest<T extends string> extends Request {
  params: Record<T, string>;
  readonly cookies: CookieMap;
}
```

---

title: Using Promises in Bun Serve Routes
description: Illustrates returning a `Promise<Response>` from a `Bun.serve` route handler. This approach allows asynchronous operations, like delayed responses or data fetching, to be handled within the route.
source: docs/api/http.md#_snippet_3

language: typescript
code:
```
import { sql, serve } from "bun";

serve({
  routes: {
    "/api/version": () => {
      return new Promise(resolve => {
        setTimeout(async () => {
          const [version] = await sql`SELECT version()`;
          resolve(Response.json(version));
        }, 100);
      });
    },
  },
});
```

---

title: Utilizing Type-Safe Route Parameters in Bun Serve
description: Explains how TypeScript can parse route parameters in `Bun.serve` when defined as string literals.  Accessing `req.params` benefits from autocomplete support.  It shows explicit typing for `BunRequest`.
source: docs/api/http.md#_snippet_4

language: typescript
code:
```
import type { BunRequest } from "bun";

Bun.serve({
  routes: {
    // TypeScript knows the shape of params when passed as a string literal
    "/orgs/:orgId/repos/:repoId": req => {
      const { orgId, repoId } = req.params;
      return Response.json({ orgId, repoId });
    },

    "/orgs/:orgId/repos/:repoId/settings": (
      // optional: you can explicitly pass a type to BunRequest:
      req: BunRequest<"/orgs/:orgId/repos/:repoId/settings">,
    ) => {
      const { orgId, repoId } = req.params;
      return Response.json({ orgId, repoId });
    },
  },
});
```

---

title: Handling Per-HTTP Method Routes with Bun Serve
description: Demonstrates defining separate handlers for different HTTP methods within a single route in `Bun.serve`. This allows for different logic based on the HTTP method used, such as `GET`, `POST`, `PUT`, and `DELETE`.
source: docs/api/http.md#_snippet_9

language: typescript
code:
```
Bun.serve({
  routes: {
    "/api/posts": {
      // Different handlers per method
      GET: () => new Response("List posts"),
      POST: async req => {
        const post = await req.json();
        return Response.json({ id: crypto.randomUUID(), ...post });
      },
      PUT: async req => {
        const updates = await req.json();
        return Response.json({ updated: true, ...updates });
      },
      DELETE: () => new Response(null, { status: 204 }),
    },
  },
});
```

---

title: Managing Error Handling in Bun Serve
description: Demonstrates structured error handling in `Bun.serve`. Errors thrown within route handlers are automatically caught, and a global error handler can be defined to customize the error response.
source: docs/api/http.md#_snippet_12

language: typescript
code:
```
Bun.serve({
  routes: {
    // Errors are caught automatically
    "/api/risky": () => {
      throw new Error("Something went wrong");
    },
  },
  // Global error handler
  error(error) {
    console.error(error);
    return new Response(`Internal Error: ${error.message}`, {
      status: 500,
      headers: {
        "Content-Type": "text/plain",
      },
    });
  },
});
```

---

title: Defining onBeforeParse Callback -TS
description: Defines the TypeScript signature for the `onBeforeParse` callback within Bun's plugin system. This signature specifies the arguments required for the callback, including the filter and namespace, as well as the napiModule and symbol for the native plugin.
source: docs/bundler/plugins.md#_snippet_4

language: ts
code:
```
onBeforeParse(
  args: { filter: RegExp; namespace?: string },
  callback: { napiModule: NapiModule; symbol: string; external?: unknown },
): void;
```

---

title: Using JavaScript to Access Build Artifacts
description: Shows how to access and process build artifacts after bundling using the JavaScript API. The code iterates through the `outputs` array of the build result, reading the content of each artifact as text and writing it to a specified path.
source: docs/bundler/index.md#_snippet_3

language: ts
code:
```
const result = await Bun.build({
  entrypoints: ["./index.ts"],
});

for (const res of result.outputs) {
  // Can be consumed as blobs
  await res.text();

  // Bun will set Content-Type and Etag headers
  new Response(res);

  // Can be written manually, but you should use `outdir` in this case.
  Bun.write(path.join("out", res.path), res);
}
```

---

title: Setting the Target Environment
description: Demonstrates how to configure the target environment for the bundle using both the JavaScript API and CLI. Specifying `browser` as the target ensures the code is optimized for browser execution.
source: docs/bundler/index.md#_snippet_4

language: ts
code:
```
await Bun.build({
  entrypoints: ['./index.ts'],
  outdir: './out',
  target: 'browser', // default
})
```

language: bash
code:
```
$ bun build --entrypoints ./index.ts --outdir ./out --target browser
```

---

title: Adding a Package as a Dev Dependency
description: Demonstrates how to use the `--dev` or `-d` flag with `bun add` to add a package as a development dependency (`devDependencies`).  Development dependencies are typically tools used for building, testing, or documentation.
source: docs/install/index.md#_snippet_7

language: bash
code:
```
$ bun add --dev @types/react
$ bun add -d @types/react
```

---

title: Adding a Package as an Optional Dependency
description: Illustrates how to use the `--optional` flag with `bun add` to add a package as an optional dependency (`optionalDependencies`). Optional dependencies are dependencies that can be safely ignored if they fail to install.
source: docs/install/index.md#_snippet_8

language: bash
code:
```
$ bun add --optional lodash
```

---

title: Adding a Package as a Peer Dependency
description: Demonstrates how to use the `--peer` flag with `bun add` to add a package as a peer dependency (`peerDependencies`). Peer dependencies are dependencies that the package expects the consumer to also have installed.
source: docs/install/index.md#_snippet_9

language: bash
code:
```
$ bun add --peer @types/bun
```

---

title: Removing a Dependency
description: Demonstrates how to use `bun remove` to remove a specific package from the project's dependencies. This command updates the `package.json` and `bun.lock` files.
source: docs/install/index.md#_snippet_11

language: bash
code:
```
$ bun remove preact
```

---

title: Adding a Dependency from Git Repository
description: Demonstrates how to install a package directly from a Git repository using `bun install`.  This can be done using various Git protocols like `github`, `git`, `git+ssh`, and `git+https`.
source: docs/install/index.md#_snippet_12

language: bash
code:
```
$ bun install git@github.com:moment/moment.git
```

---

title: Adding Tarball Dependencies
description: Demonstrates how to specify a dependency as a direct URL to a `.tgz` tarball file in the `package.json`. During `bun install`, Bun will download and install the package from the specified tarball URL instead of from a package registry.
source: docs/install/index.md#_snippet_14

language: json
code:
```
{
  "dependencies": {
    "zod": "https://registry.npmjs.org/zod/-/zod-3.21.4.tgz"
  }
}
```

---

title: Bundling CSS with Imports - CSS
description: Demonstrates how to use `@import` in CSS files to include other CSS files.  The first snippet imports `./abc.css` into `styles.css`, and the subsequent snippet defines styles within `abc.css`. Bun automatically bundles these CSS files together during the build process.
source: docs/bundler/html.md#_snippet_2

language: css
code:
```
@import "./abc.css";

.container {
  background-color: blue;
}
```

language: css
code:
```
body {
  background-color: red;
}
```

language: css
code:
```
body {
  background-color: red;
}

.container {
  background-color: blue;
}
```

---

title: Referencing Local Assets in CSS - CSS
description: Demonstrates how to reference local assets, such as images, within CSS files. The `background-image` property uses a relative URL (`./logo.png`). During the build, Bun copies the asset to the output directory and rewrites the URL to include a content hash, ensuring proper asset handling and caching.
source: docs/bundler/html.md#_snippet_3

language: css
code:
```
body {
  background-image: url("./logo.png");
}
```

language: css
code:
```
body {
  background-image: url("./logo-[ABC123].png");
}
```

---

title: Importing CSS in JavaScript - TypeScript
description: Illustrates how to import CSS files directly within JavaScript/TypeScript modules.  Importing CSS in this way associates the styles with the JavaScript entry point. Bun then bundles all imported CSS files into a single CSS file per entry point during the build process, creating `./app.css` and `./app.js` in the output.
source: docs/bundler/html.md#_snippet_4

language: ts
code:
```
import "./styles.css";
import "./more-styles.css";
```

---

title: Importing Native Addons
description: Demonstrates how to import a native addon (`.node` file) in Bun. In the runtime, native addons can be directly imported.
source: docs/bundler/loaders.md#_snippet_6

language: ts
code:
```
import addon from "./addon.node";
console.log(addon);
```

---

title: Importing SQLite Databases
description: Demonstrates how to import an SQLite database using the `sqlite` loader in Bun. This loads the database using `bun:sqlite` and supports embedding the database into the bundle.
source: docs/bundler/loaders.md#_snippet_7

language: ts
code:
```
import db from "./my.db" with { type: "sqlite" };
```

---

title: Importing Files as Paths
description: Demonstrates how to import a file and resolve it as a path/URL to the imported file using the `file` loader. This is commonly used for referencing media or font assets.
source: docs/bundler/loaders.md#_snippet_10

language: ts
code:
```
import logo from "./logo.svg";
console.log(logo);
```

---

title: Handling Requests with the Fetch Handler
description: Illustrates how to use the `fetch` handler in `Bun.serve` to handle incoming HTTP requests.  It shows how to inspect the request URL and return different responses based on the path. This provides a basic routing mechanism when specific routes aren't defined.
source: docs/api/http.md#_snippet_1

language: typescript
code:
```
Bun.serve({
  fetch(req) {
    const url = new URL(req.url);
    if (url.pathname === "/") return new Response("Home page!");
    if (url.pathname === "/blog") return new Response("Blog!");
    return new Response("404!");
  },
});
```

---

title: Using Async/Await in the Fetch Handler
description: Demonstrates how the `fetch` handler in `Bun.serve` supports asynchronous operations using `async/await`. This allows for performing tasks like waiting for a specified duration before returning a response. It shows how to use `sleep` to simulate asynchronous behavior.
source: docs/api/http.md#_snippet_2

language: typescript
code:
```
import { sleep, serve } from "bun";
serve({
  async fetch(req) {
    const start = performance.now();
    await sleep(10);
    const end = performance.now();
    return new Response(`Slept for ${end - start}ms`);
  },
});
```

---

title: Accessing the Server Object from Fetch
description: Demonstrates how to access the `Server` object within the `fetch` handler using the second argument. This allows you to retrieve server-specific information, such as the client's IP address using `server.requestIP(req)`. This is useful for logging, analytics, or access control.
source: docs/api/http.md#_snippet_4

language: typescript
code:
```
// `server` is passed in as the second argument to `fetch`.
const server = Bun.serve({
  fetch(req, server) {
    const ip = server.requestIP(req);
    return new Response(`Your IP is ${ip}`);
  },
});
```

---

title: Handling Errors with the Error Callback
description: Demonstrates how to use the `error` callback in `Bun.serve` to handle server-side errors and return a custom `Response`. The provided example returns an HTML response containing the error message and stack trace. This allows for customizing the error response and overriding Bun's default error page.
source: docs/api/http.md#_snippet_10

language: typescript
code:
```
Bun.serve({
  fetch(req) {
    throw new Error("woops!");
  },
  error(error) {
    return new Response(`<pre>${error}\n${error.stack}</pre>`, {
      headers: {
        "Content-Type": "text/html",
      },
    });
  },
});
```

---

title: Configuring Server Name Indication (SNI)
description: Shows how to configure Server Name Indication (SNI) for the server in `Bun.serve`. This example sets the `serverName` field in the `tls` object. SNI allows a server to host multiple TLS certificates for different domain names on the same IP address and port.
source: docs/api/http.md#_snippet_16

language: typescript
code:
```
Bun.serve({
  // ...
  tls: {
    // ... other config
    serverName: "my-server.com", // SNI
  },
});
```

---

title: Allowing Multiple Server Names with SNI
description: Demonstrates how to configure `Bun.serve` to support multiple server names by passing an array of objects to the `tls` option, each with a `serverName` field. This enables the server to handle TLS connections for multiple domain names using different certificates.
source: docs/api/http.md#_snippet_17

language: typescript
code:
```
Bun.serve({
  // ...
  tls: [
    {
      key: Bun.file("./key1.pem"),
      cert: Bun.file("./cert1.pem"),
      serverName: "my-server1.com",
    },
    {
      key: Bun.file("./key2.pem"),
      cert: Bun.file("./cert2.pem"),
      serverName: "my-server2.com",
    },
  ],
});
```

---

title: Disposing of Resources with HMR-ts
description: Illustrates how to use `import.meta.hot.dispose` to execute a callback function when a module is about to be replaced during HMR. It explains that Bun will remove the function call in production builds, provided it's called without indirection.
source: docs/bundler/hmr.md#_snippet_1

language: ts
code:
```
// This entire function call will be removed in production!
import.meta.hot.dispose(() => {
  console.log("dispose");
});
```

---

title: Accepting Hot Updates-ts
description: Illustrates the basic usage of `import.meta.hot.accept()` without arguments to indicate that a module can be hot-replaced. It explains how this creates a hot-reloading boundary, causing re-evaluation of the file upon updates to its dependencies and patching importers of the module.
source: docs/bundler/hmr.md#_snippet_3

language: ts
code:
```
import { getCount } from "./foo.ts";

console.log("count is ", getCount());

import.meta.hot.accept();

export function getNegativeCount() {
  return -getCount();
}
```

---

title: Accepting Hot Updates With Callback-ts
description: Demonstrates using `import.meta.hot.accept` with a callback function. It explains how the callback is called with the new module and advises using the argument-less version where possible.
source: docs/bundler/hmr.md#_snippet_4

language: ts
code:
```
export const count = 0;

import.meta.hot.accept(newModule => {
  if (newModule) {
    // newModule is undefined when SyntaxError happened
    console.log("updated: count is now ", newModule.count);
  }
});
```

---

title: Accepting Updates From Other Modules-ts
description: Demonstrates how to accept updates from a specific dependency's module using `import.meta.hot.accept` with a module specifier.  It explains that the callback will be invoked with the new module when the dependency is updated.
source: docs/bundler/hmr.md#_snippet_5

language: ts
code:
```
import { count } from "./foo";

import.meta.hot.accept("./foo", () => {
  if (!newModule) return;

  console.log("updated: count is now ", count);
});
```

---

title: Accepting Updates From Multiple Dependencies-ts
description: Demonstrates accepting hot updates from multiple dependencies using an array of module specifiers with `import.meta.hot.accept`. It specifies that the callback will receive an array containing the updated modules or `undefined` if there was a syntax error in a module.
source: docs/bundler/hmr.md#_snippet_6

language: ts
code:
```
import.meta.hot.accept(["./foo", "./bar"], newModules => {
  // newModules is an array where each item corresponds to the updated module
  // or undefined if that module had a syntax error
});
```

---

title: Maintaining State With HMR Data-ts
description: Illustrates how to persist state between module instances during hot replacement using `import.meta.hot.data`. It shows how to initialize a root element and re-use it across updates.  It also mentions that in production `data` is inlined to be `{}` and explains the recommended pattern for stateful modules.
source: docs/bundler/hmr.md#_snippet_7

language: ts
code:
```
import { createRoot } from "react-dom/client";
import { App } from "./app";

const root = import.meta.hot.data.root ??= createRoot(elem);
root.render(<App />); // re-use an existing root
```

---

title: Cleaning up Resources With HMR Dispose-ts
description: Explains how to use `import.meta.hot.dispose` to attach a callback function that runs before a module is replaced or detached. It demonstrates a scenario where side effects are cleaned up using this callback.
source: docs/bundler/hmr.md#_snippet_8

language: ts
code:
```
const sideEffect = setupSideEffect();

import.meta.hot.dispose(() => {
  sideEffect.cleanup();
});
```

---

title: Cleaning up Resources With HMR Prune-ts
description: Illustrates how to use `import.meta.hot.prune` to clean up resources when all imports to a module are removed. It demonstrates managing a WebSocket connection, closing it only when the module is no longer imported.
source: docs/bundler/hmr.md#_snippet_9

language: ts
code:
```
import { something } from "./something";

// Initialize or re-use a WebSocket connection
export const ws = (import.meta.hot.data.ws ??= new WebSocket(location.origin));

// If the module's import is removed, clean up the WebSocket connection.
import.meta.hot.prune(() => {
  ws.close();
});
```

---

title: Listening for HMR Events-ts
description: Demonstrates how to listen for events from the HMR runtime using `import.meta.hot.on` and `import.meta.hot.off`.  It shows how to listen for the `bun:beforeUpdate` event.
source: docs/bundler/hmr.md#_snippet_10

language: ts
code:
```
import.meta.hot.on("bun:beforeUpdate", () => {
  console.log("before a hot update");
});
```

---

title: Using onStart for Bundle Initialization - Typescript
description: Demonstrates using the `onStart` hook in a Bun plugin to execute code when the bundler starts a new bundle.  The callback function logs a message to the console, indicating the start of the bundle process. This is useful for initialization tasks or logging.
source: docs/bundler/plugins.md#_snippet_2

language: ts
code:
```
import { plugin } from "bun";

plugin({
  name: "onStart example",

  setup(build) {
    build.onStart(() => {
      console.log("Bundle started!");
    });
  },
});
```

---

title: Redirecting Imports with onResolve - Typescript
description: Demonstrates how to use the `onResolve` hook to modify module resolution.  The example redirects all imports starting with `images/` to the `./public/images/` directory. This can be useful for managing asset paths or customizing module resolution logic.
source: docs/bundler/plugins.md#_snippet_4

language: ts
code:
```
import { plugin } from "bun";

plugin({
  name: "onResolve example",
  setup(build) {
    build.onResolve({ filter: /.*/, namespace: "file" }, args => {
      if (args.path.startsWith("images/")) {
        return {
          path: args.path.replace("images/", "./public/images/"),
        };
      }
    });
  },
});
```

---

title: Modifying Module Contents with onLoad - Typescript
description: Demonstrates how to use the `onLoad` hook to modify the contents of a module before it's parsed. The `envPlugin` transforms imports of `env` into a JavaScript module exporting the current environment variables. This is useful for injecting environment-specific data into the bundle.
source: docs/bundler/plugins.md#_snippet_5

language: ts
code:
```
import { plugin } from "bun";

const envPlugin: BunPlugin = {
  name: "env plugin",
  setup(build) {
    build.onLoad({ filter: /env/, namespace: "file" }, args => {
      return {
        contents: `export default ${JSON.stringify(process.env)}`,
        loader: "js",
      };
    });
  },
});

Bun.build({
  entrypoints: ["./app.ts"],
  outdir: "./dist",
  plugins: [envPlugin],
});

// import env from "env"
// env.FOO === "bar"
```

---

title: Stopping the Bun Server
description: Demonstrates how to stop a Bun server using the `server.stop()` method. It shows both gracefully stopping the server by allowing in-flight requests to complete and forcefully stopping the server by terminating all connections immediately.
source: docs/api/http.md#_snippet_4

language: typescript
code:
```
const server = Bun.serve({
  fetch(req) {
    return new Response("Hello!");
  },
});

// Gracefully stop the server (waits for in-flight requests)
await server.stop();

// Force stop and close all active connections
await server.stop(true);
```

---

title: Customizing Request Timeouts
description: Demonstrates setting a custom idle timeout for individual requests using `server.timeout(req, seconds)`. If the request takes longer than the specified time, it will be aborted.
source: docs/api/http.md#_snippet_7

language: typescript
code:
```
const server = Bun.serve({
  fetch(req, server) {
    // Set 60 second timeout for this request
    server.timeout(req, 60);

    // If they take longer than 60 seconds to send the body, the request will be aborted
    await req.text();

    return new Response("Done!");
  },
});
```

---

title: Reading Cookies from Requests
description: Demonstrates how to read cookies from incoming requests using the `cookies` property on the `BunRequest` object.  It accesses the `user_id` and `theme` cookies.
source: docs/api/http.md#_snippet_9

language: typescript
code:
```
Bun.serve({
  routes: {
    "/profile": req => {
      // Access cookies from the request
      const userId = req.cookies.get("user_id");
      const theme = req.cookies.get("theme") || "light";

      return Response.json({
        userId,
        theme,
        message: "Profile page",
      });
    },
  },
});
```

---

title: Setting Cookies in Responses
description: Illustrates setting cookies using the `set` method on the `CookieMap` from the `BunRequest` object. It shows setting `user_id` and `theme` cookies with various options like `maxAge`, `httpOnly`, and `secure`.
source: docs/api/http.md#_snippet_10

language: typescript
code:
```
Bun.serve({
  routes: {
    "/login": req => {
      const cookies = req.cookies;

      // Set a cookie with various options
      cookies.set("user_id", "12345", {
        maxAge: 60 * 60 * 24 * 7, // 1 week
        httpOnly: true,
        secure: true,
        path: "/",
      });

      // Add a theme preference cookie
      cookies.set("theme", "dark");

      // Modified cookies from the request are automatically applied to the response
      return new Response("Login successful");
    },
  },
});
```

---

title: Deleting Cookies from Server
description: Demonstrates deleting a cookie using the `delete` method on the `request.cookies` (`CookieMap`) object. Deleted cookies result in a `Set-Cookie` header with `maxAge` set to `0`.
source: docs/api/http.md#_snippet_11

language: typescript
code:
```
Bun.serve({
  routes: {
    "/logout": req => {
      // Delete the user_id cookie
      req.cookies.delete("user_id", {
        path: "/",
      });

      return new Response("Logged out successfully");
    },
  },
});
```

---

title: Getting WebSocket Subscriber Count
description: Illustrates how to get the number of subscribers for a WebSocket topic using `server.subscriberCount(topic)`. This is useful for tracking the number of connected users in a chat or other real-time application.
source: docs/api/http.md#_snippet_13

language: typescript
code:
```
const server = Bun.serve({
  fetch(req, server) {
    const chatUsers = server.subscriberCount("chat");
    return new Response(`${chatUsers} users in chat`);
  },
  websocket: {
    message(ws) {
      ws.subscribe("chat");
    },
  },
});
```

---

title: Publishing WebSocket Messages to Subscribers
description: Demonstrates how to publish messages to all WebSocket clients subscribed to a specific topic using `server.publish(topic, data, compress)`. The method returns the number of bytes sent, 0 if the message was dropped, or -1 if backpressure was applied.
source: docs/api/http.md#_snippet_14

language: typescript
code:
```
const server = Bun.serve({
  websocket: {
    message(ws) {
      // Publish to all "chat" subscribers
      server.publish("chat", "Hello everyone!");
    },
  },

  fetch(req) {
    // ...
  },
});
```

---

title: Defining Global Identifiers During Bun Build
description: Illustrates how to use the `define` option in `Bun.build` to replace global identifiers with JSON strings at build time. This is useful for injecting configuration values or feature flags into the code.
source: docs/bundler/index.md#_snippet_1

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  define: {
    STRING: JSON.stringify("value"),
    "nested.boolean": "true",
  },
})
```

language: CLI
code:
```
$ bun build ./index.tsx --outdir ./out --define 'STRING="value"' --define "nested.boolean=true"
```

---

title: Customizing File Loading with Bun Build
description: Demonstrates how to use the `loader` option in `Bun.build` to customize how certain files are loaded based on their extensions. This is useful for handling different types of assets like images or text files.
source: docs/bundler/index.md#_snippet_2

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  loader: {
    ".png": "dataurl",
    ".txt": "file",
  },
})
```

language: CLI
code:
```
$ bun build ./index.tsx --outdir ./out --loader .png:dataurl --loader .txt:file
```

---

title: Running Bun with ASAN
description: Demonstrates how to configure ASAN behavior using environment variables when running an ASAN build of Bun. It shows how to disable leak detection (recommended) and how to enable it (which may produce a lot of noise).
source: docs/project/asan.md#_snippet_1

language: bash
code:
```
# Basic ASAN options - leak detection disabled (recommended)
ASAN_OPTIONS=detect_leaks=0:halt_on_error=0:detect_odr_violation=0 ./build/bun-asan

# If you really need leak detection (will produce A LOT of noise)
# ASAN_OPTIONS=detect_leaks=1:leak_check_at_exit=1:halt_on_error=0 ./build/bun-asan
# LSAN_OPTIONS=suppressions=lsan.supp:print_suppressions=1 ./build/bun-asan
```

---

title: Disabling Code Splitting
description: Illustrates how to disable code splitting using both the JavaScript API and the CLI.  Setting `splitting` to `false` (or omitting it, as it's the default) will bundle all code into a single output file per entrypoint.
source: docs/bundler/index.md#_snippet_2

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  splitting: false, // default
})
```

language: CLI
code:
```
$ bun build ./index.tsx --outdir ./out --splitting
```

---

title: Defining Shared Modules
description: Illustrates the definition of shared modules used when code-splitting is enabled. These modules are imported by multiple entry points and will be extracted into a shared chunk during the build process when `splitting` is set to `true`.
source: docs/bundler/index.md#_snippet_3

language: typescript
code:
```
import { shared } from './shared.ts';
```

language: typescript
code:
```
import { shared } from './shared.ts';
```

language: typescript
code:
```
export const shared = 'shared';
```

---

title: Generating Linked Sourcemaps
description: Demonstrates how to generate linked sourcemaps using both the JavaScript API and the CLI. Setting `sourcemap` to `'linked'` creates separate `.map` files that link to the generated code, aiding in debugging.
source: docs/bundler/index.md#_snippet_9

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  sourcemap: 'linked', // default 'none'
})
```

language: CLI
code:
```
$ bun build ./index.tsx --outdir ./out --sourcemap=linked
```

---

title: Generating and Writing Heap Snapshots - TypeScript
description: Illustrates how to create a heap snapshot using the `generateHeapSnapshot` function from the `bun` module. The snapshot is then written to a `heap.json` file, which can be analyzed using Safari's Developer Tools to identify memory leaks and optimize memory usage.
source: docs/project/benchmarking.md#_snippet_1

language: typescript
code:
```
import { generateHeapSnapshot } from "bun";

const snapshot = generateHeapSnapshot();
await Bun.write("heap.json", JSON.stringify(snapshot, null, 2));
```

---

title: Triggering Garbage Collection
description: Demonstrates how to manually trigger garbage collection in Bun using the `Bun.gc()` function. The function can be called synchronously (`Bun.gc(true)`) or asynchronously (`Bun.gc(false)`), allowing you to control when memory is reclaimed by the garbage collector.
source: docs/project/benchmarking.md#_snippet_2

language: javascript
code:
```
Bun.gc(true); // synchronous
Bun.gc(false); // asynchronous
```

---

title: Specifying External Modules in Bun Build
description: Demonstrates how to mark modules as external during the bundling process with `Bun.build`, using both the JavaScript API and the command-line interface. This prevents specified modules from being included in the final bundle, leaving the `import` statements intact for runtime resolution.
source: docs/bundler/index.md#_snippet_2

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  external: ["lodash", "react"], // default: []
})
```

language: bash
code:
```
$ bun build ./index.tsx --outdir ./out --external lodash --external react
```

---

title: Marking All Imports as External in Bun Build
description: Demonstrates how to mark all imports as external using the wildcard `*` with `Bun.build`.  This prevents any packages from being included in the final bundle.
source: docs/bundler/index.md#_snippet_4

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  external: ['*'],
})
```

language: bash
code:
```
$ bun build ./index.tsx --outdir ./out --external '*'
```

---

title: Controlling Package Dependencies with Bun Build
description: Demonstrates how to use the `packages` option in `Bun.build` to control whether package dependencies are bundled or treated as external. Setting `packages` to `'external'` treats all imports that don't start with `.`, `..`, or `/` as external packages.
source: docs/bundler/index.md#_snippet_5

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.ts'],
  packages: 'external',
})
```

language: bash
code:
```
$ bun build ./index.ts --packages external
```

---

title: Customizing Generated Filenames with Bun Build
description: Demonstrates how to customize the generated file names for bundles using the `naming` option in `Bun.build`. The example shows the default naming pattern and how to use tokens like `[dir]`, `[name]`, and `[ext]` to structure the output files.
source: docs/bundler/index.md#_snippet_6

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  naming: "[dir]/[name].[ext]", // default
})
```

language: bash
code:
```
$ bun build ./index.tsx --outdir ./out --entry-naming [dir]/[name].[ext]
```

---

title: Including Hash in Bundle Names with Bun Build
description: Illustrates how to include a hash of the bundle contents in the generated file names using the `[hash]` token in the `naming` option of `Bun.build`. This helps prevent naming collisions and allows for cache busting.
source: docs/bundler/index.md#_snippet_7

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  naming: 'files/[dir]/[name]-[hash].[ext]',
})
```

language: bash
code:
```
$ bun build ./index.tsx --outdir ./out --entry-naming [name]-[hash].[ext]
```

---

title: Cross-Compiling with Bun
description: Illustrates the use of the `--target` flag with `bun build` to cross-compile standalone executables for different operating systems and architectures. This is useful for deploying applications to various environments without requiring Bun to be installed on the target system.
source: docs/bundler/executables.md#_snippet_1

language: sh
code:
```
bun build --compile --target=bun-linux-x64 ./index.ts --outfile myapp
```

language: sh
code:
```
bun build --compile --target=bun-linux-arm64 ./index.ts --outfile myapp
```

language: sh
code:
```
bun build --compile --target=bun-windows-x64 ./path/to/my/app.ts --outfile myapp
```

---

title: Defining Build-Time Constants with Bun
description: Shows how to use the `--define` flag to inject build-time constants into the compiled executable.  This allows embedding version numbers, timestamps, and configuration values directly into the binary, improving performance by enabling dead code elimination.
source: docs/bundler/executables.md#_snippet_2

language: bash
code:
```
$ bun build --compile --define BUILD_VERSION='"1.2.3"' --define BUILD_TIME='"2024-01-15T10:30:00Z"' src/cli.ts --outfile mycli
```

---

title: Consuming Bun Types in Ambient Declarations
description: Demonstrates how to consume types defined within the `bun` module inside ambient declarations.  It shows that `type A = import("bun").MyType;` and `type A = Bun.MyType;` are equivalent ways to reference the `MyType` type.
source: packages/bun-types/authoring.md#_snippet_3

language: typescript
code:
```
// These are equivalent
type A = import("bun").MyType;
type A = Bun.MyType;
```

---

title: Importing Packages with Macro Export Conditions
description: Demonstrates how to import a package that defines the macro condition. The first import resolves to the runtime code, while the second import, using `with { type: 'macro' }`, resolves to the macro-specific code for bundle-time execution.
source: docs/bundler/macros.md#_snippet_3

language: typescript
code:
```
import pkg from "my-package"; // runtime import
import { macro } from "my-package" with { type: "macro" }; // macro import
```

---

title: Creating Dead Code Elimination Macros
description: Illustrates how macros can be used to perform dead code elimination during bundling. The `returnFalse` macro returns `false`, causing the `if` block to be eliminated from the final bundle when the minify syntax option is enabled.
source: docs/bundler/macros.md#_snippet_4

language: typescript
code:
```
export function returnFalse() {
  return false;
}
```

language: typescript
code:
```
import { returnFalse } from "./returnFalse.ts" with { type: "macro" };

if (returnFalse()) {
  console.log("This code is eliminated");
}
```

---

title: Building Bun Handler Artifacts
description: Explains how to build the Bun handler using the Bun toolkit.  It uses `bun build` to bundle the handler into a single file. This artifact is then zipped for deployment to AWS Lambda.
source: packages/bun-lambda/README.md#_snippet_3

language: sh
code:
```
bun build <handler-entry>.[ts|js] --outfile ./dist/handler.js
```

---

title: Adapting Layouts with CSS Logical Properties
description: Illustrates the use of CSS logical properties for defining layout, spacing, and sizing relative to the document's writing mode and text direction. It shows how Bun's CSS bundler compiles these logical properties to physical properties with appropriate directional adjustments for older browsers, enabling international layouts that automatically adapt to different writing systems.
source: docs/bundler/css.md#_snippet_1

language: css
code:
```
.multilingual-component {
  /* Margin that adapts to writing direction */
  margin-inline-start: 1rem;

  /* Padding that makes sense regardless of text direction */
  padding-block: 1rem 2rem;

  /* Border radius for the starting corner at the top */
  border-start-start-radius: 4px;

  /* Size that respects the writing mode */
  inline-size: 80%;
  block-size: auto;
}
```

language: css
code:
```
/* For left-to-right languages */
.multilingual-component:dir(ltr) {
  margin-left: 1rem;
  padding-top: 1rem;
  padding-bottom: 2rem;
  border-top-left-radius: 4px;
  width: 80%;
  height: auto;
}

/* For right-to-left languages */
.multilingual-component:dir(rtl) {
  margin-right: 1rem;
  padding-top: 1rem;
  padding-bottom: 2rem;
  border-top-right-radius: 4px;
  width: 80%;
  height: auto;
}
```

---

title: Styling Based on Text Direction with :dir() Selector
description: Demonstrates how to use the `:dir()` pseudo-class selector to style elements based on their text direction (RTL or LTR). It explains how Bun's CSS bundler converts the `:dir()` selector to the more widely supported `:lang()` selector with appropriate language mappings for browsers that don't support it natively, ensuring direction-aware CSS works reliably across browsers.
source: docs/bundler/css.md#_snippet_2

language: css
code:
```
/* Apply different styles based on text direction */
.nav-arrow:dir(ltr) {
  transform: rotate(0deg);
}

.nav-arrow:dir(rtl) {
  transform: rotate(180deg);
}

/* Position elements based on text flow */
.sidebar:dir(ltr) {
  border-right: 1px solid #ddd;
}

.sidebar:dir(rtl) {
  border-left: 1px solid #ddd;
}
```

language: css
code:
```
/* Converted to use language-based selectors as fallback */
.nav-arrow:lang(en, fr, de, es, it, pt, nl) {
  transform: rotate(0deg);
}

.nav-arrow:lang(ar, he, fa, ur) {
  transform: rotate(180deg);
}

.sidebar:lang(en, fr, de, es, it, pt, nl) {
  border-right: 1px solid #ddd;
}

.sidebar:lang(ar, he, fa, ur) {
  border-left: 1px solid #ddd;
}
```

---

title: Applying Language-Specific Styling with :lang() Selector
description: Illustrates the use of the `:lang()` pseudo-class selector to target elements based on the language they're in. It shows how Bun's CSS bundler converts the modern CSS that allows the `:lang()` selector to accept multiple language codes, converting this syntax to use the `:is()` selector to maintain the same behavior for better browser support.
source: docs/bundler/css.md#_snippet_3

language: css
code:
```
/* Typography adjustments for CJK languages */
:lang(zh, ja, ko) {
  line-height: 1.8;
  font-size: 1.05em;
}

/* Different quote styles by language group */
blockquote:lang(fr, it, es, pt) {
  font-style: italic;
}

blockquote:lang(de, nl, da, sv) {
  font-weight: 500;
}
```

language: css
code:
```
/* Multiple languages grouped with :is() for better browser support */
:is(:lang(zh), :lang(ja), :lang(ko)) {
  line-height: 1.8;
  font-size: 1.05em;
}

blockquote:is(:lang(fr), :lang(it), :lang(es), :lang(pt)) {
  font-style: italic;
}

blockquote:is(:lang(de), :lang(nl), :lang(da), :lang(sv)) {
  font-weight: 500;
}
```

---

title: Grouping Selectors with :is() Selector
description: Demonstrates how to use the `:is()` pseudo-class function to create more concise and readable selectors by grouping multiple selectors together. It explains how Bun's CSS bundler provides fallbacks using vendor-prefixed alternatives for browsers that don't support `:is()`, ensuring styles are applied correctly across different browsers.
source: docs/bundler/css.md#_snippet_4

language: css
code:
```
/* Instead of writing these separately */
/*
.article h1,
.article h2,
.article h3 {
  margin-top: 1.5em;
}
*/

/* You can write this */
.article :is(h1, h2, h3) {
  margin-top: 1.5em;
}

/* Complex example with multiple groups */
:is(header, main, footer) :is(h1, h2, .title) {
  font-family: "Heading Font", sans-serif;
}
```

language: css
code:
```
/* Fallback using -webkit-any */
.article :-webkit-any(h1, h2, h3) {
  margin-top: 1.5em;
}

/* Fallback using -moz-any */
.article :-moz-any(h1, h2, h3) {
  margin-top: 1.5em;
}

/* Original preserved for modern browsers */
.article :is(h1, h2, h3) {
  margin-top: 1.5em;
}

/* Complex example with fallbacks */
:-webkit-any(header, main, footer) :-webkit-any(h1, h2, .title) {
  font-family: "Heading Font", sans-serif;
}

:-moz-any(header, main, footer) :-moz-any(h1, h2, .title) {
  font-family: "Heading Font", sans-serif;
}

:is(header, main, footer) :is(h1, h2, .title) {
  font-family: "Heading Font", sans-serif;
}
```

---

title: Excluding Elements with :not() Selector
description: Explains how to use the `:not()` pseudo-class to exclude elements that match a specific selector. It showcases how Bun's CSS bundler converts the modern version of this selector that accepts multiple arguments to a more compatible form while preserving the same behavior, and can generate further fallbacks if `:is()` isn't supported.
source: docs/bundler/css.md#_snippet_5

language: css
code:
```
/* Select all buttons except primary and secondary variants */
button:not(.primary, .secondary) {
  background-color: #f5f5f5;
  border: 1px solid #ddd;
}

/* Apply styles to all headings except those inside sidebars or footers */
h2:not(.sidebar *, footer *) {
  margin-top: 2em;
}
```

language: css
code:
```
/* Converted to use :not with :is() for compatibility */
button:not(:is(.primary, .secondary)) {
  background-color: #f5f5f5;
  border: 1px solid #ddd;
}

h2:not(:is(.sidebar *, footer *)) {
  margin-top: 2em;
}
```

language: css
code:
```
/* Even more fallbacks for maximum compatibility */
button:not(:-webkit-any(.primary, .secondary)) {
  background-color: #f5f5f5;
  border: 1px solid #ddd;
}

button:not(:-moz-any(.primary, .secondary)) {
  background-color: #f5f5f5;
  border: 1px solid #ddd;
}

button:not(:is(.primary, .secondary)) {
  background-color: #f5f5f5;
  border: 1px solid #ddd;
}
```

---

title: Optimizing Calculations with CSS Math Functions
description: Demonstrates the use of CSS math functions to perform complex calculations directly in stylesheets. It shows how Bun's CSS bundler evaluates these mathematical expressions at build time when all values are known constants, resulting in optimized output by pre-calculating values.
source: docs/bundler/css.md#_snippet_6

language: css
code:
```
.dynamic-sizing {
  /* Clamp a value between minimum and maximum */
  width: clamp(200px, 50%, 800px);

  /* Round to the nearest multiple */
  padding: round(14.8px, 5px);

  /* Trigonometry for animations or layouts */
  transform: rotate(calc(sin(45deg) * 50deg));

  /* Complex math with multiple functions */
  --scale-factor: pow(1.25, 3);
  font-size: calc(16px * var(--scale-factor));
}
```

language: css
code:
```
.dynamic-sizing {
  width: clamp(200px, 50%, 800px);
  padding: 15px;
  transform: rotate(35.36deg);
  --scale-factor: 1.953125;
  font-size: calc(16px * var(--scale-factor));
}
```

---

title: Configuring Debugging with Launch JSON
description: Demonstrates how to configure debugging for JavaScript and TypeScript files using Bun within Visual Studio Code. The `launch.json` file defines configurations for launching and attaching to a Bun process, allowing developers to debug code effectively.
source: packages/bun-vscode/README.md#_snippet_0

language: jsonc
code:
```
{
  "version": "0.2.0",
  "configurations": [
    {
      "type": "bun",
      "request": "launch",
      "name": "Debug Bun",

      // The path to a JavaScript or TypeScript file to run.
      "program": "${file}",

      // The arguments to pass to the program, if any.
      "args": [],

      // The working directory of the program.
      "cwd": "${workspaceFolder}",

      // The environment variables to pass to the program.
      "env": {},

      // If the environment variables should not be inherited from the parent process.
      "strictEnv": false,

      // If the program should be run in watch mode.
      // This is equivalent to passing `--watch` to the `bun` executable.
      // You can also set this to "hot" to enable hot reloading using `--hot`.
      "watchMode": false,

      // If the debugger should stop on the first line of the program.
      "stopOnEntry": false,

      // If the debugger should be disabled. (for example, breakpoints will not be hit)
      "noDebug": false,

      // The path to the `bun` executable, defaults to your `PATH` environment variable.
      "runtime": "bun",

      // The arguments to pass to the `bun` executable, if any.
      // Unlike `args`, these are passed to the executable itself, not the program.
      "runtimeArgs": [],
    },
    {
      "type": "bun",
      "request": "attach",
      "name": "Attach to Bun",

      // The URL of the WebSocket inspector to attach to.
      // This value can be retrieved by using `bun --inspect`.
      "url": "ws://localhost:6499/",
      // Optional path mapping for remote debugging
      "localRoot": "${workspaceFolder}",
      "remoteRoot": "/app",
    },
  ]
}
```

---

title: Accessing SQLite with Bun Build
description: Demonstrates how to import and use an SQLite database with `bun build --compile`. It illustrates how the database is resolved relative to the current working directory of the process.
source: docs/bundler/executables.md#_snippet_1

language: javascript
code:
```
import db from "./my.db" with { type: "sqlite" };

console.log(db.query("select * from users LIMIT 1").get());
```

---

title: Embedding Files for Standalone Executables
description: Illustrates how to embed files into a standalone executable using `bun build --compile`. It shows how to import a file with the `type: "file"` attribute and stream it using `Bun.file` within a `Response` object.
source: docs/bundler/executables.md#_snippet_2

language: typescript
code:
```
// this becomes an internal file path
import icon from "./icon.png" with { type: "file" };
import { file } from "bun";

export default {
  fetch(req) {
    // Embedded files can be streamed from Response objects
    return new Response(file(icon));
  },
};
```

---

title: Reading Embedded Files in Bun
description: Demonstrates how to read the contents of an embedded file using `Bun.file`. It shows how to import a file with the `type: "file"` attribute and then read its contents into an `ArrayBuffer`.
source: docs/bundler/executables.md#_snippet_3

language: javascript
code:
```
import icon from "./icon.png" with { type: "file" };
import { file } from "bun";

const bytes = await file(icon).arrayBuffer();
// await fs.promises.readFile(icon)
// fs.readFileSync(icon)
```

---

title: Embedding SQLite Databases with Bun
description: Shows how to embed a SQLite database into a Bun executable. The `embed: "true"` attribute makes it read-write, but changes are lost upon exit.
source: docs/bundler/executables.md#_snippet_4

language: javascript
code:
```
import myEmbeddedDb from "./my.db" with { type: "sqlite", embed: "true" };

console.log(myEmbeddedDb.query("select * from users LIMIT 1").get());
```

---

title: Embedding N-API Addons in Bun
description: Demonstrates how to embed N-API addons (``.node`` files) into executables using `bun build --compile`. It requires directly referencing the `.node` file in your code.
source: docs/bundler/executables.md#_snippet_5

language: javascript
code:
```
const addon = require("./addon.node");

console.log(addon.hello());
```

---

title: Listing Embedded Files in Bun
description: Demonstrates how to list all embedded files using `Bun.embeddedFiles`.  It imports a file with `type: "file"` and then logs the name of the embedded file.
source: docs/bundler/executables.md#_snippet_7

language: javascript
code:
```
import "./icon.png" with { type: "file" };
import { embeddedFiles } from "bun";

console.log(embeddedFiles[0].name); // `icon-${hash}.png`
```

---

title: Canceling Listening on a Port
description: Illustrates how to cancel listening on a port using the `us_listen_socket_close` function. This function allows you to stop accepting new connections on the specified socket.
source: packages/bun-uws/misc/READMORE.md#_snippet_1

language: c++
code:
```
us_listen_socket_close
```

---

title: Enabling Console Echo During Development
description: Demonstrates how to enable console log echoing from the browser to the terminal when using `Bun.serve()`. It illustrates the configuration needed within the `development` object to enable both hot module reloading and console echoing.
source: docs/bundler/fullstack.md#_snippet_6

language: typescript
code:
```
import homepage from "./index.html";

Bun.serve({
  // development can also be an object.
  development: {
    // Enable Hot Module Reloading
    hmr: true,

    // Echo console logs from the browser to the terminal
    console: true,
  },

  routes: {
    "/": homepage,
  },
});
```

---

title: Configuring Tailwind CSS with Bun Plugins
description: Demonstrates how to configure Tailwind CSS in Bun using bundler plugins. It explains how to install the `bun-plugin-tailwind` plugin and configure it in the `bunfig.toml` file.
source: docs/bundler/fullstack.md#_snippet_8

language: sh
code:
```
$ bun add bun-plugin-tailwind
```

language: toml
code:
```
[serve.static]
plugins = ["bun-plugin-tailwind"]
```

language: html
code:
```
<!doctype html>
<html>
  <head>
    <title>Home</title>
    <link rel="stylesheet" href="tailwindcss" />
  </head>
  <body>
    <!-- the rest of your HTML... -->
  </body>
</html>
```

---

title: Importing Tailwind CSS in CSS
description: Shows how to import Tailwind CSS directly within CSS files when using the `bun-plugin-tailwind` plugin. This allows developers to use Tailwind's utility classes directly in their CSS stylesheets.
source: docs/bundler/fullstack.md#_snippet_9

language: css
code:
```
@import "tailwindcss";
```

---

title: Setting up Bun Internal Tests - PowerShell
description: Demonstrates setting up the Bun internal test suite by installing dependencies. This is required before running the tests.
source: docs/project/building-windows.md#_snippet_9

language: ps1
code:
```
# Setup
> bun i --cwd packages\bun-internal-test
```

---

title: Running Test Suite - PowerShell
description: Illustrates how to run the entire test suite with a reporter and also how to run an individual test file.  The `bun run test` command executes all tests defined in the `package.json` script, and the `bun-debug test` command allows running specific test files.
source: docs/project/building-windows.md#_snippet_10

language: ps1
code:
```
# Run the entire test suite with reporter
# the package.json script "test" uses "build/debug/bun-debug.exe" by default
> bun run test

# Run an individual test file:
> bun-debug test node\fs
> bun-debug test "C:\bun\test\js\bun\resolve\import-meta.test.js"
```

---

title: Benchmarking with Oha
description: Explains how to benchmark the server using `oha`. The command sends 500,000 requests to `http://localhost:3000` with the `Accept-Encoding: identity` header to prevent response compression.
source: bench/express/README.md#_snippet_4

language: bash
code:
```
oha http://localhost:3000 -n 500000 -H "Accept-Encoding: identity"
```

---

title: Using JS Bindgen Functions
description: Demonstrates how to access the native implementation of the `add` function through `bun.gen.math.jsAdd` provided by the code generator. Also shows how to create a JavaScript callback using `bun.gen.math.createAddCallback(global)` to expose the native function to JavaScript.  `$bindgenFn` retrieves a handle to the implementation.
source: docs/project/bindgen.md#_snippet_2

language: typescript
code:
```
/**
 * Throws if zero arguments are provided.
 * Wraps out of range numbers using modulo.
 */
declare function add(a: number, b: number = 1): number;
```

---

title: Defining Function Variants with Bindgen - Typescript
description: Demonstrates how to define function variants (overloads) using the `variants` property in the `bindgen` library. Each variant specifies a different set of arguments and return types for the same function name, enabling polymorphism.
source: docs/project/bindgen.md#_snippet_3

language: typescript
code:
```
import { t, fn } from 'bindgen';

export const action = fn({
  variants: [
    {
      args: {
        a: t.i32,
      },
      ret: t.i32,
    },
    {
      args: {
        a: t.DOMString,
      },
      ret: t.DOMString,
    },
  ]
});
```

---

title: Implementing Function Variants in Zig
description: Illustrates how each variant defined in the `.bind.ts` file maps to a separate function in Zig, named with a number suffix based on the order defined in the schema.  The example shows two variants of `action`: one accepting an `i32`, the other accepting a `bun.String`.
source: docs/project/bindgen.md#_snippet_4

language: zig
code:
```
fn action1(a: i32) i32 {
  return a;
}

fn action2(a: bun.String) bun.String {
  return a;
}
```

---

title: Defining String Enum with Bindgen - Typescript
description: Demonstrates creating a new string enum type using `t.stringEnum`. This example defines a `Formatter` enum with two possible values, and uses it as the type of the `formatter` argument in the `fmtString` function.
source: docs/project/bindgen.md#_snippet_5

language: typescript
code:
```
export const Formatter = t.stringEnum(
  "highlight-javascript",
  "escape-powershell",
);

export const fmtString = fn({
  args: {
    global: t.globalObject,
    code: t.UTF8String,
    formatter: Formatter,
  },
  ret: t.DOMString,
});
```

---

title: Connecting via Socket (for Local Debugging) - Bun Inspector
description: Illustrates how to connect to the Bun inspector via a Unix or TCP socket using the `NodeSocketInspector` class. It establishes a socket connection, creates an inspector client, sets up event listeners, and starts the inspector.  The `import` statements are coupled with the usage of the imported modules.
source: packages/bun-inspector-protocol/README.md#_snippet_3

language: typescript
code:
```
import { NodeSocketInspector } from "bun-inspector-protocol";
import { Socket } from
```

language: typescript
code:
```
// Create a socket connection
const socket = new Socket();
socket.connect("/path/to/debug/socket");

// Create a new inspector client
const inspector = new NodeSocketInspector(socket);

// Set up event listeners and use the API as with WebSocketInspector
inspector.on("Inspector.connected", () => {
  console.log("Connected to debugger via socket!");
});

await inspector.start();
// Use the same API as WebSocketInspector from here...
```

---

title: Handling Events - Bun Inspector
description: Demonstrates how to listen for specific events emitted by the inspector, such as `Debugger.scriptParsed`, `Debugger.paused`, and `Runtime.consoleAPICalled`.  It shows how to access the event parameters and format remote objects using `remoteObjectToString`.
source: packages/bun-inspector-protocol/README.md#_snippet_4

language: typescript
code:
```
// Listen for specific protocol events
inspector.on("Debugger.scriptParsed", params => {
  console.log("Script parsed:", params.url);
});

// Listen for breakpoint hits
inspector.on("Debugger.paused", params => {
  console.log("Execution paused at:", params.callFrames[0].location);
});

// Listen for console messages
inspector.on("Runtime.consoleAPICalled", params => {
  console.log(
    "Console message:",
    params.args
      .map(arg =>
        // Use the included utility to format objects
        remoteObjectToString(arg, true),
      )
      .join(" "),
  );
});
```

---

title: Converting Remote Objects To String - Bun Inspector
description: Illustrates how to convert remote object references received from expression evaluation into string representations using the `remoteObjectToString` utility.  The `import` statement is coupled with the usage of the imported module.
source: packages/bun-inspector-protocol/README.md#_snippet_5

language: typescript
code:
```
import { remoteObjectToString } from "bun-inspector-protocol";

const result = await inspector.send("Runtime.evaluate", {
  expression: "{ a: 1, b: { c: 'hello' } }",
});

console.log(remoteObjectToString(result.result, true));
// Output: {a: 1, b: {c: "hello"}}
```

---

title: Setting Breakpoints - Bun Inspector
description: Demonstrates how to set, customize, and remove breakpoints using the Debugger domain of the Bun inspector protocol. It includes examples for setting breakpoints by URL, adding custom actions, and removing breakpoints.
source: packages/bun-inspector-protocol/README.md#_snippet_6

language: typescript
code:
```
// Set a breakpoint by URL
const { breakpointId } = await inspector.send("Debugger.setBreakpointByUrl", {
  lineNumber: 42,
  url: "/app/foo.ts",
  condition: "x > 5", // Optional condition
});

// Set a breakpoint with custom actions
await inspector.send("Debugger.setBreakpoint", {
  location: { scriptId: "123", lineNumber: 10 },
  options: {
    condition: "count > 5",
    actions: [
      { type: "log", data: "Breakpoint hit!" },
      { type: "evaluate", data: "console.log('Custom breakpoint action')" },
    ],
    autoContinue: true,
  },
});

// Remove a breakpoint
await inspector.send("Debugger.removeBreakpoint", { breakpointId });
```

---

title: Running and Waking Up the Event Loop
description: Illustrates how to run the event loop using `us_loop_run`, which blocks the calling thread until all non-fallthrough polls are complete. Also demonstrates `us_wakeup_loop`, a thread-safe function to signal the loop to wake up and execute its wakeup handler, enabling inter-thread communication.
source: packages/bun-usockets/misc/manual.md#_snippet_1

language: c
code:
```
/* Blocks the calling thread and drives the event loop until no more non-fallthrough polls are scheduled */
WIN32_EXPORT void us_loop_run(struct us_loop_t *loop);

/* Signals the loop from any thread to wake up and execute its wakeup handler from the loop's own running thread.
 * This is the only fully thread-safe function and serves as the basis for thread safety */
WIN32_EXPORT void us_wakeup_loop(struct us_loop_t *loop);
```

---

title: Setting Socket Context Callbacks
description: Illustrates how to set various asynchronous callbacks for a socket context, including `on_open`, `on_close`, `on_data`, `on_writable`, `on_timeout`, and `on_end`. These callbacks define the behavior of the socket context in response to different events.
source: packages/bun-usockets/misc/manual.md#_snippet_3

language: c
code:
```
/* Setters of various async callbacks */
WIN32_EXPORT void us_socket_context_on_open(int ssl, struct us_socket_context_t *context, struct us_socket_t *(*on_open)(struct us_socket_t *s, int is_client, char *ip, int ip_length));
WIN32_EXPORT void us_socket_context_on_close(int ssl, struct us_socket_context_t *context, struct us_socket_t *(*on_close)(struct us_socket_t *s));
WIN32_EXPORT void us_socket_context_on_data(int ssl, struct us_socket_context_t *context, struct us_socket_t *(*on_data)(struct us_socket_t *s, char *data, int length));
WIN32_EXPORT void us_socket_context_on_writable(int ssl, struct us_socket_context_t *context, struct us_socket_t *(*on_writable)(struct us_socket_t *s));
WIN32_EXPORT void us_socket_context_on_timeout(int ssl, struct us_socket_context_t *context, struct us_socket_t *(*on_timeout)(struct us_socket_t *s));

/* Emitted when a socket has been half-closed */
WIN32_EXPORT void us_socket_context_on_end(int ssl, struct us_socket_context_t *context, struct us_socket_t *(*on_end)(struct us_socket_t *s));
```

---

title: Listening for Connections and Connecting to a Host
description: Demonstrates how to listen for incoming connections using `us_socket_context_listen`, which acts as a server, and how to connect to a remote host using `us_socket_context_connect`, acting as a client.  These functions initialize the network communication and will trigger the previously defined async callbacks.
source: packages/bun-usockets/misc/manual.md#_snippet_4

language: c
code:
```
/* Listen for connections. Acts as the main driving cog in a server. Will call set async callbacks. */
WIN32_EXPORT struct us_listen_socket_t *us_socket_context_listen(int ssl, struct us_socket_context_t *context, const char *host, int port, int options, int socket_ext_size);

/* Land in on_open or on_close or return null or return socket */
WIN32_EXPORT struct us_socket_t *us_socket_context_connect(int ssl, struct us_socket_context_t *context, const char *host, int port, int options, int socket_ext_size);
```

---

title: Writing Data to a Socket
description: Illustrates how to write data to a socket using `us_socket_write`. The function attempts to write `length` bytes from `data` and returns the actual number of bytes written, triggering the `on_writable` callback if not all data could be written immediately.
source: packages/bun-usockets/misc/manual.md#_snippet_5

language: c
code:
```
/* Write up to length bytes of data. Returns actual bytes written. Will call the on_writable callback of active socket context on failure to write everything off in one go.
WIN32_EXPORT int us_socket_write(int ssl, struct us_socket_t *s, const char *data, int length);
```

---

title: Setting a Socket Timeout
description: Demonstrates how to set a timeout on a socket using `us_socket_timeout`. This function configures a low-precision, high-performance timer that will trigger the `on_timeout` callback if the socket remains idle for the specified number of seconds.
source: packages/bun-usockets/misc/manual.md#_snippet_6

language: c
code:
```
/* Set a low precision, high performance timer on a socket. A socket can only have one single active timer at any given point in time. Will remove any such pre set timer */
WIN32_EXPORT void us_socket_timeout(int ssl, struct us_socket_t *s, unsigned int seconds);
```

---

title: Creating and Arming a Timer
description: Demonstrates the creation of a new timer using `us_create_timer` within a given loop, and how to set its callback and interval using `us_timer_set`. The timer can be configured for single execution or repeated execution based on the `repeat_ms` value.
source: packages/bun-usockets/misc/manual.md#_snippet_7

language: c
code:
```
/* Create a new high precision, low performance timer. May fail and return null */
WIN32_EXPORT struct us_timer_t *us_create_timer(struct us_loop_t *loop, int fallthrough, unsigned int ext_size);

/* Arm a timer with a delay from now and eventually a repeat delay.
 * Specify 0 as repeat delay to disable repeating. Specify both 0 to disarm. */
WIN32_EXPORT void us_timer_set(struct us_timer_t *timer, void (*cb)(struct us_timer_t *t), int ms, int repeat_ms);
```

---

title: Creating and Initializing a Poll
description: Shows how to create a poll using `us_create_poll`, a fundamental component for eventing, and associate it with a socket descriptor and poll type using `us_poll_init`. The poll can be configured to either keep the loop alive (non-fallthrough) or allow it to fall through when idle.
source: packages/bun-usockets/misc/manual.md#_snippet_8

language: c
code:
```
/* A fallthrough poll does not keep the loop running, it falls through */
WIN32_EXPORT struct us_poll_t *us_create_poll(struct us_loop_t *loop, int fallthrough, unsigned int ext_size);

/* Associate this poll with a socket descriptor and poll type */
WIN32_EXPORT void us_poll_init(struct us_poll_t *p, LIBUS_SOCKET_DESCRIPTOR fd, int poll_type);
```

---

title: Starting and Stopping a Poll
description: Demonstrates how to start, change, and stop polling for events using `us_poll_start`, `us_poll_change`, and `us_poll_stop`, respectively.  These functions allow for dynamic control over which events the application is interested in, enabling efficient resource utilization.
source: packages/bun-usockets/misc/manual.md#_snippet_9

language: c
code:
```
/* Start, change and stop polling for events */
WIN32_EXPORT void us_poll_start(struct us_poll_t *p, struct us_loop_t *loop, int events);
WIN32_EXPORT void us_poll_change(struct us_poll_t *p, struct us_loop_t *loop, int events);
WIN32_EXPORT void us_poll_stop(struct us_poll_t *p, struct us_loop_t *loop);
```

---

title: Importing Common Utilities from Harness - TypeScript
description: Lists common imports from the `harness` module, providing access to utilities like `bunExe`, `bunEnv`, `tempDirWithFiles`, and platform checks.  These are crucial for writing effective and portable Bun tests.
source: test/AGENTS.md#_snippet_4

language: typescript
code:
```
import {
  bunExe, // Path to Bun executable
  bunEnv, // Environment variables for Bun
  tempDirWithFiles, // Create temporary test directories with files
  tmpdirSync, // Create empty temporary directory
  isMacOS, // Platform checks
  isWindows,
  isPosix,
  gcTick, // Trigger garbage collection
  withoutAggressiveGC, // Disable aggressive GC for performance tests
} from "harness";
```

---

title: Accessing Private Properties and JSC Intrinsics - Using $ Prefix
description: Illustrates the use of the `$` prefix to access private properties and JavaScriptCore intrinsics in built-in modules.  The preprocessor converts `$` to `@` during build. This allows access to internal functionality within the JavaScript runtime.
source: AGENTS.md#_snippet_5

language: javascript
code:
```
const arr = $Array.from(...);  // Private global
map.$set(...);                 // Private method
const arr2 = $newArrayWithSize(5); // JSC intrinsic
```

---

title: Loading Modules - Using Require String Literals
description: Demonstrates how to load modules using `require()` within built-in modules.  The module identifiers must be string literals, which are resolved at compile time by numeric ID. This is not standard ES module behavior.
source: AGENTS.md#_snippet_6

language: javascript
code:
```
const fs = require("fs"); // Directly loads by numeric ID
```

---

title: Using Debug Helpers - Debugging and Assertions
description: Demonstrates the use of debug helpers such as `$debug()` and `$assert()`, which are stripped in release builds, as well as conditional debug checks. These allow developers to add logging and assertions during development without impacting production performance.
source: AGENTS.md#_snippet_7

language: javascript
code:
```
$debug() // Like console.log but stripped in release builds
$assert() // Assertions stripped in release builds
if($debug) {} // Check if debug env var is set
```

---

title: Handling Re-export Runtime - JavaScript
description: Demonstrates how re-exports are handled when the external module requires runtime processing. An `import` statement is added to the top level, and a `__reExport` function call is inserted into the wrapper to handle the re-export.
source: src/bundler/linker_context/README.md#_snippet_2

language: javascript
code:
```
// Input:
export * from "./external-module";

// Output (when external module needs runtime re-export):
import * as ns from "./external-module"; // â† outside_wrapper_prefix
__reExport(exports, ns, module.exports); // â† inside_wrapper_prefix (runtime call)
```

---

title: Formatting Code - Running Prettier
description: Demonstrates how to use Prettier to format JavaScript and TypeScript files in the Bun project. Running this command ensures consistent code style.
source: CLAUDE.md#_snippet_5

language: shell
code:
```
bun run prettier
```

---

title: Formatting Code - Running Zig Format
description: Illustrates how to use `zig-format` to format Zig files within the Bun project. This helps maintain a consistent code style across Zig source code.
source: CLAUDE.md#_snippet_6

language: shell
code:
```
bun run zig-format
```

---

title: Formatting Code - Running Clang Format
description: Demonstrates using `clang-format` to format C++ files in the Bun project. Running this ensures the C++ code adheres to the project's style guidelines.
source: CLAUDE.md#_snippet_7

language: shell
code:
```
bun run clang-format
```

---

title: Checking the Status of a Pull Request - Using Bun CI
description: Demonstrates how to use the `bun ci` command to get the status of a pull request in the Bun project's BuildKite CI system.
source: CLAUDE.md#_snippet_12

language: bash
code:
```
bun ci
```

---

title: Renaming Identifiers with Numbering - JavaScript
description: Illustrates how identifiers are renamed using a number-based approach when minification is disabled. The input code includes conflicting variable names (`x`) in different functions, and the number-renamed output shows how these conflicts are resolved by appending a number (e.g., `x_1`) to avoid naming collisions during development.
source: src/bundler/linker_context/README.md#_snippet_2

language: javascript
code:
```
// Input with conflicts:
function test() {
  var x = 1;
}
function test2() {
  var x = 2;
} // Conflict with first 'x'

// Number-renamed output:
function test() {
  var x = 1;
}
function test2() {
  var x_1 = 2;
} // Renamed to avoid conflict
```

---

title: Adding Custom Checks After Bundling
description: Explains the usage of `onAfterBundle` to add custom checks after the bundle is created. This example reads the content of `/out.js` and throws an error if it contains the string 'this', ensuring that all instances of `this` have been correctly rewritten to `exports`.
source: test/bundler/expectBundled.md#_snippet_4

language: typescript
code:
```
itBundled("default/ThisOutsideFunctionRenamedToExports", {
  files: {
    "/entry.js": /* js */ `
      console.log(this)
      console.log((x = this) => this)
      console.log({x: this})
      console.log(class extends this.foo {})
      console.log(class { [this.foo] })
      console.log(class { [this.foo]() {} })
      console.log(class { static [this.foo] })
      console.log(class { static [this.foo]() {} })
    `,
  },
  onAfterBundle(api) {
    if (api.readFile("/out.js").includes("this")) {
      throw new Error("All cases of `this` should have been rewritten to `exports`");
    }
  },
});
```

---

title: Capturing Specific JavaScript Output
description: Demonstrates using `capture` to isolate and verify specific JavaScript output emitted by the bundler. The example evaluates template string lengths and comparisons, capturing the resulting values to ensure they match the expected results after minification.
source: test/bundler/expectBundled.md#_snippet_6

language: typescript
code:
```
itBundled("minify/TemplateStringFolding", {
  files: {
    "/entry.js": /* js */ `
      capture(\`[U+1F60B][U+1F4CB][U+1F44C]\`.length)
      capture(\`[U+1F60B][U+1F4CB][U+1F44C]\`.length === 6)
      capture(\`[U+1F60B][U+1F4CB][U+1F44C]\`.length == 6)
      capture(\`[U+1F60B][U+1F4CB][U+1F44C]\`.length === 2)
      capture(\`[U+1F60B][U+1F4CB][U+1F44C]\`.length == 2)
    `,
  },
  minifySyntax: true,
  capture: ["6", "true", "true", "false", "false"],
});
```

---

title: Adding String Escape Characters in Bun Flavored TOML
description: Demonstrates the extended string escape sequences available in Bun-flavored TOML for better interoperability with JavaScript strings. It adds support for hexadecimal and unicode escapes using `\x{XX}` and `\u{x+}` respectively, as well as the vertical tab `\v`.
source: docs/bun-flavored-toml.md#_snippet_1

language: toml
code:
```
# Bun-flavored TOML extras
\x{XX}     - ASCII           (U+00XX)
\u{x+}     - unicode         (U+0000000X) - (U+XXXXXXXX)
\v         - vertical tab

# Regular TOML
\b         - backspace       (U+0008)
\t         - tab             (U+0009)
\n         - linefeed        (U+000A)
\f         - form feed       (U+000C)
\r         - carriage return (U+000D)
\"         - quote           (U+0022)
\\         - backslash       (U+005C)
\uXXXX     - unicode         (U+XXXX)
\UXXXXXXXX - unicode         (U+XXXXXXXX)
```

---

title: Transforming Modules (CommonJS)
description: Illustrates the transformation of a module with no exports into a CommonJS module. This ensures that the namespace object exists at runtime.
source: src/bundler/linker_context/README.md#_snippet_4

language: javascript
code:
```
// Input: module-a.js (has no exports)
// No code, just an empty file

// Input: module-b.js
import * as a from "./module-a.js";
console.log(a);

// Result: module-a.js is marked as exports_kind = .cjs, wrap = .cjs
// This ensures the namespace object 'a' exists at runtime
```

---

title: Handling Export Star Conflicts
description: Illustrates how the bundler handles export star conflicts when multiple modules export the same name, resulting in potentially ambiguous exports.
source: src/bundler/linker_context/README.md#_snippet_8

language: javascript
code:
```
// constants.js
export const API_URL = "https://api.example.com";
export const VERSION = "1.0.0";

// utils.js
export const formatDate = date => date.toISOString();
export const API_URL = "https://dev.api.example.com"; // Conflict!

// index.js
export * from "./constants.js";
export * from "./utils.js";

// Result: index.js exports formatDate, VERSION, and API_URL (marked as potentially ambiguous)
// Bundler will emit warning about API_URL conflict
```

---

title: Parallelizing with LinkerContext
description: Illustrates the parallelization strategy used by the LinkerContext to improve bundling performance. It highlights parallel processing for symbol renaming, code generation, CSS processing, source map calculations, and post-processing.
source: src/bundler/linker_context/README.md#_snippet_7

language: text
code:
```
## Parallelization Strategy

The LinkerContext makes extensive use of parallel processing:

- **Symbol renaming**: Each chunk's symbols are renamed in parallel
- **Code generation**: Each part range is compiled in parallel
- **CSS processing**: CSS chunks are processed in parallel
- **Source maps**: Source map calculations are parallelized
- **Post-processing**: Final chunk processing happens in parallel

This parallelization significantly improves bundling performance for large applications.
```

---

title: Adding TypeScript Support - Bun Project
description: Explains how to add TypeScript support to a Bun project by installing the `@types/bun` package and configuring the `tsconfig.json` file. This resolves type errors related to the `Bun` global and enables TypeScript features within the Bun environment.
source: docs/quickstart.md#_snippet_2

language: sh
code:
```
$ bun add -d @types/bun
```

language: json
code:
```
{
  "compilerOptions": {
    "lib": ["ESNext"],
    "target": "ESNext",
    "module": "Preserve",
    "moduleDetection": "force",
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "noEmit": true,
  }
}
```

---

title: Writing to Standard Output
description: Shows how to write to standard output using `console.write` in Bun.js. The code writes the string 'Hello World!' to the console without a trailing newline. This method can be used with both strings and typed arrays.
source: docs/benchmarks.md#_snippet_4

language: javascript
code:
```
// no trailing newline
// works with strings and typed arrays
console.write("Hello World!");
```

---

title: Writing Responses to Disk
description: Illustrates writing a `Response` object to disk using `Bun.write`.  The code fetches content from `https://example.com` using `fetch`, then writes the resulting `Response` to a file named `index.html`. This automatically converts the `Response` to a `Blob` before writing it to disk.
source: docs/benchmarks.md#_snippet_6

language: javascript
code:
```
// Eventually, this will stream the response to disk but today it buffers
await Bun.write("index.html", await fetch("https://example.com"));
```

---

title: Handling CommonJS Compatibility - Javascript
description: Illustrates the handling of CommonJS compatibility in ES module output format. When the entry point is a CommonJS module being output as an ES module, the `exports` and `module` symbols are marked as unbound to prevent renaming, ensuring they retain their original names.
source: src/bundler/linker_context/README.md#_snippet_2

language: javascript
code:
```
// For CommonJS entry points in ES module output format:
if (isEntryPoint && outputFormat === 'esm' && moduleKind === 'cjs') {
  // Mark exports/module symbols as unbound so they don't get renamed
  symbols[exportsRef].kind = .unbound; // Keep "exports" name
  symbols[moduleRef].kind = .unbound;  // Keep "module" name
}
```

---

title: Computing Reserved Names For Symbol Renaming - Javascript
description: Describes how reserved names are computed during symbol renaming to avoid conflicts. It outlines that initial reserved names are computed based on the output format (browser globals or Node.js builtins), and existing symbol names in the chunk's module scopes are preserved.
source: src/bundler/linker_context/README.md#_snippet_8

language: javascript
code:
```
// For browser output format:
["window", "document", "console", "setTimeout", "fetch", ...]

// For Node.js output format:
["require", "module", "exports", "process", "Buffer", "__dirname", ...]

// Plus any existing identifiers in the code:
["myExistingFunction", "API_KEY", "UserClass", ...]
```

---

title: Providing a Test Implementation to Todo - Typescript
description: Shows how to provide a test implementation to a `todo` test. This implementation will not be run unless the `--todo` flag is passed to `bun test`.
source: docs/guides/test/todo-tests.md#_snippet_2

language: typescript
code:
```
import { test, expect } from "bun:test";

test.todo("unimplemented feature", () => {
  expect(Bun.isAwesome()).toBe(true);
});
```

---

title: Running Todo Tests with Implementation - Shell
description: Demonstrates how to run `todo` tests with an implementation using the `--todo` flag. If the test passes, `bun test` will return a non-zero exit code.
source: docs/guides/test/todo-tests.md#_snippet_3

language: shell
code:
```
$ bun test --todo
my.test.ts:
âœ— unimplemented feature
  ^ this test is marked as todo but passes. Remove `.todo` or check that test is correct.

 0 pass
 1 fail
 1 expect() calls
$ echo $?
1 # this is the exit code of the previous command
```

---

title: Configuring Different Coverage Thresholds - Bun
description: Demonstrates how to configure separate coverage thresholds for line-level and function-level coverage in `bunfig.toml`. This allows for more granular control over coverage requirements, for example, requiring 50% line coverage and 70% function coverage.  This is useful when certain parts of the code require different levels of coverage.
source: docs/guides/test/coverage-threshold.md#_snippet_2

language: toml
code:
```
[test]
# to set different thresholds for lines and functions
coverageThreshold = { lines = 0.5, functions = 0.7 }
```

---

title: Configuring Preload for Happy-Dom Environment - TOML
description: Demonstrates how to configure `happy-dom` as a preload in `bunfig.toml` for DOM testing in Bun. This injects browser APIs into the global scope, providing a browser-like environment for tests.
source: docs/guides/test/migrate-from-jest.md#_snippet_4

language: toml
code:
```
[test]
preload = ["./happy-dom.ts"]
```

---

title: Installing Specific Version of Bun (Linux/Mac)
description: Demonstrates installing a specific version of Bun by passing the version tag to the installation script. It uses `curl` to download and execute the script with the desired version specified.
source: docs/installation.md#_snippet_14

language: sh
code:
```
$ curl -fsSL https://bun.com/install | bash -s "bun-v$BUN_LATEST_VERSION"
```

---

title: Installing Specific Version of Bun (Windows)
description: Illustrates how to install a specific version of Bun on Windows using the Powershell installation script. The `-Version` parameter is used to specify the desired Bun version.
source: docs/installation.md#_snippet_15

language: sh
code:
```
# PowerShell:
$ iex "& {$(irm https://bun.com/install.ps1)} -Version $BUN_LATEST_VERSION"
```

---

title: Declaration Merging for Testing Library Matchers (TypeScript)
description: Shows how to use declaration merging in TypeScript to extend the `Matchers` interface in `bun:test` with Testing Library's matchers. This allows TypeScript to recognize and provide type checking for the new matchers in your tests.
source: docs/guides/test/testing-library.md#_snippet_5

language: typescript
code:
```
import { TestingLibraryMatchers } from '@testing-library/jest-dom/matchers';
import { Matchers, AsymmetricMatchers } from 'bun:test';

declare module 'bun:test' {
  interface Matchers<T>
    extends TestingLibraryMatchers<typeof expect.stringContaining, T> {}
  interface AsymmetricMatchers extends TestingLibraryMatchers {}
}
```

---

title: Listening to BeforeExit and Exit Events - TypeScript
description: Demonstrates listening to both the `
source: docs/guides/process/os-signals.md#_snippet_2

language: typescript
code:
```
process.on("beforeExit", code => {
  console.log(`Event loop is empty!`);
});

process.on("exit", code => {
  console.log(`Process is exiting with code ${code}`);
});
```

---

title: Listening for CTRL+C (TypeScript)
description: Demonstrates how to listen for the CTRL+C signal using `process.on('SIGINT')`.  This allows your application to gracefully handle interruptions and perform cleanup operations before exiting.
source: README.md#_snippet_11

language: typescript
code:
```
process.on('SIGINT', () => {
  console.log('Received SIGINT. Exiting...');
  process.exit(0);
});

console.log('Press CTRL+C to exit.');
await new Promise(() => {});
```

---

title: Detecting When Code Is Executed With Bun (TypeScript)
description: Shows how to detect if code is being run with Bun by checking the `Bun` global variable. This can be used to conditionally execute code specific to the Bun runtime.
source: README.md#_snippet_19

language: typescript
code:
```
if (typeof Bun !== 'undefined') {
  console.log('Running in Bun!');
} else {
  console.log('Not running in Bun.');
}
```

---

title: Specifying Encoding When Appending Data - JavaScript
description: Shows how to specify the encoding when appending data to a file using `fs.appendFile`. The `appendFile` function is called with the file name, the data to append, the encoding type (`utf8`), and a callback function to handle the result.
source: docs/guides/write-file/append.md#_snippet_2

language: javascript
code:
```
import { appendFile } from "node:fs";

appendFile("message.txt", "data to append", "utf8", callback);
```

---

title: Replacing Global Identifiers
description: Demonstrates how to replace global identifiers such as `window` with `undefined` to handle server-side rendering (SSR) scenarios or ensure code doesn't depend on the `window` object.
source: docs/guides/runtime/define-constant.md#_snippet_4

language: sh
code:
```
bun --define window="undefined" src/index.ts
```

language: js
code:
```
if (typeof window !== "undefined") {
  console.log(
```

---

title: Referencing Environment Variables - Bunfig TOML
description: Illustrates referencing environment variables within `bunfig.toml` for registry configuration. Shows how Bun automatically loads environment variables from `.env.local`, `.env.[NODE_ENV]`, and `.env` files, enabling dynamic configuration without hardcoding sensitive information.
source: docs/guides/install/custom-registry.md#_snippet_1

language: toml
code:
```
[install]
registry = { url = "https://registry.npmjs.org", token = "$npm_token" }
```

---

title: Configuring Optional Dependencies (packagejson)
description: Illustrates the addition of `zod` to the `optionalDependencies` section within the `package.json` file. This configuration specifies that `zod` is an optional dependency, meaning the application can still run if `zod` fails to install.
source: docs/guides/install/add-optional.md#_snippet_1

language: json-diff
code:
```
{
  "optionalDependencies": {
+   "zod": "^3.0.0"
  }
}
```

---

title: Pinning to Exact Version of Package
description: Demonstrates how to pin a package to an exact version using the `--exact` flag with `bun add`. This command adds the package to `dependencies` without the `^`, ensuring that only the specified version is used.
source: docs/guides/install/add.md#_snippet_2

language: sh
code:
```
$ bun add zod --exact
```

---

title: Specifying Version or Tag
description: Illustrates how to specify a particular version or tag when adding a package using `bun add`. This allows installing specific versions or tagged releases of a package.
source: docs/guides/install/add.md#_snippet_3

language: sh
code:
```
$ bun add zod@3.0.0
$ bun add zod@next
```

---

title: Configuring Azure Artifacts Using Environment Variables - Shell
description: Illustrates how to configure Azure Artifacts by setting the `NPM_CONFIG_REGISTRY` environment variable. The URL includes the username and password directly, enabling authentication with the Azure Artifacts registry without a `bunfig.toml` file.
source: docs/guides/install/azure-artifacts.md#_snippet_2

language: bash
code:
```
NPM_CONFIG_REGISTRY=https://pkgs.dev.azure.com/my-azure-artifacts-user/_packaging/my-azure-artifacts-user/npm/registry/:username=<USERNAME>:_password=<PASSWORD>
```

---

title: Describing Project Structure of React App
description: Illustrates the directory structure of a React application created with Bun. The file structure includes components (`App.tsx`, `APITester.tsx`), entry points (`index.tsx`, `frontend.tsx`), configuration files (`tsconfig.json`, `bunfig.toml`), and static assets.
source: docs/guides/ecosystem/react.md#_snippet_1

language: text
code:
```
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ index.tsx       # Server entry point with API routes
â”‚   â”œâ”€â”€ frontend.tsx    # React app entry point with HMR
â”‚   â”œâ”€â”€ App.tsx         # Main React component
â”‚   â”œâ”€â”€ APITester.tsx   # Component for testing API endpoints
â”‚   â”œâ”€â”€ index.html      # HTML template
â”‚   â”œâ”€â”€ index.css       # Styles
â”‚   â””â”€â”€ *.svg           # Static assets
â”œâ”€â”€ package.json        # Dependencies and scripts
â”œâ”€â”€ tsconfig.json       # TypeScript configuration
â”œâ”€â”€ bunfig.toml         # Bun configuration
â””â”€â”€ bun.lock            # Lock file
```

---

title: Automating Build Metadata Injection - TypeScript
description: Demonstrates creating a build script that automatically injects build metadata. The script uses `bun` and shell commands to retrieve the git version, build time, and commit hash, then injects them as build-time constants using `Bun.build`.
source: docs/guides/runtime/build-time-constants.md#_snippet_10

language: ts
code:
```
// build.ts
import { $ } from "bun";

const version = await $`git describe --tags --always`.text();
const buildTime = new Date().toISOString();
const gitCommit = await $`git rev-parse HEAD`.text();

await Bun.build({
  entrypoints: ["./src/cli.ts"],
  outdir: "./dist",
  define: {
    BUILD_VERSION: JSON.stringify(version.trim()),
    BUILD_TIME: JSON.stringify(buildTime),
    GIT_COMMIT: JSON.stringify(gitCommit.trim()),
  },
});

console.log(`Built with version ${version.trim()}`);
```

---

title: Inspecting Subsets in ArrayBuffer
description: Illustrates how a `Uint8Array` can represent a subset of data within an `ArrayBuffer`. The `byteOffset` and `byteLength` properties indicate the starting position and length of the subset, respectively, while the `buffer` property returns the entire underlying buffer.
source: docs/guides/binary/typedarray-to-arraybuffer.md#_snippet_1

language: typescript
code:
```
const arr = new Uint8Array(64, 16, 32);
arr.buffer; // => ArrayBuffer(64)
arr.byteOffset; // => 16
arr.byteLength; // => 32
```

---

title: Configuring SvelteKit Adapter for Bun
description: Demonstrates how to configure the SvelteKit project to use the `svelte-adapter-bun` adapter. First, it installs the adapter as a development dependency using `bun add -D svelte-adapter-bun`. Then, it shows how to modify the `svelte.config.js` file to import and use the Bun adapter instead of the default adapter.
source: docs/guides/ecosystem/sveltekit.md#_snippet_2

language: ts-diff
code:
```
- import adapter from "@sveltejs/adapter-auto";
+ import adapter from "svelte-adapter-bun";
  import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

  /** @type {import('@sveltejs/kit').Config} */
  const config = {
  	// Consult https://svelte.dev/docs/kit/integrations#preprocessors
  	// for more information about preprocessors
  	preprocess: vitePreprocess(),

  	kit: {
  		// adapter-auto only supports some environments, see https://svelte.dev/docs/kit/adapter-auto for a list.
  		// If your environment is not supported, or you settled on a specific environment, switch out the adapter.
  		// See https://svelte.dev/docs/kit/adapters for more information about adapters.
  		adapter: adapter()
  	}
  };

  export default config;
```

---

title: Configuring the Development Script in packagejson
description: Illustrates how to modify the `package.json` file to simplify starting the development server.  Updates the `dev` script to use `bunx --bun vite`, allowing the server to be started with `bun run dev`.
source: docs/guides/ecosystem/vite.md#_snippet_3

language: json-diff
code:
```
  "scripts": {
-   "dev": "vite",
+   "dev": "bunx --bun vite",
    "build": "vite build",
    "serve": "vite preview"
  },
  // ...
```

---

title: Filtering Scripts By Workspace Name
description: This demonstrates how to use the `--filter` flag with `bun` to run a script concurrently across multiple workspace packages.  It allows targeting specific packages based on a glob pattern matching their names, respecting dependency order.
source: docs/guides/install/from-npm-install-to-bun-install.md#_snippet_3

language: sh
code:
```
$ bun --filter 'lib-*' my-script
# instead of:
# npm run --workspace lib-foo --workspace lib-bar my-script
```

---

title: Listing Running Docker Containers
description: Demonstrates how to list all running Docker containers using the `docker ps` command. This is useful for identifying the container ID, image name, and other information about the running containers, which can be used to manage them.
source: docs/guides/ecosystem/docker.md#_snippet_5

language: sh
code:
```
$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
7f03e212a15e        bun-hello-world     "bun run index.ts"       2 minutes ago       Up 2 minutes        0.0.0.0:3000->3000/tcp   flamboyant_cerf
```

---

title: Generating SQL Migrations with Drizzle Kit
description: Explains how to use the `drizzle-kit` CLI to generate SQL migrations based on a defined schema. This command creates the necessary files for managing database schema changes.
source: docs/guides/ecosystem/drizzle.md#_snippet_5

language: sh
code:
```
$ bunx drizzle-kit generate --dialect sqlite --schema ./schema.ts
```

---

title: Reloading Systemd Daemon (Bash)
description: Explains the process of reloading the systemd daemon after modifying a service file.  `systemctl daemon-reload` ensures that systemd recognizes the updated configuration.
source: docs/guides/ecosystem/systemd.md#_snippet_6

language: bash
code:
```
$ sudo systemctl daemon-reload
```

---

title: Creating a Typed Array Sub-Section From ArrayBuffer
description: Demonstrates how to create a typed array that views only a portion of an `ArrayBuffer`. By passing the offset and length to the `Uint8Array` constructor, a specific section of the buffer can be accessed and manipulated.
source: docs/guides/binary/arraybuffer-to-typedarray.md#_snippet_2

language: ts
code:
```
const buffer = new ArrayBuffer(64);
const arr = new Uint8Array(buffer, 0, 16); // view first 16 bytes
```

---

title: Configuring Chunk Size for Blob Stream
description: Demonstrates how to set the chunk size for the `Blob.stream()` method by passing a number to the method. This controls the size of the chunks streamed from the `Uint8Array`, optimizing the streaming process.
source: docs/guides/binary/typedarray-to-readablestream.md#_snippet_2

language: ts
code:
```
const arr = new Uint8Array(64);
const blob = new Blob([arr]);

// set chunk size of 1024 bytes
const stream = blob.stream(1024);
```

---

title: Globally Checking Package Installation with Bun
description: Demonstrates the usage of glob patterns with `bun why` to check the installation reasons for multiple packages matching a specific pattern (e.g., `@types/*`). This is useful for understanding dependencies across a range of related packages.
source: docs/cli/why.md#_snippet_2

language: bash
code:
```
$ bun why "@types/*"
@types/react@18.2.15
  â””â”€ dev my-app@1.0.0 (requires ^18.0.0)

@types/react-dom@18.2.7
  â””â”€ dev my-app@1.0.0 (requires ^18.0.0)
```

---

title: Limiting Dependency Tree Depth -Bash
description: Demonstrates the `--depth` option, allowing you to limit the depth of the dependency tree displayed by `bun why`. This is helpful for focusing on the immediate dependencies without being overwhelmed by deeply nested relationships.
source: docs/cli/why.md#_snippet_4

language: bash
code:
```
$ bun why express --depth 2
express@4.18.2
  â””â”€ express-pollyfill@1.20.1 (requires ^4.18.2)
     â””â”€ body-parser@1.20.1 (requires ^1.20.1)
     â””â”€ accepts@1.3.8 (requires ^1.3.8)
        â””â”€ (deeper dependencies hidden)
```

---

title: Simulating Publish Process with Dry Run
description: Illustrates how to simulate the publish process without actually publishing the package using the `--dry-run` flag. This is useful for verifying the contents of the published package without actually publishing it.
source: docs/cli/publish.md#_snippet_3

language: sh
code:
```
$ bun publish --dry-run
```

---

title: Examining Generated Drizzle Migration Files
description: Illustrates the structure of the generated `drizzle` directory after running `drizzle-kit generate`. It contains a SQL migration file (e.g., `0000_aspiring_post.sql`) and a `meta` directory with snapshot and journal JSON files.
source: docs/guides/ecosystem/neon-drizzle.md#_snippet_7

language: txt
code:
```
drizzle
â”œâ”€â”€ 0000_aspiring_post.sql
â””â”€â”€ meta
    â”œâ”€â”€ 0000_snapshot.json
    â””â”€â”€ _journal.json
```

---

title: Seeding the Database
description: Illustrates how to seed the database with initial data using Drizzle. It imports the database instance and the schema, then uses the `db.insert` function to insert multiple rows into the `authors` table.
source: docs/guides/ecosystem/neon-drizzle.md#_snippet_10

language: ts
code:
```
import { db } from "./db";
import * as schema from "./schema";

async function seed() {
  await db.insert(schema.authors).values([
    {
      name: "J.R.R. Tolkien",
      bio: "The creator of Middle-earth and author of The Lord of the Rings.",
    },
    {
      name: "George R.R. Martin",
      bio: "The author of the epic fantasy series A Song of Ice and Fire.",
    },
    {
      name: "J.K. Rowling",
      bio: "The creator of the Harry Potter series.",
    },
  ]);
}

async function main() {
  try {
    await seed();
    console.log("Seeding completed");
  } catch (error) {
    console.error("Error during seeding:", error);
    process.exit(1);
  }
}

main();
```

---

title: Running the Seeding Script
description: Demonstrates executing the `seed.ts` script using `bun run`. The output confirms successful completion of the database seeding process.
source: docs/guides/ecosystem/neon-drizzle.md#_snippet_11

language: sh
code:
```
$ bun run seed.ts
Seeding completed
```

---

title: Using Bun PM View as an Alias for Bun Info
description: Demonstrates that `bun pm view` is an alias for `bun info`.  This command allows developers to use a more descriptive name (`view`) to retrieve package metadata, offering flexibility in command usage.
source: docs/cli/info.md#_snippet_4

language: bash
code:
```
$ bun pm view react  # equivalent to: bun info react
```

---

title: Adding an Optional Dependency Using Bun
description: Demonstrates how to add a package as an optional dependency using the `--optional` flag with the `bun add` command. Optional dependencies are not required for the application to run, and installation failures will not cause the install to fail.
source: docs/cli/add.md#_snippet_3

language: bash
code:
```
$ bun add --optional lodash
```

---

title: Adding a Peer Dependency Using Bun
description: Illustrates how to add a package as a peer dependency using the `--peer` flag with the `bun add` command.  Peer dependencies express compatibility with a host package.
source: docs/cli/add.md#_snippet_4

language: bash
code:
```
$ bun add --peer @types/bun
```

---

title: Adding Git Dependencies Using Bun
description: Illustrates how to add a dependency from a public or private Git repository using the `bun add` command. This allows you to install packages directly from Git repositories.
source: docs/cli/add.md#_snippet_9

language: bash
code:
```
$ bun add git@github.com:moment/moment.git
```

---

title: Defining BunfigToml Configuration (TypeScript)
description: Defines the TypeScript interfaces that represent the structure of the `bunfig.toml` configuration file. This includes interfaces for `Root`, `Install`, `Registry`, `Scopes`, `Cache`, and `Lockfile`, which define the types and properties available for configuring Bun's installation behavior.
source: docs/cli/bun-install.md#_snippet_1

language: typescript
code:
```
export interface Root {
  install: Install;
}

export interface Install {
  scopes: Scopes;
  registry: Registry;
  production: boolean;
  saveTextLockfile: boolean;
  frozenLockfile: boolean;
  dryRun: boolean;
  optional: boolean;
  dev: boolean;
  peer: boolean;
  globalDir: string;
  globalBinDir: string;
  cache: Cache;
  lockfile: Lockfile;
  logLevel: "debug" | "error" | "warn";
}

type Registry =
  | string
  | {
      url?: string;
      token?: string;
      username?: string;
      password?: string;
    };

type Scopes = Record<string, Registry>;

export interface Cache {
  dir: string;
  disable: boolean;
  disableManifest: boolean;
}

export interface Lockfile {
  print?: "yarn";
  save: boolean;
}
```

---

title: Specifying Install Backend with Bun Install (Bash)
description: Illustrates how to specify the installation backend for `bun install` using the `--backend` flag. This allows users to force a specific method for copying files, such as `hardlink`, `clonefile`, `copyfile`, or `symlink`, for performance tuning or troubleshooting.
source: docs/cli/bun-install.md#_snippet_3

language: bash
code:
```
$ rm -rf node_modules
$ bun install --backend hardlink
```

language: bash
code:
```
$ rm -rf node_modules
$ bun install --backend clonefile
```

language: bash
code:
```
$ rm -rf node_modules
$ bun install --backend clonefile_each_dir
```

---

title: Configuring Preload in bunfigtoml - Bun
description: Illustrates how to configure the `--preload` option in the `bunfig.toml` file to automatically run a setup script before each test run. This eliminates the need to specify the `--preload` flag every time you run tests, ensuring consistent test environment setup.
source: docs/test/lifecycle.md#_snippet_4

language: toml
code:
```
[test]
preload = ["./setup.ts"]
```

---

title: Rerunning Tests for Flakiness Detection
description: Explains how to rerun each test multiple times using the `--rerun-each` flag to detect flaky or non-deterministic test failures. This is useful for identifying tests that intermittently fail.
source: docs/cli/test.md#_snippet_7

language: sh
code:
```
$ bun test --rerun-each 100
```

---

title: Using emitDecoratorMetadata - TypeScript
description: Illustrates the use of `emitDecoratorMetadata` to enable design-time type metadata for decorated declarations. The example shows how `Reflect.getMetadata` retrieves metadata about constructor parameters, allowing dependency injection frameworks or other tools to inspect and utilize type information at runtime.
source: docs/runtime/typescript.md#_snippet_4

language: typescript
code:
```
import "reflect-metadata";

class User {
  id: number;
  name: string;
}

function Injectable(target: Function) {
  // Get metadata about constructor parameters
  const params = Reflect.getMetadata("design:paramtypes", target);
  console.log("Dependencies:", params); // [User]
}

@Injectable
class UserService {
  constructor(private user: User) {}
}

// Creates new UserService instance with dependencies
const container = new UserService(new User());
```

---

title: Configuring Coverage Reporters - TOML
description: Demonstrates how to configure coverage reporters using the `coverageReporter` and `coverageDir` options in `bunfig.toml`. It shows how to specify multiple reporters (e.g., `text`, `lcov`) and customize the directory where coverage reports are saved.
source: docs/test/coverage.md#_snippet_7

language: toml
code:
```
[test]
coverageReporter  = ["text", "lcov"]  # default ["text"]
coverageDir = "path/to/somewhere"  # default "coverage"
```

---

title: Adjusting Concurrent Scripts - Bash
description: Explains how to adjust the maximum number of concurrent scripts that run during installation using the `--concurrent-scripts` flag.  The default value is two times the CPU count or GOMAXPROCS. This can optimize installation speed.
source: docs/cli/install.md#_snippet_3

language: bash
code:
```
$ bun install --concurrent-scripts 5
```

---

title: Filtering Dependencies Installation - Bash
description: Demonstrates how to use the `--filter` flag to install dependencies for specific packages in a monorepo.  This allows for selective installation of dependencies based on package names or paths.
source: docs/cli/install.md#_snippet_5

language: bash
code:
```
# Install dependencies for all workspaces except `pkg-c`
$ bun install --filter '!pkg-c'

# Install dependencies for only `pkg-a` in `./packages/pkg-a`
$ bun install --filter './packages/pkg-a'
```

---

title: Installing in Production Mode - Bash
description: Explains how to install dependencies in production mode, which excludes `devDependencies` and `optionalDependencies`. The `--production` flag enables this mode, optimizing for deployment.
source: docs/cli/install.md#_snippet_8

language: bash
code:
```
$ bun install --production
```

---

title: Omitting Dependencies - Bash
description: Illustrates how to omit specific types of dependencies during installation using the `--omit` flag. You can exclude `dev`, `peer`, or `optional` dependencies to tailor the installation process.
source: docs/cli/install.md#_snippet_10

language: bash
code:
```
# Exclude "devDependencies" from the installation. This will apply to the
# root package and workspaces if they exist. Transitive dependencies will
# not have "devDependencies".
$ bun install --omit dev

# Install only dependencies from "dependencies"
$ bun install --omit=dev --omit=peer --omit=optional
```

---

title: Performing a Dry Run - Bash
description: Shows how to perform a dry run of `bun install` using the `--dry-run` flag. This allows you to preview the installation process without actually installing any packages.
source: docs/cli/install.md#_snippet_11

language: bash
code:
```
$ bun install --dry-run
```

---

title: Installing with Isolated Strategy - Bash
description: Demonstrates how to use the `isolated` linker strategy with `bun install`. This creates strict dependency isolation, similar to pnpm, preventing phantom dependencies by creating a central package store with symlinks.
source: docs/cli/install.md#_snippet_14

language: bash
code:
```
$ bun install --linker isolated
```

---

title: Expanding Braces in Shell Commands - JavaScript
description: Illustrates how to use `$.braces` for brace expansion in shell commands. This is useful for generating multiple commands with similar patterns, which can then be executed using Bun Shell.
source: docs/runtime/shell.md#_snippet_4

language: javascript
code:
```
import { $ } from "bun";

await $.braces(`echo {1,2,3}`);
// => ["echo 1", "echo 2", "echo 3"]
```

---

title: Escaping Strings for Shell Commands - JavaScript
description: Demonstrates how to escape strings for use in shell commands using `$.escape`. This is necessary to prevent unintended interpretation of special characters by the shell.
source: docs/runtime/shell.md#_snippet_5

language: javascript
code:
```
import { $ } from "bun";

console.log($.escape('$(foo) `bar` "baz"'));
// => \$(foo) \`bar\` \"baz\"
```

---

title: Using Raw Strings in Shell Commands - JavaScript
description: Illustrates how to prevent escaping of strings in shell commands by wrapping them in a `{ raw: 'str' }` object. This is useful when you want the shell to interpret the string directly without any modification.
source: docs/runtime/shell.md#_snippet_6

language: javascript
code:
```
import { $ } from "bun";

await $`echo ${{ raw: '$(foo) `bar` "baz"' }}`;
// => bun: command not found: foo
// => bun: command not found: bar
// => baz
```

---

title: Inspecting Errors with Syntax Highlighting
description: Demonstrates how to inspect errors and display a syntax-highlighted source code preview using `Bun.inspect(error)`. This is useful for debugging and understanding the context of errors.
source: docs/runtime/debugger.md#_snippet_7

language: typescript
code:
```
// Create an error
const err = new Error("Something went wrong");
console.log(Bun.inspect(err, { colors: true }));
```

---

title: Executing Asynchronous Tasks with onStart
description: Demonstrates the use of asynchronous operations within the `onStart` lifecycle hook of a Bun plugin.  The example shows Bun waiting for both a sleep operation and a shell command to complete before continuing the bundling process, ensuring that setup tasks are finished.
source: docs/runtime/plugins.md#_snippet_2

language: typescript
code:
```
const result = await Bun.build({
  entrypoints: ["./app.ts"],
  outdir: "./dist",
  sourcemap: "external",
  plugins: [
    {
      name: "Sleep for 10 seconds",
      setup(build) {
        build.onStart(async () => {
          await Bunlog.sleep(10_000);
        });
      },
    },
    {
      name: "Log bundle time to a file",
      setup(build) {
        build.onStart(async () => {
          const now = Date.now();
          await Bun.$`echo ${now} > bundle-time.txt`;
        });
      },
    },
  ],
});
```

---

title: Configuring Scoped Registries in Bunfigtoml
description: Demonstrates configuring registries for specific scopes (e.g., `@myorg/<package>`) using the `install.scopes` section in `bunfig.toml`. It showcases how to define a registry as a string or with username/password or token, and demonstrates referencing environment variables within the configuration.
source: docs/runtime/bunfig.md#_snippet_2

language: toml
code:
```
[install.scopes]
# registry as string
myorg = "https://username:password@registry.myorg.com/"

# registry with username/password
# you can reference environment variables
myorg = { username = "myusername", password = "$npm_password", url = "https://registry.myorg.com/" }

# registry with token
myorg = { token = "$npm_token", url = "https://registry.myorg.com/" }
```

---

title: Aliasing Node to Bun Globally in Bunfigtoml
description: Illustrates enabling the automatic aliasing of `node` to `bun` for all scripts and executables invoked by `bun run` or `bun` by setting `bun = true` in the `[run]` section of `bunfig.toml`. This is equivalent to using the `--bun` flag.
source: docs/runtime/bunfig.md#_snippet_9

language: toml
code:
```
[run]
# equivalent to `bun --bun` for all `bun run` commands
bun = true
```

---

title: Suppressing Command Output When Running Bun in Bunfigtoml
description: Demonstrates how to suppress the output of the command being run by `bun run` or `bun` by setting `silent = true` in the `[run]` section of `bunfig.toml`. This is equivalent to passing `--silent` to all `bun run` commands.
source: docs/runtime/bunfig.md#_snippet_11

language: toml
code:
```
[run]
silent = true
```

---

title: Specifying .env Files with --env-file
description: Demonstrates how to manually specify which `.env` files to load using the `--env-file` flag. This allows overriding the default `.env` file loading behavior, providing flexibility in choosing configuration files.
source: docs/runtime/env.md#_snippet_4

language: sh
code:
```
$ bun --env-file=.env.1 src/index.ts

$ bun --env-file=.env.abc --env-file=.env.def run build
```

---

title: Using Import and Require Together - TypeScript
description: Illustrates the co-existence of `import` and `require` in the same file. This example demonstrates Bun's ability to handle both ES modules and CommonJS modules seamlessly, promoting interoperability between different module systems.
source: docs/runtime/modules.md#_snippet_5

language: ts
code:
```
import { stuff } from "./my-commonjs.cjs";
import Stuff from "./my-commonjs.cjs";
const myStuff = require("./my-commonjs.cjs");
```

---

title: Combining Subpath and Conditional Exports - JSON
description: Shows how to combine subpath and conditional exports in `package.json` for advanced module resolution. This allows a package to specify different entry points for different module systems (ESM vs. CommonJS) while also controlling which subpaths are exposed, offering fine-grained control over package structure and usage.
source: docs/runtime/modules.md#_snippet_8

language: json
code:
```
{
  "name": "foo",
  "exports": {
    ".": {
      "import": "./index.mjs",
      "require": "./index.js"
    }
  }
}
```

---

title: Setting Test-Specific Timeouts in Bun:test
description: Demonstrates how to set a per-test timeout using the third argument to the `test` function in `bun:test`.  This allows specifying a maximum execution time for individual tests, preventing them from running indefinitely. If the test doesn't finish within the timeout, it will fail.
source: docs/test/writing.md#_snippet_4

language: ts
code:
```
import { test } from "bun:test";

test("wat", async () => {
  const data = await slowOperation();
  expect(data).toBe(42);
}, 500); // test must run in <500ms
```

---

title: Running Specific Tests with Test.only in Bun:test
description: Demonstrates how to run only specific tests or suites using `test.only()` or `describe.only()` in `bun:test`. It imports `test` and `describe` from `bun:test`. This is useful for focusing on a subset of tests during development.
source: docs/test/writing.md#_snippet_7

language: ts
code:
```
import { test, describe } from "bun:test";

test("test #1", () => {
  // does not run
});

test.only("test #2", () => {
  // runs
});

describe.only("only", () => {
  test("test #3", () => {
    // runs
  });
});
```

---

title: Applying Conditional Modifiers to Describe Blocks in Bun:test
description: Illustrates how to apply conditional modifiers like `.if()`, `.skipIf()`, and `.todoIf()` to `describe` blocks in `bun:test`. This allows affecting all tests within a suite based on a condition. The examples show running the suite only on macOS, skipping the suite on Windows, and marking the suite as TODO on Linux.
source: docs/test/writing.md#_snippet_12

language: ts
code:
```
const isMacOS = process.platform === "darwin";

// Only runs the entire suite on macOS
describe.if(isMacOS)("macOS-specific features", () => {
  test("feature A", () => {
    // only runs on macOS
  });

  test("feature B", () => {
    // only runs on macOS
  });
});

// Skips the entire suite on Windows
describe.skipIf(process.platform === "win32")("Unix features", () => {
  test("feature C", () => {
    // skipped on Windows
  });
});

// Marks the entire suite as TODO on Linux
describe.todoIf(process.platform === "linux")("Upcoming Linux support", () => {
  test("feature D", () => {
    // marked as TODO on Linux
  });
});
```

---

title: Using Format Specifiers for Test Titles in Bun:test
description: Demonstrates how to use format specifiers like `%s`, `%i`, and `%p` for formatting test titles when using `test.each` in `bun:test`.  The examples show using basic specifiers, `%p` for pretty-format output, and `%#` for the test case index.
source: docs/test/writing.md#_snippet_15

language: ts
code:
```
// Basic specifiers
test.each([
  ["hello", 123],
  ["world", 456],
])("string: %s, number: %i", (str, num) => {
  // "string: hello, number: 123"
  // "string: world, number: 456"
});

// %p for pretty-format output
test.each([
  [{ name: "Alice" }, { a: 1, b: 2 }],
  [{ name: "Bob" }, { x: 5, y: 10 }],
])("user %p with data %p", (user, data) => {
  // "user { name: 'Alice' } with data { a: 1, b: 2 }"
  // "user { name: 'Bob' } with data { x: 5, y: 10 }"
});

// %# for index
test.each(["apple", "banana"])("fruit #%# is %s", fruit => {
  // "fruit #0 is apple"
  // "fruit #1 is banana"
});
```

---

title: Verifying Assertion Counts with Expect.hasAssertions in Bun:test
description: Shows how to use `expect.hasAssertions()` to verify that at least one assertion is called during a test in `bun:test`. This is useful for ensuring that asynchronous tests call assertions.
source: docs/test/writing.md#_snippet_16

language: ts
code:
```
test("async work calls assertions", async () => {
  expect.hasAssertions(); // Will fail if no assertions are called

  const data = await fetchData();
  expect(data).toBeDefined();
});
```

---

title: Overriding Existing Modules With Bun Plugin
description: Illustrates how to override existing modules using `build.module`. The code demonstrates how subsequent calls to `build.module` with the same specifier will replace the previous module definition, affecting future imports or requires.
source: docs/runtime/plugins.md#_snippet_8

language: js
code:
```
import { plugin } from "bun";
build.module("my-object-virtual-module", () => {
  return {
    exports: {
      foo: "bar",
    },
    loader: "object",
  };
});

require("my-object-virtual-module"); // { foo: "bar" }
await import("my-object-virtual-module"); // { foo: "bar" }

build.module("my-object-virtual-module", () => {
  return {
    exports: {
      baz: "quix",
    },
    loader: "object",
  };
});
require("my-object-virtual-module"); // { baz: "quix" }
await import("my-object-virtual-module"); // { baz: "quix" }
```

---

title: Customizing JSX Factory Function with `jsxFactory`
description: Illustrates how to customize the function used to create JSX elements using the `jsxFactory` compiler option.  It demonstrates setting `jsxFactory` to `h` and shows the resulting code using `h` instead of `createElement`.
source: docs/runtime/jsx.md#_snippet_4

language: json
code:
```
{
  "jsx": "react",
  "jsxFactory": "h"
}
```

language: tsx
code:
```
import { h } from "react";
h("Box", { width: 5 }, "Hello");
```

---

title: Customizing JSX Fragment Factory with `jsxFragmentFactory`
description: Demonstrates how to customize the function used to create JSX fragments using the `jsxFragmentFactory` compiler option.  It demonstrates setting `jsxFragmentFactory` to `MyFragment` and shows the resulting code using `myjsx(MyFragment, ...)`.
source: docs/runtime/jsx.md#_snippet_5

language: json
code:
```
{
  "jsx": "react",
  "jsxFactory": "myjsx",
  "jsxFragmentFactory": "MyFragment"
}
```

language: tsx
code:
```
// input
<>Hello</>;

// output
import { myjsx, MyFragment } from "react";
myjsx(MyFragment, null, "Hello");
```

---

title: Specifying JSX Import Source with `jsxImportSource`
description: Illustrates how the `jsxImportSource` compiler option specifies the module from which JSX factory functions are imported. The first example shows the default import from `react/jsx-runtime` when `jsxImportSource` is omitted, and the other two examples demonstrates importing from `preact/jsx-runtime` and `preact/jsx-dev-runtime` when `jsxImportSource` is set to `preact`.
source: docs/runtime/jsx.md#_snippet_6

language: jsonc
code:
```
{
  "jsx": "react",
  // jsxImportSource is not defined
  // default to "react"
}
```

language: tsx
code:
```
import { jsx } from "react/jsx-runtime";
jsx("Box", { width: 5, children: "Hello" });
```

language: jsonc
code:
```
{
  "jsx": "react-jsx",
  "jsxImportSource": "preact",
}
```

language: tsx
code:
```
import { jsx } from "preact/jsx-runtime";
jsx("Box", { width: 5, children: "Hello" });
```

language: jsonc
code:
```
{
  "jsx": "react-jsxdev",
  "jsxImportSource": "preact",
}
```

language: tsx
code:
```
// /jsx-runtime is automatically appended
import { jsxDEV } from "preact/jsx-dev-runtime";
jsxDEV(
  "Box",
  { width: 5, children: "Hello" },
  undefined,
  false,
  undefined,
  this,
);
```

---

title: Prefetching DNS Entries - Node.js
description: Illustrates how to use the experimental `dns.prefetch` API in Bun to prefetch a DNS entry for a given hostname and port.  Prefetching can reduce latency when a connection to that host is subsequently established, for example, using `fetch`. This is especially useful for database connections or other services that are frequently accessed.
source: docs/api/dns.md#_snippet_1

language: ts
code:
```
import { dns } from "bun";

dns.prefetch("my.database-host.com", 5432);
```

---

title: Attaching Headers on Upgrade
description: Demonstrates how to attach additional headers to the `101 Switching Protocols` response during the WebSocket upgrade process. This allows setting cookies or other relevant headers to be sent to the client when the WebSocket connection is established.
source: docs/api/websockets.md#_snippet_3

language: typescript
code:
```
Bun.serve({
  fetch(req, server) {
    const sessionId = await generateSessionId();
    server.upgrade(req, {
      headers: {
        "Set-Cookie": `SessionId=${sessionId}`,
      },
    });
  },
  websocket: {}, // handlers
});
```

---

title: Implementing Pub/Sub for Group Chat
description: Demonstrates a basic publish-subscribe implementation for a group chat using `Bun.serve`, allowing WebSocket clients to subscribe to a topic and broadcast messages to other subscribers. The example showcases how to handle `open`, `message`, and `close` events to manage subscriptions and publish messages.
source: docs/api/websockets.md#_snippet_6

language: typescript
code:
```
const server = Bun.serve<{ username: string }>({
  fetch(req, server) {
    const url = new URL(req.url);
    if (url.pathname === "/chat") {
      console.log(`upgrade!`);
      const username = getUsernameFromReq(req);
      const success = server.upgrade(req, { data: { username } });
      return success
        ? undefined
        : new Response("WebSocket upgrade error", { status: 400 });
    }

    return new Response("Hello world");
  },
  websocket: {
    open(ws) {
      const msg = `${ws.data.username} has entered the chat`;
      ws.subscribe("the-group-chat");
      server.publish("the-group-chat", msg);
    },
    message(ws, message) {
      // this is a group chat
      // so the server re-broadcasts incoming message to everyone
      server.publish("the-group-chat", `${ws.data.username}: ${message}`);
    },
    close(ws) {
      const msg = `${ws.data.username} has left the chat`;
      ws.unsubscribe("the-group-chat");
      server.publish("the-group-chat", msg);
    },
  },
});

console.log(`Listening on ${server.hostname}:${server.port}`);
```

---

title: Publishing Server-Side Messages
description: Demonstrates how to publish messages to a topic from the server instance, allowing server-side events to be broadcast to all subscribers of a specific topic. This example shows how to use the `.publish()` method on the `Server` instance to send a message.
source: docs/api/websockets.md#_snippet_7

language: typescript
code:
```
const server = Bun.serve({
  websocket: {
    // ...
  },
});

// listen for some external event
server.publish("the-group-chat", "Hello world");
```

---

title: Defining Global Identifiers - TOML
description: Demonstrates using the `define` field in `bunfig.toml` to replace global identifiers with constant expressions. This is useful for injecting configuration values or feature flags into your code at build time. Bun will replace any usage of the specified identifier with the provided expression.
source: docs/runtime/bunfig.md#_snippet_4

language: toml
code:
```
[define]
# Replace any usage of "process.env.bagel" with the string `lox`.
# The values are parsed as JSON, except single-quoted strings are supported and `'undefined'` becomes `undefined` in JS.
# This will probably change in a future release to be just regular TOML instead. It is a holdover from the CLI argument parsing.
"process.env.bagel" = "'lox'"
```

---

title: Mapping File Extensions to Loaders - TOML
description: Illustrates how to configure file extension to loader mappings using the `loader` field in `bunfig.toml`. This allows Bun to handle custom file types by specifying which loader should be used to process them. For example, you can instruct Bun to treat `.bagel` files as `tsx` files.
source: docs/runtime/bunfig.md#_snippet_5

language: toml
code:
```
[loader]
# when a .bagel file is imported, treat it like a tsx file
".bagel" = "tsx"
```

---

title: Handling Non-Existent Files - TypeScript
description: Illustrates how `Bun.file` handles non-existent files. It shows that you can create a `BunFile` instance for a file that doesn't exist, and accessing its `size` returns 0, the default `type` is `text/plain;charset=utf-8`, and `.exists()` returns `false`.
source: docs/api/file-io.md#_snippet_3

language: typescript
code:
```
const notreal = Bun.file("notreal.txt");
notreal.size; // 0
notreal.type; // "text/plain;charset=utf-8"
const exists = await notreal.exists(); // false
```

---

title: Configuring High Water Mark for FileSink - TypeScript
description: Shows how to configure the high water mark for a `FileSink` instance, which determines when the buffer is automatically flushed to disk. It illustrates how to set the `highWaterMark` option when creating a `FileSink`.
source: docs/api/file-io.md#_snippet_13

language: typescript
code:
```
const file = Bun.file("output.txt");
const writer = file.writer({ highWaterMark: 1024 * 1024 }); // 1MB
```

---

title: Sending Multiple Packets with `sendMany()` - Unconnected Socket
description: Demonstrates how to efficiently send multiple UDP packets at once using the `sendMany()` API on an unconnected socket. Each packet is specified as a set of three array elements: data, port, and address. The address must be a valid IP address.
source: docs/api/udp.md#_snippet_4

language: typescript
code:
```
const socket = await Bun.udpSocket({});
// sends 'Hello' to 127.0.0.1:41234, and 'foo' to 1.1.1.1:53 in a single operation
socket.sendMany([
```

---

title: Sending Multiple Packets with `sendMany()` - Connected Socket
description: Demonstrates how to use `sendMany()` with a connected socket. Each array element represents the data to be sent to the connected peer. The `connect` option must be used when creating the socket.
source: docs/api/udp.md#_snippet_5

language: typescript
code:
```
const socket = await Bun.udpSocket({
  connect: {
    port: 41234,
    hostname:
```

---

title: Selecting Columns to Insert - TypeScript
description: Illustrates how to select specific columns to insert into a PostgreSQL table using Bun's SQL client. The `sql(object, ...string)` helper allows specifying which columns from the object should be included in the `INSERT` statement.  This is useful when the object contains fields that do not correspond to columns in the table, or when you only want to insert a subset of the available data.
source: docs/api/sql.md#_snippet_3

language: ts
code:
```
const user = {
  name: "Alice",
  email: "alice@example.com",
  age: 25,
};

await sql`INSERT INTO users ${sql(user, "name", "email")}`;
// Only inserts name and email columns, ignoring other fields
```

---

title: Referencing Table Names Dynamically - TypeScript
description: Demonstrates how to safely reference table names dynamically in SQL queries using Bun's SQL client. The `sql()` helper is used to escape the table name, preventing SQL injection vulnerabilities. This approach allows building queries that adapt to different tables or schemas at runtime.
source: docs/api/sql.md#_snippet_6

language: ts
code:
```
// Safely reference tables dynamically
await sql`SELECT * FROM ${sql("users")}`;

// With schema qualification
await sql`SELECT * FROM ${sql("public.users")}`;
```

---

title: Updating Columns Dynamically - TypeScript
description: Illustrates how to dynamically update columns in a PostgreSQL table using Bun's SQL client. The `sql(object, ...string)` helper allows specifying which columns from the object should be updated.  This provides control over which fields are included in the `UPDATE` statement.
source: docs/api/sql.md#_snippet_8

language: ts
code:
```
await sql`UPDATE users SET ${sql(user, "name", "email")} WHERE id = ${user.id}`;
// uses all keys from the object to update the row
await sql`UPDATE users SET ${sql(user)} WHERE id = ${user.id}`;
```

---

title: Executing Queries from Files - TypeScript
description: Demonstrates how to execute SQL queries from files using the `sql.file` method in Bun's SQL client.  The queries from the file can be parameterized using `$1`, `$2`, etc.  If no parameters are used, it can execute multiple commands per file.
source: docs/api/sql.md#_snippet_11

language: ts
code:
```
const result = await sql.file("query.sql", [1, 2, 3]);
```

---

title: Creating Blob from Mixed Data Types
description: Illustrates constructing a `Blob` from a combination of string, `Blob`, and `Uint8Array` parts.  The example concatenates these parts to form a complete HTML document, showing the flexibility of the `Blob` constructor.
source: docs/api/binary-data.md#_snippet_10

language: ts
code:
```
const blob = new Blob([
  "<html>",
  new Blob(["<body>"]),
  new Uint8Array([104, 101, 108, 108, 111]), // "hello" in binary
  "</body></html>",
]);
```

---

title: Scanning Code For Imports And Exports - TypeScript
description: Illustrates how to use the `scan` method to analyze code for imports and exports. The `scan` method returns a list of exports, and a list of imports along with their `kind` and `path`.
source: docs/api/transpiler.md#_snippet_5

language: typescript
code:
```
const transpiler = new Bun.Transpiler({
  loader: 'tsx',
});

const code = `
import React from 'react';
import type {ReactNode} from 'react';
const val = require('./cjs.js')
import('./loader');

export const name = "hello";
`;

const result = transpiler.scan(code);
```

language: json
code:
```
{
  "exports": [
    "name"
  ],
  "imports": [
    {
      "kind": "import-statement",
      "path": "react"
    },
    {
      "kind": "import-statement",
      "path": "remix"
    },
    {
      "kind": "dynamic-import",
      "path": "./loader"
    }
  ]
}
```

---

title: Scanning Code For Imports - TypeScript
description: Demonstrates using the `scanImports` method to efficiently analyze code for imports.  It's faster than `scan` but slightly less accurate due to performance optimizations.
source: docs/api/transpiler.md#_snippet_6

language: typescript
code:
```
const transpiler = new Bun.Transpiler({
  loader: 'tsx',
});

const code = `
import React from 'react';
import type {ReactNode} from 'react';
const val = require('./cjs.js')
import('./loader');

export const name = "hello";
`;

const result = transpiler.scanImports(code);
```

language: json
code:
```
[
  {
    kind: "import-statement",
    path: "react"
  }, {
    kind: "require-call",
    path: "./cjs.js"
  }, {
    kind: "dynamic-import",
    path: "./loader"
  }
]
```

---

title: Configuring Path For Bun Which
description: Shows how to configure the `PATH` environment variable when using `Bun.which()` to locate executables.  This allows searching for executables in specific directories.
source: docs/api/utils.md#_snippet_6

language: typescript
code:
```
const ls = Bun.which("ls", {
  PATH: "/usr/local/bin:/usr/bin:/bin",
});
console.log(ls); // "/usr/bin/ls"
```

---

title: Finding Executable With Cwd
description: Explains how to use the `cwd` option with `Bun.which()` to resolve executables from within a specific directory. This limits the search scope.
source: docs/api/utils.md#_snippet_7

language: typescript
code:
```
const ls = Bun.which("ls", {
  cwd: "/tmp",
  PATH: "",
});

console.log(ls); // null
```

---

title: Specifying Editor Line And Column
description: Demonstrates how to specify the editor, line number, and column number when opening a file using `Bun.openInEditor()`. This allows opening the file at a specific location.
source: docs/api/utils.md#_snippet_14

language: typescript
code:
```
Bun.openInEditor(import.meta.url, {
  editor: "vscode", // or "subl"
  line: 10,
  column: 5,
});
```

---

title: Performing Strict Deep Equals Comparison
description: Shows how to enable strict mode in `Bun.deepEquals()` by passing a third boolean parameter. This is used by `expect().toStrictEqual()` in the test runner.
source: docs/api/utils.md#_snippet_16

language: typescript
code:
```
const a = { entries: [1, 2] };
const b = { entries: [1, 2], extra: undefined };

Bun.deepEquals(a, b); // => true
Bun.deepEquals(a, b, true); // => false
```

---

title: Specifying TLS Keys and Certificates
description: Illustrates the different ways to specify the contents of TLS keys and certificates for secure communication in `Bun.listen`. The `key` and `cert` fields can accept a string, `BunFile`, `TypedArray`, or `Buffer` containing the certificate or key data, or an array of these types.
source: docs/api/tcp.md#_snippet_3

language: typescript
code:
```
Bun.listen({
  // ...
  tls: {
    // BunFile
    key: Bun.file("./key.pem"),
    // Buffer
    key: fs.readFileSync("./key.pem"),
    // string
    key: fs.readFileSync("./key.pem", "utf8"),
    // array of above
    key: [Bun.file("./key1.pem"), Bun.file("./key2.pem")],
  },
});
```

---

title: Hot Reloading Server Handlers
description: Explains how to hot reload handlers for all active server-side sockets using the `server.reload` method. This allows updating the server's behavior without restarting the server, such as changing the `data` handler.
source: docs/api/tcp.md#_snippet_7

language: typescript
code:
```
const server = Bun.listen({ /* config */ })

// reloads handlers for all active server-side sockets
server.reload({
  socket: {
    data(){
      // new 'data' handler
    }
  }
})
```

---

title: Hot Reloading Client Handlers
description: Explains how to hot reload handlers for a client socket using the `socket.reload` method. This allows updating the client's behavior without disconnecting, such as changing the `data` handler.
source: docs/api/tcp.md#_snippet_8

language: typescript
code:
```
const socket = await Bun.connect({ /* config */ })
socket.reload({
  data(){
    // new 'data' handler
  }
})
```

---

title: Extending Matchers Using Extend - JavaScript
description: Demonstrates how to extend `expect` with custom matchers using `.extend`. This lets you create your own assertion functions tailored to your specific testing needs.
source: docs/test/writing.md#_snippet_19

language: javascript
code:
```
expect.extend({
  toBeDivisibleBy(received, divisor) {
    const pass = received % divisor == 0;
    if (pass) {
      return {
        message: () =>
          `expected ${received} not to be divisible by ${divisor}`,
        pass: true,
      };
    } else {
      return {
        message: () =>
          `expected ${received} to be divisible by ${divisor}`,
        pass: false,
      };
    }
  },
});
```

---

title: Setting Assertion Count Using Assertions - JavaScript
description: Demonstrates the `.assertions()` matcher to verify that a certain number of assertions are called within a test. This helps ensure that all expected checks are performed, especially in asynchronous tests.
source: docs/test/writing.md#_snippet_23

language: javascript
code:
```
expect.assertions(1);
expect(true).toBe(true);
```

---

title: Requiring Assertions Using HasAssertions - JavaScript
description: Illustrates using `.hasAssertions()` to enforce that at least one assertion is called within a test.  This can help prevent tests from accidentally passing when they shouldn't, particularly with asynchronous code.
source: docs/test/writing.md#_snippet_25

language: javascript
code:
```
expect.hasAssertions();
expect(true).toBe(true);
```

---

title: Matching Snapshots Using ToMatchSnapshot - JavaScript
description: Demonstrates the `.toMatchSnapshot()` matcher, used to compare a value against a previously recorded snapshot. This is useful for detecting unexpected changes in output.
source: docs/test/writing.md#_snippet_47

language: javascript
code:
```
expect({ foo: 'bar' }).toMatchSnapshot();
```

---

title: Matching Inline Snapshots Using ToMatchInlineSnapshot - JavaScript
description: Illustrates the usage of `.toMatchInlineSnapshot()` matcher, which is a convenient way to create and update snapshots directly in your test file. It is useful for smaller snapshots and simplifies the snapshot management.
source: docs/test/writing.md#_snippet_48

language: javascript
code:
```
expect({ foo: 'bar' }).toMatchInlineSnapshot(`
  Object {
    "foo": "bar",
  }
`);
```

---

title: Matching Error Snapshots Using ToThrowErrorMatchingSnapshot - JavaScript
description: Demonstrates the `.toThrowErrorMatchingSnapshot()` matcher, which is used to ensure that a function throws an error that matches a previously recorded snapshot. It's particularly helpful for tracking changes in error messages or error objects.
source: docs/test/writing.md#_snippet_49

language: javascript
code:
```
expect(() => { throw new Error('This is an error'); }).toThrowErrorMatchingSnapshot();
```

---

title: Matching Inline Error Snapshots Using ToThrowErrorMatchingInlineSnapshot - JavaScript
description: Illustrates using the `.toThrowErrorMatchingInlineSnapshot()` matcher. This is a convenient way to create and update snapshots for thrown errors directly within the test. This is suitable for shorter, more concise error messages.
source: docs/test/writing.md#_snippet_50

language: javascript
code:
```
expect(() => { throw new Error('This is an error'); }).toThrowErrorMatchingInlineSnapshot(`"This is an error"`);
```

---

title: Returning a C Object to JavaScript with N-API
description: Demonstrates returning a C object to JavaScript using N-API within `bun:ffi`. The C code defines a function that creates a N-API object and returns it. This approach allows passing complex data structures between C and JavaScript without type conversion.
source: docs/api/cc.md#_snippet_2

language: c
code:
```
#include <node/node_api.h>

napi_value hello(napi_env env) {
  napi_value result;
  napi_create_object(env, &result);
  return result;
}
```

---

title: Using Safe Integers - With Bigint
description: Demonstrates how to configure the `Database` to return integers as `bigint` types by setting the `safeIntegers` option to `true`. This is necessary when dealing with integers larger than 2^53 to prevent data loss due to JavaScript's number precision limitations.
source: docs/api/sqlite.md#_snippet_7

language: typescript
code:
```
import { Database } from "bun:sqlite";

const db = new Database(":memory:", { safeIntegers: true });
const query = db.query(
  `SELECT ${BigInt(Number.MAX_SAFE_INTEGER) + 102n} as max_int`,
);
const result = query.get();
console.log(result.max_int); // => 9007199254741093n
```

---

title: Loading SQLite Extensions
description: Demonstrates how to load a SQLite extension using `.loadExtension(name)`.  This allows you to add custom functions and features to your SQLite database.
source: docs/api/sqlite.md#_snippet_13

language: typescript
code:
```
import { Database } from "bun:sqlite";

const db = new Database();
db.loadExtension("myext");
```

---

title: Closing a Database Connection
description: Illustrates how to close a database connection using the `.close()` method.  The `throwOnError` argument determines whether to throw an error if there are pending queries. It's important to close connections to free resources.
source: docs/api/sqlite.md#_snippet_7

language: ts
code:
```
const db = new Database();
// ... do stuff
db.close(false);
```

language: ts
code:
```
const db = new Database();
// ... do stuff
db.close(true);
```

---

title: Listening for the Open Event
description: Demonstrates listening for the `open` event on a worker. This event is emitted when the worker is created and ready to receive messages, useful for sending an initial message once it's ready.
source: docs/api/workers.md#_snippet_7

language: ts
code:
```
const worker = new Worker(new URL("worker.ts", import.meta.url).href);

worker.addEventListener("open", () => {
  console.log("worker is ready");
});
```

---

title: Listening for the Close Event
description: Demonstrates how to listen for the `close` event on a worker. This event is emitted when a worker has been terminated and provides the exit code.
source: docs/api/workers.md#_snippet_11

language: ts
code:
```
const worker = new Worker(new URL("worker.ts", import.meta.url).href);

worker.addEventListener("close", event => {
  console.log("worker is being closed");
});
```

---

title: Increasing Maximum HTTP Requests (Bun Configuration)
description: Demonstrates how to increase the maximum number of simultaneous `fetch` requests using the `BUN_CONFIG_MAX_HTTP_REQUESTS` environment variable. This can be useful for applications that need to make a large number of concurrent requests.
source: docs/api/fetch.md#_snippet_3

language: sh
code:
```
$ BUN_CONFIG_MAX_HTTP_REQUESTS=512 bun ./my-script.ts
```

---

title: Executing Raw Commands in Redis - Bun
description: Demonstrates how to use the `send` method to execute arbitrary Redis commands that may not have dedicated methods in the client. This allows for accessing the full range of Redis functionality using the Bun Redis client.
source: docs/api/redis.md#_snippet_8

language: ts
code:
```
// Run any Redis command
const info = await redis.send("INFO", []);

// LPUSH to a list
await redis.send("LPUSH", ["mylist", "value1", "value2"]);

// Get list range
const list = await redis.send("LRANGE", ["mylist", "0", "-1"]);
```

---

title: Boosting Performance by Passing JSCallback Prototype
description: Demonstrates a performance optimization for passing a JavaScript callback to a native function. Instead of passing the entire `JSCallback` object, pass `JSCallback.prototype.ptr` directly to avoid overhead.
source: docs/api/ffi.md#_snippet_11

language: typescript
code:
```
const onResolve = new JSCallback(arg => arg === 42, {
  returns: "bool",
  args: ["i32"],
});
const setOnResolve = new CFunction({
  returns: "bool",
  args: ["function"],
  ptr: myNativeLibrarySetOnResolve,
});

// This code runs slightly faster:
setOnResolve(onResolve.ptr);

// Compared to this:
setOnResolve(onResolve);
```

---

title: Handling Peer Dependencies with Specialized Paths
description: Demonstrates how isolated installs manage peer dependencies by creating specialized directory paths that encode both the package version and its peer dependency versions.  This ensures each unique combination of package and peer dependency versions gets its own isolated installation, resolving potential conflicts. The directory name includes the package version and its peer dependency versions.
source: docs/install/isolated.md#_snippet_3

language: bash
code:
```
# Package with peer dependencies creates specialized paths
node_modules/.bun/package@1.0.0_react@18.2.0/
```

---

title: Streaming Response Bodies with Async Iterators
description: Illustrates how to stream a response body using async iterators in Bun's `fetch` API. This allows processing large response bodies in chunks, reducing memory usage and improving performance.
source: docs/api/fetch.md#_snippet_3

language: typescript
code:
```
const response = await fetch("http://example.com");

for await (const chunk of response.body) {
  console.log(chunk);
}
```

---

title: Streaming Request Bodies with ReadableStream
description: Shows how to stream data in request bodies using a `ReadableStream` object with Bun's `fetch` API. This allows sending large amounts of data in chunks, useful for uploading files or other large payloads.
source: docs/api/fetch.md#_snippet_4

language: typescript
code:
```
const stream = new ReadableStream({
  start(controller) {
    controller.enqueue("Hello");
    controller.enqueue(" ");
    controller.enqueue("World");
    controller.close();
  },
});

const response = await fetch("http://example.com", {
  method: "POST",
  body: stream,
});
```

---

title: Setting up Inter-Process Communication
description: Illustrates how to set up inter-process communication (IPC) between two `bun` processes. The example shows how to specify an `ipc` handler in the parent process to receive messages from the child process, and demonstrates sending a message from the parent to the child.
source: docs/api/spawn.md#_snippet_12

language: typescript
code:
```
const child = Bun.spawn(["bun", "child.ts"], {
  ipc(message) {
    /**
     * The message received from the sub process
     **/
  },
});
```

language: typescript
code:
```
const childProc = Bun.spawn(["bun", "child.ts"], {
  ipc(message, childProc) {
    /**
     * The message received from the sub process
     **/
    childProc.send(
```

---

title: Sending and Receiving IPC Messages
description: Demonstrates how to send messages from the parent process to the child process and vice versa using IPC with `process.send()` and `process.on("message")`. The parent process can use `.send()` on the `Subprocess` instance, and the child process uses `process.send()` to send messages to its parent.
source: docs/api/spawn.md#_snippet_13

language: typescript
code:
```
Respond to child")
  },
});

childProc.send("I am your father"); // The parent can send messages to the child as well
```

language: typescript
code:
```
process.send("Hello from child as string");
process.send({ message: "Hello from child as object" });

process.on("message", (message) => {
  // print message from parent
  console.log(message);
});
```

---

title: Sending Messages in the Child Process
description: Illustrates how the child process sends messages to its parent using `process.send()`. It shows how to send both string and object messages.
source: docs/api/spawn.md#_snippet_14

language: typescript
code:
```
// send a string
process.send("Hello from child as string");

// send an object
process.send({ message: "Hello from child as object" });
```

---

title: Using IPC Between Bun and Nodejs
description: Demonstrates how to enable inter-process communication between a Bun process and a Node.js process by setting `serialization: "json"` in `Bun.spawn`. This ensures compatibility between the different JavaScript engines used by Bun and Node.js.
source: docs/api/spawn.md#_snippet_15

language: javascript
code:
```
if (typeof Bun !== "undefined") {
  const prefix = `[bun ${process.versions.bun} [U+1F407]]`;
  const node = Bun.spawn({
    cmd: ["node", __filename],
    ipc({ message }) {
      console.log(message);
      node.send({ message: `${prefix} [U+1F44B] hey node` });
      node.kill();
    },
    stdio: ["inherit", "inherit", "inherit"],
    serialization: "json",
  });

  node.send({ message: `${prefix} [U+1F44B] hey node` });
} else {
  const prefix = `[node ${process.version}]`;
  process.on("message", ({ message }) => {
    console.log(message);
    process.send({ message: `${prefix} [U+1F44B] hey bun` });
  });
}
```

---

title: Defining Route Precedence in Bun Serve
description: Explains the order of route matching in `Bun.serve`: exact routes, parameter routes, wildcard routes, and finally a global catch-all. This example defines routes to demonstrate this precedence.
source: docs/api/http.md#_snippet_8

language: typescript
code:
```
Bun.serve({
  routes: {
    // Most specific first
    "/api/users/me": () => new Response("Current user"),
    "/api/users/:id": req => new Response(`User ${req.params.id}`),
    "/api/*": () => new Response("API catch-all"),
    "/*": () => new Response("Global catch-all"),
  },
});
```

---

title: Handling All Methods with a Single Route Handler
description: Illustrates how to handle all HTTP methods with a single route handler function in `Bun.serve`. It shows that if an object with method handlers isn't provided, a function will handle all methods.
source: docs/api/http.md#_snippet_10

language: typescript
code:
```
const server = Bun.serve({
  routes: {
    "/api/version": () => Response.json({ version: "1.0.0" }),
  },
});

await fetch(new URL("/api/version", server.url));
await fetch(new URL("/api/version", server.url), { method: "PUT" });
// ... etc
```

---

title: Omitting Dependency Types During Installation
description: Explains how to use the `--omit` flag with `bun install` to exclude specific dependency types like `dev`, `optional`, or `peer` during installation. This can be useful to reduce the installation size or to avoid installing dependencies that are not needed in a specific environment.
source: docs/install/index.md#_snippet_3

language: bash
code:
```
# Disable devDependencies and optionalDependencies
$ bun install --omit=dev --omit=optional
```

---

title: Forwarding Requests with the Fetch Handler
description: Illustrates how the `fetch` handler in `Bun.serve` can be used to forward incoming requests to another server.  This example shows a simple proxy implementation where all requests are forwarded to `https://example.com`. This is useful for creating reverse proxies or load balancers.
source: docs/api/http.md#_snippet_3

language: typescript
code:
```
Bun.serve({
  fetch(req) {
    // Forward the request to another server.
    return fetch("https://example.com");
  },
});
```

---

title: Activating Development Mode for Error Display
description: Shows how to enable development mode in `Bun.serve` using the `development: true` option. In development mode, Bun provides a built-in error page in the browser to display server-side errors, making debugging easier.
source: docs/api/http.md#_snippet_9

language: typescript
code:
```
Bun.serve({
  development: true,
  fetch(req) {
    throw new Error("woops!");
  },
});
```

---

title: Overriding Trusted CA Certificates
description: Demonstrates how to override the default trusted CA (Certificate Authority) certificates in `Bun.serve` by providing a value for the `ca` option in the `tls` object. When `ca` is specified, the default Mozilla list is overwritten. This is useful when using self-signed certificates or a custom CA.
source: docs/api/http.md#_snippet_15

language: typescript
code:
```
Bun.serve({
    fetch(req) {
      return new Response("Hello!!!");
    },
    tls: {
      key: Bun.file("./key.pem"), // path to TLS key
      cert: Bun.file("./cert.pem"), // path to TLS cert
      ca: Bun.file("./ca.pem"), // path to root CA certificate
    }
  });
```

---

title: Sending Partial File Content Using Slice Method
description: Illustrates sending a portion of a file using the `slice(start, end)` method on a `Bun.file` object. This automatically sets the `Content-Range` and `Content-Length` headers in the `Response`.
source: docs/api/http.md#_snippet_3

language: typescript
code:
```
Bun.serve({
  fetch(req) {
    // parse `Range` header
    const [start = 0, end = Infinity] = req.headers
      .get("Range") // Range: bytes=0-100
      .split("=") // ["Range: bytes", "0-100"]
      .at(-1) // "0-100"
      .split("-") // ["0", "100"]
      .map(Number); // [0, 100]

    // return a slice of the file
    const bigFile = Bun.file("./big-video.mp4");
    return new Response(bigFile.slice(start, end));
  },
});
```

---

title: Getting Client IP and Port Information
description: Illustrates how to retrieve client IP and port information using `server.requestIP(req)`. This method returns the client's address and port or `null` for closed requests or Unix domain sockets.
source: docs/api/http.md#_snippet_8

language: typescript
code:
```
const server = Bun.serve({
  fetch(req, server) {
    const address = server.requestIP(req);
    if (address) {
      return new Response(
        `Client IP: ${address.address}, Port: ${address.port}`,
      );
    }
    return new Response("Unknown client");
  },
});
```

---

title: Monitoring Server Activity with Counters
description: Shows how to monitor server activity using the built-in counters `server.pendingRequests` and `server.pendingWebSockets`. These counters provide insights into the number of active requests and WebSocket connections.
source: docs/api/http.md#_snippet_12

language: typescript
code:
```
const server = Bun.serve({
  fetch(req, server) {
    return new Response(
      `Active requests: ${server.pendingRequests}\n` +
        `Active WebSockets: ${server.pendingWebSockets}`,
    );
  },
});
```

---

title: Adding a Banner to a Bun Build
description: Illustrates how to add a banner to the final bundle using the `banner` option in `Bun.build`. This is useful for adding directives like 'use client' for React or including license information.
source: docs/bundler/index.md#_snippet_3

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  banner: '"use client";'
})
```

language: CLI
code:
```
$ bun build ./index.tsx --outdir ./out --banner "\"use client;\""
```

---

title: Adding a Footer to a Bun Build
description: Demonstrates how to add a footer to the final bundle using the `footer` option in `Bun.build`. This can be used for adding license information or custom messages.
source: docs/bundler/index.md#_snippet_4

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  footer: '// built with love in SF'
})
```

language: CLI
code:
```
$ bun build ./index.tsx --outdir ./out --footer="// built with love in SF"
```

---

title: Inlining Environment Variables
description: Demonstrates how to inline environment variables into the bundled output using the `env` option. This replaces `process.env.FOO` references with string literals of the actual environment variable values.
source: docs/bundler/index.md#_snippet_6

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  env: "inline",
})
```

language: CLI
code:
```
$ FOO=bar BAZ=123 bun build ./index.tsx --outdir ./out --env inline
```

---

title: Using Environment Variable Prefixes
description: Demonstrates how to inline environment variables with a specific prefix using the `env` option.  This replaces `process.env.FOO` references with string literals only for variables matching the provided prefix.
source: docs/bundler/index.md#_snippet_7

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',

  // Inline all env vars that start with "ACME_PUBLIC_"
  env: "ACME_PUBLIC_*",
})
```

language: CLI
code:
```
$ FOO=bar BAZ=123 ACME_PUBLIC_URL=https://acme.com bun build ./index.tsx --outdir ./out --env 'ACME_PUBLIC_*'
```

---

title: Adding New Files to Bun Types
description: Demonstrates how to add a new type definition file to the `bun-types` package.  It involves adding the file under `packages/bun-types` and then referencing it in `index.d.ts` using a triple-slash directive.  The `bun build` command is then used to compile the changes.
source: packages/bun-types/README.md#_snippet_1

language: diff
code:
```
+ /// <reference path="./newfile.d.ts" />
```

language: bash
code:
```
bun build
```

---

title: Using External Modules with Zod in Bun Build
description: Illustrates how to use the `external` option to prevent the `zod` package from being included in the bundle. The `import` statement for `zod` is left as-is in the generated bundle, while the `lodash` package (implicitly included) is bundled.
source: docs/bundler/index.md#_snippet_3

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  external: ['zod'],
})
```

language: bash
code:
```
$ bun build ./index.tsx --outdir ./out --external zod
```

language: js
code:
```
import {z} from "zod";

// ...
// the contents of the "lodash" package
// including the `_.upperCase` function

var value = z.string().parse("Hello world!")
console.log(_.upperCase(value));
```

---

title: Specifying Naming Templates with Bun Build
description: Demonstrates how to specify separate naming templates for entrypoints, chunks, and assets when using `Bun.build` with the JavaScript API.  This gives fine-grained control over the naming strategy for different types of output files.
source: docs/bundler/index.md#_snippet_8

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  naming: {
    // default values
    entry: '[dir]/[name].[ext]',
    chunk: '[name]-[hash].[ext]',
    asset: '[name]-[hash].[ext]',
  },
})
```

language: bash
code:
```
$ bun build ./index.tsx --outdir ./out --entry-naming "[dir]/[name].[ext]" --chunk-naming "[name]-[hash].[ext]" --asset-naming "[name]-[hash].[ext]"
```

---

title: Using Workers in Standalone Executables
description: Explains how to include workers in standalone executables by specifying the worker's entrypoint as a CLI argument during the build process with `bun build --compile`. This enables the creation of self-contained applications that utilize worker threads.
source: docs/bundler/executables.md#_snippet_7

language: sh
code:
```
$ bun build --compile ./index.ts ./my-worker.ts --outfile myapp
```

---

title: Defining Macro Export Conditions (package.json)
description: Shows how to use the `macro` export condition in `package.json` to provide a specific version of a package for the macro environment. This allows users to import the package at both runtime and bundle-time using the same import specifier, while resolving to different files.
source: docs/bundler/macros.md#_snippet_2

language: jsonc
code:
```
{
  "name": "my-package",
  "exports": {
    "import": "./index.js",
    "require": "./index.js",
    "default": "./index.js",
    "macro": "./index.macro.js"
  }
}
```

---

title: Applying Styles with CSS
description: Illustrates how to apply CSS styles to a React component in a Bun application. It defines a simple CSS rule to set the background color of the body to red.
source: docs/bundler/fullstack.md#_snippet_4

language: css
code:
```
body {
  background-color: red;
}
```

language: tsx
code:
```
export function App() {
  return <div>Hello World</div>;
}
```

---

title: Registering Yaml Plugin for Runtime Use
description: Demonstrates registering the `bun-plugin-yaml` for runtime use. `Bun.plugin` registers the yaml plugin, which is then preloaded, enabling `.yaml` file processing at runtime.
source: packages/bun-plugin-yaml/README.md#_snippet_3

language: typescript
code:
```
// yaml.ts
import yamlPlugin from "bun-plugin-yaml";

Bun.plugin(yamlPlugin());
```

language: toml
code:
```
preload = ["./yaml.ts"]
```

---

title: Creating Plugin State Using NAPI External
description: Illustrates how to create a plugin state using NAPI's `External` type to communicate data between the native plugin and JavaScript. It defines Rust functions to create and access a thread-safe state (`PluginState`) containing a `foo_count`.
source: packages/bun-native-plugin-rs/README.md#_snippet_4

language: rs
code:
```
struct PluginState {
  foo_count: std::sync::atomic::AtomicU32,
}

#[napi]
pub fn create_plugin_state() -> External<PluginState> {
  let external = External::new(PluginState {
    foo_count: 0,
  });

  external
}


#[napi]
pub fn get_foo_count(plugin_state: External<PluginState>) -> u32 {
  let plugin_state: &PluginState = &plugin_state;
  plugin_state.foo_count.load(std::sync::atomic::Ordering::Relaxed)
}
```

---

title: Passing External State from JavaScript
description: Demonstrates how to pass the NAPI `External` state to the Bun plugin from JavaScript when registering the plugin using the `Bun.build` API. It shows how to call the NAPI module function to create the external and pass it as a configuration option.
source: packages/bun-native-plugin-rs/README.md#_snippet_5

language: js
code:
```
const napiModule = require("path/to/napi_module.node");
const pluginState = napiModule.createPluginState();

const result = await Bun.build({
  entrypoints: ["index.ts"],
  plugins: [
    {
      name: "replace-foo-with-bar",
      setup(build) {
        build.onBeforeParse(
          { filter: /\.ts/ },
          {
            napiModule,
            symbol: "on_before_parse_plugin_impl",
            // pass our NAPI external which contains our plugin state here
            external: pluginState,
          },
        );
      },
    },
  ],
});

console.log("Total `foo`s encountered: ", pluginState.getFooCount());
```

---

title: Extracting External State in Native Plugin
description: Illustrates how to extract and use the NAPI `External` state within the native plugin implementation. It shows how to safely access the `PluginState` and increment the `foo_count` based on the number of `foo` occurrences in the source code.
source: packages/bun-native-plugin-rs/README.md#_snippet_6

language: rs
code:
```
#[bun]
pub fn on_before_parse_plugin_impl(handle: &mut OnBeforeParse) {
    // This operation is only safe if you pass in an external when registering the plugin.
    // If you don't, this could lead to a segfault or access of undefined memory.
  let plugin_state: &PluginState =
     unsafe { handle.external().and_then(|state| state.ok_or(Error::Unknown))? };


  // Fetch our source code again
  let input_source_code = handle.input_source_code()?;

  // Count the number of `foo`s and add it to our state
  let foo_count = source_code.matches("foo").count() as u32;
  plugin_state.foo_count.fetch_add(foo_count, std::sync::atomic::Ordering::Relaxed);
}
```

---

title: Validating Snapshot Nodes
description: Demonstrates the usage of `validateSnapshotNodes` to create a heap dump, an embedder graph copy, and then validate the occurrences of specific nodes.  This is useful for verifying the structure of the heap and ensuring that certain objects are present with the expected relationships.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_0

language: js
code:
```
validateSnapshotNodes('TLSWRAP', [
  { children: [ { name: 'enc_out' }, { name: 'enc_in' }, { name: 'TLSWrap' } ] },
]);
```

---

title: Importing Common Utilities from Harness - TypeScript
description: Lists common import statements from the `harness` module. The module provides utilities for testing, like obtaining the Bun executable path (`bunExe`), setting environment variables (`bunEnv`), creating temporary directories (`tempDirWithFiles`, `tmpdirSync`), checking the platform (`isMacOS`, `isWindows`, `isPosix`), triggering garbage collection (`gcTick`), and disabling aggressive GC (`withoutAggressiveGC`).
source: test/CLAUDE.md#_snippet_4

language: typescript
code:
```
import {
  bunExe, // Path to Bun executable
  bunEnv, // Environment variables for Bun
  tempDirWithFiles, // Create temporary test directories with files
  tmpdirSync, // Create empty temporary directory
  isMacOS, // Platform checks
  isWindows,
  isPosix,
  gcTick, // Trigger garbage collection
  withoutAggressiveGC, // Disable aggressive GC for performance tests
} from "harness";
```

---

title: Formatting Code - Applying Prettier, Zig, and Clang
description: Demonstrates how to format code using Prettier for JavaScript/TypeScript files, zig-format for Zig files, and clang-format for C++ files. These tools help maintain a consistent code style across the project.
source: AGENTS.md#_snippet_4

language: shell
code:
```
bun run prettier
```

language: shell
code:
```
bun run zig-format
```

language: shell
code:
```
bun run clang-format
```

---

title: Creating Dual Exports for CommonJS - JavaScript
description: Illustrates the generation of dual export objects for CommonJS entry points. It creates an internal ESM export object and an external CommonJS export object with the `__esModule` marker using the `__reExport` function.
source: src/bundler/linker_context/README.md#_snippet_3

language: javascript
code:
```
// Internal ESM export object (no __esModule marker):
var exports = {};

// External CommonJS export object (with __esModule marker):
__reExport(exports, targetModule, module.exports); // module.exports gets __esModule
```

---

title: Accessing Private Properties and Intrinsics - Using $ Prefix
description: Illustrates how to access private properties and JavaScriptCore intrinsics within built-in modules using the `$` prefix. The preprocessor converts `$` to `@` for JSC's actual syntax.
source: CLAUDE.md#_snippet_8

language: javascript
code:
```
const arr = $Array.from(...);  // Private global
map.$set(...);                 // Private method
const arr2 = $newArrayWithSize(5); // JSC intrinsic
```

---

title: Loading Modules - Using String Literals in Require()
description: Demonstrates how to load modules within Bun's built-in JavaScript modules using `require()`.  `require()` must use string literals, which are resolved at compile time by numeric ID.
source: CLAUDE.md#_snippet_9

language: javascript
code:
```
const fs = require("fs"); // Directly loads by numeric ID
```

---

title: Using Debug Helpers - Conditional Logging
description: Illustrates the use of `$debug()` for logging and `$assert()` for assertions within Bun's built-in modules.  These are stripped in release builds, improving performance in production.
source: CLAUDE.md#_snippet_10

language: javascript
code:
```
if($debug) {}
```

---

title: Defining Module Exports - Using Export Default
description: Illustrates the usage of `export default` syntax for defining module exports in Bun's built-in JavaScript modules. This is converted to a return statement by the preprocessor.
source: CLAUDE.md#_snippet_11

language: javascript
code:
```
export default {
  readFile,
  writeFile,
};
```

---

title: Processing Parts within Files - JavaScript
description: Illustrates the processing of parts within files, where a file is divided into logical code sections, and each part is processed individually. The example shows two parts: top-level declarations and a conditional export, demonstrating how each part contributes to the final module structure.
source: src/bundler/linker_context/README.md#_snippet_5

language: javascript
code:
```
// Part 1: Top-level declarations
const API_URL = 'https://api.example.com';
function fetchData() { ... }

// Part 2: Conditional export
if (development) {
  export { debugTools };  // Only included if reachable
}
```

---

title: Modifying Bundle Output with `appendFile`
description: Shows how to use `onAfterBundle` with `appendFile` to modify the output bundle. This example appends a `console.log` statement to the end of `/out.js` to print the JSON stringification of the bundled module, which is useful when testing IIFE bundles in combination with `globalName`.
source: test/bundler/expectBundled.md#_snippet_5

language: typescript
code:
```
itBundled("importstar/ReExportStarExternalIIFE", {
  files: {
    "/entry.js": `export * from "foo"`,
  },
  format: "iife",
  globalName: "mod",
  external: ["foo"],
  runtimeFiles: {
    "/node_modules/foo/index.js": /* js */ `
      export const foo = 'foo'
      export const bar = 'bar'
    `,
  },
  onAfterBundle(api) {
    api.appendFile("/out.js", "\nconsole.log(JSON.stringify(mod))");
  },
  run: {
    stdout: '{"bar":"bar","foo":"foo"}',
  },
});
```

---

title: Using Bail with Bun Test
description: Illustrates how to replace the `bail` option in a Jest configuration with the `--bail` CLI flag in `bun test`. This allows you to stop the test suite after a specified number of test failures.
source: docs/guides/test/migrate-from-jest.md#_snippet_5

language: sh
code:
```
$ bun test --bail=3
```

---

title: Using Coverage with Bun Test
description: Illustrates how to replace the `collectCoverage` option in a Jest configuration with the `--coverage` CLI flag in `bun test`. This enables code coverage reporting for your test suite.
source: docs/guides/test/migrate-from-jest.md#_snippet_6

language: sh
code:
```
$ bun test --coverage
```

---

title: Setting Test Timeout with Bun Test
description: Demonstrates how to replace the `testTimeout` option with the `--test-timeout` CLI flag in `bun test`. This sets the maximum time a test can run before it is considered a failure.
source: docs/guides/test/migrate-from-jest.md#_snippet_7

language: sh
code:
```
$ bun test --timeout 10000
```

---

title: Overriding Default CAs for TLS - TypeScript
description: Demonstrates how to override the default Certificate Authorities (CAs) trusted by Bun when establishing TLS connections. By passing an array of certificate files as `ca`, you can specify which CAs the server should trust, enhancing security and control.
source: docs/guides/http/tls.md#_snippet_1

language: typescript
code:
```
const server = Bun.serve({
  fetch: request => new Response("Welcome to Bun!"),
  tls: {
    cert: Bun.file("cert.pem"),
    key: Bun.file("key.pem"),
    ca: [Bun.file("ca1.pem"), Bun.file("ca2.pem")],
  },
});
```

---

title: Defining Environment Variables (bunfig.toml)
description: Illustrates how to define environment variables in a `bunfig.toml` file.  This is useful for configuring your application based on different environments (development, production, etc.).
source: README.md#_snippet_4

language: toml
code:
```
[env]
API_URL = "https://api.example.com"
DEBUG = "true"
```

---

title: Configuring Import Paths with tsconfigjson
description: Defines the `paths` field within a `tsconfig.json` file to remap import paths, which allows for aliasing package names and avoiding long relative paths. This configuration is useful for simplifying imports and improving code readability.
source: docs/guides/runtime/tsconfig-paths.md#_snippet_0

language: json
code:
```
{
  "compilerOptions": {
    "paths": {
      "my-custom-name": ["zod"],
      "@components/*": ["./src/components/*"]
    }
  }
}
```

---

title: Configuring Buffer Size with Highwatermark - TypeScript
description: Demonstrates how to configure the buffer size of the `FileSink` using the `highWaterMark` option. This allows you to control when the buffer auto-flushes to disk, optimizing performance for different use cases.
source: docs/guides/write-file/filesink.md#_snippet_2

language: typescript
code:
```
const file = Bun.file("/path/to/file.txt");
const writer = file.writer({ highWaterMark: 1024 * 1024 }); // 1MB
```

---

title: Configuring Git Attributes for Lockb Files
description: Defines a `gitattributes` configuration that instructs Git to treat `.lockb` files as binary and use a custom diff driver named `lockb`. This setup ensures that Git recognizes `.lockb` files and applies the specified diffing behavior.
source: docs/guides/install/git-diff-bun-lockfile.md#_snippet_0

language: js
code:
```
*.lockb binary diff=lockb
```

---

title: Referencing Environment Variables in TOML Configuration
description: Demonstrates how to reference environment variables within a `bunfig.toml` configuration file. This allows sensitive information, such as tokens, to be securely managed and accessed without hardcoding them directly in the configuration.
source: docs/guides/install/registry-scope.md#_snippet_1

language: toml
code:
```
[install.scopes]
"@myorg3" = { token = "$npm_token", url = "https://registry.myorg.com/" }
```

---

title: Replacing Global with GlobalThis
description: Shows how to replace the `global` identifier with `globalThis` to ensure compatibility across different JavaScript environments (Node.js and browsers).
source: docs/guides/runtime/define-constant.md#_snippet_5

language: sh
code:
```
bun --define global="globalThis" src/index.ts
```

---

title: Configuring Optional Peer Dependencies in Package JSON
description: Explains how to mark a peer dependency as optional using the `peerDependenciesMeta` section in `package.json`.  Setting `optional: true` for `@types/bun` allows installation to proceed even if the peer dependency is not found, providing flexibility in environments where the dependency may not be strictly required.
source: docs/guides/install/add-peer.md#_snippet_2

language: json-diff
code:
```
{
  "peerDependencies": {
    "@types/bun": "^$BUN_LATEST_VERSION"
  },
  "peerDependenciesMeta": {
+   "@types/bun": {
+     "optional": true
+   }
  }

}
```

---

title: Setting Default Yarn Lockfile Behavior (bunfig.toml)
description: Illustrates how to configure Bun to generate a `yarn.lock` file by default. Adding the `[install.lockfile]` section to `bunfig.toml` with `print = "yarn"` ensures that `yarn.lock` is created on every install.
source: docs/guides/install/yarnlock.md#_snippet_1

language: toml
code:
```
[install.lockfile]
print = "yarn"
```

---

title: Configuring Environment-Specific Builds - JSON
description: Illustrates setting up environment-specific builds using different build-time constants defined in `package.json` scripts. Each script defines `NODE_ENV` and `API_URL` for development, staging, and production environments, creating distinct executables.
source: docs/guides/runtime/build-time-constants.md#_snippet_8

language: json
code:
```
{
  "scripts": {
    "build:dev": "bun build --compile --define NODE_ENV='"development"' --define API_URL='"http://localhost:3000"' src/app.ts --outfile app-dev",
    "build:staging": "bun build --compile --define NODE_ENV='"staging"' --define API_URL='"https://staging.example.com"' src/app.ts --outfile app-staging",
    "build:prod": "bun build --compile --define NODE_ENV='"production"' --define API_URL='"https://api.example.com"' src/app.ts --outfile app-prod"
  }
}
```

---

title: Forcing Usage of Bun's Runtime With Shebang
description: This shows how to force the use of Bun's runtime instead of the system's `node` executable when running a script with a shebang.  By passing the `--bun` flag to `bun run`, a symlink to Bun is created and added to the `PATH` for the script's execution.
source: docs/guides/install/from-npm-install-to-bun-install.md#_snippet_8

language: sh
code:
```
# Force using Bun's runtime instead of node
$ bun --bun my-script

# This also works:
$ bun run --bun my-script
```

---

title: Configuring Neon Connection String - Shell
description: Illustrates how to create a `.env.local` file and add the Neon Postgres connection string to it. This configuration allows the application to connect to the Neon database.
source: docs/guides/ecosystem/neon-serverless-postgres.md#_snippet_1

language: shell
code:
```
DATABASE_URL=postgresql://username:password@ep-adj-noun-guid.us-east-1.aws.neon.tech/neondb?sslmode=require
```

---

title: Configuring Docker Ignore File
description: Illustrates the use of a `.dockerignore` file to exclude specific files and directories from the Docker build process. This helps to reduce the size of the Docker image and improve build times by preventing unnecessary files like `node_modules`, development configuration files, and Git-related data from being included.
source: docs/guides/ecosystem/docker.md#_snippet_1

language: txt
code:
```
node_modules
Dockerfile*
docker-compose*
.dockerignore
.git
.gitignore
README.md
LICENSE
.vscode
Makefile
helm-charts
.env
.editorconfig
.idea
coverage*
```

---

title: Updating to Latest Version with Bun
description: Demonstrates how to update dependencies to the latest version, regardless of the version range in `package.json`, using the `--latest` flag. This is useful when you want to use the newest features or bug fixes even if they introduce breaking changes.
source: docs/cli/update.md#_snippet_2

language: shell
code:
```
$ bun update --latest
```

---

title: Upgrading to a Canary Build of Bun
description: Illustrates how to upgrade to a canary build of Bun using the `--canary` flag. This command downloads the latest unstable build from the `canary` release tag on GitHub.
source: docs/cli/bun-upgrade.md#_snippet_1

language: bash
code:
```
$ bun upgrade --canary
```

---

title: Reverting to the Latest Published Bun Version
description: Demonstrates reverting from a canary or other specific version back to the latest published version of Bun. This command utilizes the default `bun upgrade` behavior without any flags.
source: docs/cli/bun-upgrade.md#_snippet_2

language: bash
code:
```
$ bun upgrade
```

---

title: Customizing Github Domain with GITHUB_API_DOMAIN
description: Illustrates how to customize the GitHub API domain that Bun pings for downloads using the `GITHUB_API_DOMAIN` environment variable. This is beneficial for users working behind a proxy or within a GitHub Enterprise environment.
source: docs/cli/bun-create.md#_snippet_5

language: shell
code:
```
`GITHUB_API_DOMAIN=your.github.domain bun create ...`
```

---

title: Authenticating with GitHub Using GITHUB_TOKEN
description: Demonstrates how to use the `GITHUB_TOKEN` environment variable to authenticate with GitHub when using `bun create`. This allows access to private repositories or avoids rate limiting issues during template downloads.
source: docs/cli/bun-create.md#_snippet_6

language: shell
code:
```
`GITHUB_TOKEN=your_github_token bun create ...`
```

---

title: Changing the Test Root Directory Using bunfigtoml
description: Illustrates how to configure the root directory for test discovery in `bunfig.toml`.  The `root` option specifies the directory where Bun will start searching for test files. This is useful for organizing tests within a specific directory structure.
source: docs/test/discovery.md#_snippet_3

language: toml
code:
```
[test]
root = "src"  # Only scan for tests in the src directory
```

---

title: Adding Setup Logic to Local Templates
description: Explains how to specify pre- and post-install setup scripts in the `bun-create` section of a local template's `package.json`. The `preinstall` script runs before installation, and the `postinstall` script runs after, allowing for custom setup logic within the template.
source: docs/cli/bun-create.md#_snippet_6

language: json
code:
```
{
  "name": "@bun-examples/simplereact",
  "version": "0.0.1",
  "main": "index.js",
  "dependencies": {
    "react": "^17.0.2",
    "react-dom": "^17.0.2"
  },
  "bun-create": {
    "preinstall": "echo 'Installing...'", // a single command
    "postinstall": ["echo 'Done!'"], // an array of commands
    "start": "bun run echo 'Hello world!'"
  }
}
```

---

title: Trusting Dependencies to Run Lifecycle Scripts in Bun
description: Demonstrates how to specify trusted dependencies in `package.json` to allow Bun to execute lifecycle scripts, such as `postinstall`. This is useful for packages that require these scripts but are not on Bun's allow-list.
source: docs/cli/add.md#_snippet_8

language: json-diff
code:
```
  {
    "name": "my-app",
    "version": "1.0.0",
+   "trustedDependencies": ["my-trusted-package"]
  }
```

---

title: Clearing Bun Install Cache (Bash)
description: Demonstrates how to clear the Bun install cache by removing the `~/.bun/install/cache` directory. This can be useful for resolving issues related to corrupted or outdated cached packages, forcing Bun to download fresh copies of dependencies.
source: docs/cli/bun-install.md#_snippet_2

language: bash
code:
```
$ rm -rf ~/.bun/install/cache
```

---

title: Installing Dependencies with Symlink Backend (Bash)
description: Demonstrates how to install dependencies using the `symlink` backend with `bun install`. This is typically used for `file:` dependencies and requires using `--preserve-symlinks` flag when running Node.js to ensure proper module resolution.
source: docs/cli/bun-install.md#_snippet_5

language: bash
code:
```
$ rm -rf node_modules
$ bun install --backend symlink
$ node --preserve-symlinks ./my-file.js # https://nodejs.org/api/cli.html#--preserve-symlinks
```

---

title: Running WASM binaries
description: Demonstrates how to execute a WebAssembly (WASM) binary using Bun. This enables running low-level compiled code within the Bun runtime. Bun supports WASI, but it's experimental.
source: docs/runtime/loaders.md#_snippet_3

language: bash
code:
```
$ bun ./my-wasm-app.wasm
# if the filename doesn't end with ".wasm"
$ bun run ./my-wasm-app.whatever
```

---

title: Enabling Quiet Output for AI Agents
description: Illustrates how to enable quieter output for AI coding assistants by setting environment variables such as `CLAUDECODE=1`.  This minimizes test output verbosity, showing only failures while preserving essential summary statistics, enhancing readability and reducing context noise.
source: docs/cli/test.md#_snippet_15

language: bash
code:
```
# Example: Enable quiet output for Claude Code
$ CLAUDECODE=1 bun test

# Still shows failures and summary, but hides verbose passing test output
```

---

title: Configuring Test Discovery - TOML
description: Illustrates how to configure the root directory for test discovery using the `root` option in `bunfig.toml`. This overrides the default behavior, limiting the test runner to scanning only the specified directory (e.g., `src`) for test files.
source: docs/test/configuration.md#_snippet_0

language: toml
code:
```
[test]
root = "src"  # Only scan for tests in the src directory
```

---

title: Ignoring File Patterns in Coverage Reports - TOML
description: Demonstrates how to exclude specific files or file patterns from coverage reports using the `coveragePathIgnorePatterns` option in `bunfig.toml`.  Glob patterns are used to define which files should be excluded from coverage calculation and reporting. This is useful for ignoring test files, utility functions, or configuration files from the coverage analysis.
source: docs/test/configuration.md#_snippet_5

language: toml
code:
```
[test]
# Single pattern
coveragePathIgnorePatterns = "**/*.spec.ts"

# Multiple patterns
coveragePathIgnorePatterns = [
  "**/*.spec.ts",
  "**/*.test.ts",
  "src/utils/**",
  "*.config.js"
]
```

---

title: Using Experimental Decorators - TypeScript
description: Illustrates the use of experimental decorators in TypeScript to modify the behavior of a method. The `@log` decorator logs the arguments passed to the `greet` method, demonstrating a simple example of meta-programming to add functionality without modifying the original method's code.
source: docs/runtime/typescript.md#_snippet_2

language: typescript
code:
```
// Simple logging decorator
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = function(...args: any[]) {
    console.log(`Calling ${propertyKey} with:`, args);
    return originalMethod.apply(this, args);
  };
}

class Example {
  @log
  greet(name: string) {
    return `Hello ${name}!`;
  }
}

// Usage
const example = new Example();
example.greet("world"); // Logs: "Calling greet with: ['world']"
```

---

title: Skipping Test Files in Coverage - Configuration
description: Demonstrates how to exclude test files from coverage reports using the `coverageSkipTestFiles` option in `bunfig.toml`. Setting this option to `true` prevents files matching test patterns (e.g., `*.test.ts`, `__spec.js`) from being included in the coverage calculation and reporting.
source: docs/test/coverage.md#_snippet_2

language: toml
code:
```
[test]
coverageSkipTestFiles = true       # default false
```

---

title: Setting Coverage Thresholds - Configuration
description: Shows how to specify coverage thresholds in `bunfig.toml` to enforce a minimum level of code coverage.  If the test suite's coverage falls below the defined threshold (either globally or for lines, functions, and statements individually), `bun test` will exit with a non-zero exit code.
source: docs/test/coverage.md#_snippet_3

language: toml
code:
```
[test]

# to require 90% line-level and function-level coverage
coverageThreshold = 0.9

# to set different thresholds for lines and functions
coverageThreshold = { lines = 0.9, functions = 0.9, statements = 0.9 }
```

---

title: Excluding Test Files from Coverage - Configuration
description: Demonstrates how to exclude test files from coverage reports using `coverageSkipTestFiles` in `bunfig.toml`. This configuration excludes files matching test patterns (e.g., `_.test.ts`, `__spec.js`) from the coverage report.
source: docs/test/coverage.md#_snippet_5

language: toml
code:
```
[test]
coverageSkipTestFiles = true   # default false
```

---

title: Ignoring Paths and Patterns in Coverage - Configuration
description: Illustrates how to exclude specific files or file patterns from coverage reports using the `coveragePathIgnorePatterns` option in `bunfig.toml`. This option accepts glob patterns to exclude utility files, configuration files, test patterns, and build artifacts from coverage calculation.
source: docs/test/coverage.md#_snippet_6

language: toml
code:
```
[test]
# Single pattern
coveragePathIgnorePatterns = "**/*.spec.ts"

# Multiple patterns
coveragePathIgnorePatterns = [
  "**/*.spec.ts",
  "**/*.test.ts",
  "src/utils/**",
  "*.config.js"
]
```

---

title: Configuring Trusted Dependencies - JSON
description: Shows how to configure trusted dependencies in `package.json` to allow lifecycle scripts to run for specific packages.  By adding a package to `trustedDependencies`, Bun will execute lifecycle scripts for that package during installation, mitigating potential security risks.
source: docs/cli/install.md#_snippet_2

language: json-diff
code:
```
  {

```

language: json-diff
code:
```
    "name": "my-app",
    "version": "1.0.0",
+   "trustedDependencies": ["my-trusted-package"]
  }

```

---

title: Specifying Dependency Overrides - JSON
description: Illustrates how to use npm's `overrides` feature in `package.json` to specify version ranges for metadependencies. This allows you to control the versions of dependencies of your dependencies.
source: docs/cli/install.md#_snippet_6

language: json-diff
code:
```
  {
    "name": "my-app",
    "dependencies": {
      "foo": "^2.0.0"
    },
+   "overrides": {
+     "bar": "~4.4.0"
+   }
  }

```

---

title: Defining Non-npm Dependencies - JSON
description: Demonstrates how to define dependencies from Git, GitHub, and tarballs in `package.json`. Bun supports installing packages directly from these sources, expanding installation options.
source: docs/cli/install.md#_snippet_12

language: json
code:
```
{
  "dependencies": {
    "dayjs": "git+https://github.com/iamkun/dayjs.git",
    "lodash": "git+ssh://github.com/lodash/lodash.git#4.17.21",
    "moment": "git@github.com:moment/moment.git",
    "zod": "github:colinhacks/zod",
    "react": "https://registry.npmjs.org/react/-/react-18.2.0.tgz",
    "bun-types": "npm:@types/bun"
  }
}
```

---

title: Installing with Hoisted Strategy - Bash
description: Illustrates how to use the `hoisted` linker strategy with `bun install`. This is the traditional npm/Yarn approach that flattens dependencies into a shared `node_modules` directory.
source: docs/cli/install.md#_snippet_13

language: bash
code:
```
$ bun install --linker hoisted
```

---

title: Configuring Install Options - TOML
description: Demonstrates how to configure the default behavior of `bun install` using `bunfig.toml`. This file allows you to customize options such as installing optional, dev, or peer dependencies, and enabling production mode.
source: docs/cli/install.md#_snippet_15

language: toml
code:
```
[install]

# whether to install optionalDependencies
optional = true

# whether to install devDependencies
dev = true

# whether to install peerDependencies
peer = true

# equivalent to `--production` flag
production = false

# equivalent to `--save-text-lockfile` flag
saveTextLockfile = false

# equivalent to `--frozen-lockfile` flag
frozenLockfile = false

# equivalent to `--dry-run` flag
dryRun = false

# equivalent to `--concurrent-scripts` flag
concurrentScripts = 16 # (cpu count or GOMAXPROCS) x2

# installation strategy: "hoisted" or "isolated"
# default: "hoisted"
linker = "hoisted"
```

---

title: Running WASM Applications - CLI
description: Shows how to execute WebAssembly (WASM) binaries using Bun. This experimental feature enables developers to run low-level, high-performance code within the Bun runtime, expanding the possibilities for application development.
source: docs/runtime/index.md#_snippet_2

language: bash
code:
```
$ bun ./my-wasm-app.wasm
# if the filename doesn't end with ".wasm"
$ bun run ./my-wasm-app.whatever
```

---

title: Configuring Default Registry in Bunfigtoml
description: Demonstrates setting the default registry for package installation within the `bunfig.toml` configuration file. It illustrates specifying the registry URL as a string, along with options for including a token or username and password for authentication.
source: docs/runtime/bunfig.md#_snippet_0

language: toml
code:
```
[install]
# set default registry as a string
registry = "https://registry.npmjs.org"
# set a token
registry = { url = "https://registry.npmjs.org", token = "123456" }
# set a username/password
registry = "https://username:password@registry.npmjs.org"
```

---

title: Configuring CA Certificates in Bunfigtoml
description: Illustrates setting up a CA certificate using `install.ca` or `install.cafile` in `bunfig.toml`. It demonstrates specifying the certificate directly as a string or providing a path to a CA certificate file.
source: docs/runtime/bunfig.md#_snippet_3

language: toml
code:
```
[install]
# The CA certificate as a string
ca = "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"

# A path to a CA certificate file. The file can contain multiple certificates.
cafile = "path/to/cafile"
```

---

title: Using Interface Merging for TypeScript Autocompletion
description: Demonstrates how to use interface merging in TypeScript to provide autocompletion and type checking for environment variables. By declaring a module, you can add properties to the `Bun.Env` interface, treating the variable as a non-optional string.
source: docs/runtime/env.md#_snippet_8

language: ts
code:
```
declare module "bun" {
  interface Env {
    AWESOME: string;
  }
}
process.env.AWESOME; // => string
```

---

title: Configuring Package Entrypoints Using Exports - JSON
description: Demonstrates how to define conditional exports in `package.json` to specify different entry points for various environments. This allows a package to provide optimized or environment-specific modules, enhancing compatibility and performance.
source: docs/runtime/modules.md#_snippet_6

language: jsonc
code:
```
{
  "name": "foo",
  "exports": {
    "bun": "./index.js",
    "node": "./index.js",
    "require": "./index.js", // if importer is CommonJS
    "import": "./index.mjs", // if importer is ES module
    "default": "./index.js",
  }
}
```

---

title: Defining Subpath Exports - JSON
description: Illustrates how to define subpath exports in `package.json` to control which files within a package can be imported.  Specifying any subpath in the `exports` map will prevent other subpaths from being importable, enforcing a controlled API surface for the package.
source: docs/runtime/modules.md#_snippet_7

language: jsonc
code:
```
{
  "name": "foo",
  "exports": {
    ".": "./index.js"
  }
}
```

---

title: Skipping Tests with Test.skip in Bun:test
description: Illustrates how to skip a test using `test.skip` in `bun:test`. Skipped tests are not executed, allowing you to temporarily disable tests that are failing or not yet implemented. It imports `expect` and `test` from `bun:test`.
source: docs/test/writing.md#_snippet_5

language: ts
code:
```
import { expect, test } from "bun:test";

test.skip("wat", () => {
  // TODO: fix this
  expect(0.1 + 0.2).toEqual(0.3);
});
```

---

title: Running Tests Conditionally with Test.if in Bun:test
description: Illustrates how to conditionally run a test based on a truthy condition using `test.if()` in `bun:test`.  This is useful for running tests only on specific architectures or operating systems.  The code shows running the test if a random number is greater than 0.5 and if the operating system is MacOS.
source: docs/test/writing.md#_snippet_8

language: ts
code:
```
test.if(Math.random() > 0.5)("runs half the time", () => {
  // ...
});

const macOS = process.arch === "darwin";
test.if(macOS)("runs on macOS", () => {
  // runs if macOS
});
```

---

title: Creating Virtual Modules at Runtime
description: Explains how to create virtual modules at runtime using `builder.module(specifier, callback)` within a Bun plugin's `setup` function.  Demonstrates creating both a transpiled JavaScript module and a module that exports a JavaScript object, showcasing the flexibility of the `loader` option.
source: docs/runtime/plugins.md#_snippet_7

language: js
code:
```
import { plugin } from "bun";

plugin({
  name: "my-virtual-module",

  setup(build) {
    build.module(
      // The specifier, which can be any string - except a built-in, such as "buffer"
      "my-transpiled-virtual-module",
      // The callback to run when the module is imported or required for the first time
      () => {
        return {
          contents: "console.log('hello world!')",
          loader: "js",
        };
      },
    );

    build.module("my-object-virtual-module", () => {
      return {
        exports: {
          foo: "bar",
        },
        loader: "object",
      };
    });
  },
});

// Sometime later
// All of these work
import "my-transpiled-virtual-module";
require("my-transpiled-virtual-module");
await import("my-transpiled-virtual-module");
require.resolve("my-transpiled-virtual-module");

import { foo } from "my-object-virtual-module";
const object = require("my-object-virtual-module");
await import("my-object-virtual-module");
require.resolve("my-object-virtual-module");
```

---

title: Using Prop Punning in JSX
description: Demonstrates prop punning in JSX, a shorthand syntax for assigning a variable to a prop with the same name.  This simplifies the code by allowing you to write `<div {className} />` instead of `<div className={className} />`.
source: docs/runtime/jsx.md#_snippet_9

language: tsx
code:
```
function Div(props: {className: string;}) {
  const {className} = props;

  // without punning
  return <div className={className} />;
  // with punning
  return <div {className} />;
}
```

---

title: Getting DNS Cache Statistics - Node.js
description: Demonstrates how to retrieve DNS cache statistics using the experimental `dns.getCacheStats` API in Bun.  The returned object provides metrics like cache hits, misses, size, errors, and total connection count. The import statement makes the `dns` module available.
source: docs/api/dns.md#_snippet_3

language: ts
code:
```
import { dns } from "bun";

const stats = dns.getCacheStats();
console.log(stats);
// => { cacheHitsCompleted: 0, cacheHitsInflight: 0, cacheMisses: 0, size: 0, errors: 0, totalCount: 0 }
```

---

title: Disabling Prepared Statements - Bun SQL
description: Illustrates how to disable prepared statements in Bun's SQL client by setting `prepare: false` in the connection options. Disabling prepared statements can be useful when using PGBouncer in transaction mode or when debugging query execution plans, but may impact performance for frequently executed queries.
source: docs/api/sql.md#_snippet_2

language: typescript
code:
```
const sql = new SQL({
  // ... other options ...
  prepare: false, // Disable persisting named prepared statements on the server
});
```

---

title: Enabling Per-Message Compression
description: Illustrates how to enable per-message compression for WebSocket connections using the `perMessageDeflate` parameter in `Bun.serve`. This can reduce the size of messages sent over the WebSocket, improving performance.
source: docs/api/websockets.md#_snippet_8

language: typescript
code:
```
Bun.serve({
  fetch(req, server) {}, // upgrade logic
  websocket: {
    // enable compression and decompression
    perMessageDeflate: true,
  },
});
```

---

title: Disabling Error Throwing - JavaScript
description: Demonstrates how to disable automatic error throwing for non-zero exit codes using `.nothrow()` in Bun Shell.  This requires manually checking the `exitCode` property of the result to determine if the command was successful.
source: docs/runtime/shell.md#_snippet_6

language: js
code:
```
import { $ } from "bun";

const { stdout, stderr, exitCode } = await $`something-that-may-fail`
  .nothrow()
  .quiet();

if (exitCode !== 0) {
  console.log(`Non-zero exit code ${exitCode}`);
}

console.log(stdout);
console.log(stderr);
```

---

title: Handling Backpressure in UDP Sockets - TypeScript
description: Explains how to handle backpressure when sending UDP packets. If `send` returns `false` or `sendMany` returns a number smaller than expected, the `drain` socket handler is called when the socket becomes writable again, allowing for continuation of data sending.
source: docs/api/udp.md#_snippet_6

language: typescript
code:
```
const socket = await Bun.udpSocket({
  socket: {
    drain(socket) {
      // continue sending data
    },
  },
});
```

---

title: Implementing Savepoints in Transactions - TypeScript
description: Illustrates how to use savepoints within a transaction to create intermediate checkpoints, enabling partial rollbacks without affecting the entire operation. Shows usage of `tx.savepoint` and how a rollback can be triggered within the savepoint block. Demonstrates insert and update statements within a transaction.
source: docs/api/sql.md#_snippet_5

language: typescript
code:
```
await sql.begin(async tx => {
  await tx`INSERT INTO users (name) VALUES (${'Alice'})`;

  await tx.savepoint(async sp => {
    // This part can be rolled back separately
    await sp`UPDATE users SET status = 'active'`;
    if (someCondition) {
      throw new Error("Rollback to savepoint");
    }
  });

  // Continue with transaction even if savepoint rolled back
  await tx`INSERT INTO audit_log (action) VALUES ('user_created')`;
});
```

---

title: Estimating Shallow Memory Usage
description: Illustrates how to use `estimateShallowMemoryUsageOf` from `bun:jsc` to get a best-effort estimate of the memory usage of an object in bytes, excluding referenced objects. It provides examples with an object, a Buffer, a Request object, and an Array.
source: docs/api/utils.md#_snippet_10

language: js
code:
```
import { estimateShallowMemoryUsageOf } from
```

---

title: Formatting Query Results as Arrays of Buffers - TypeScript
description: Illustrates how to use the `.raw()` method to retrieve query results as arrays of `Buffer` objects using Bun's SQL client. This is useful when working with binary data or when performance is critical. Each row is returned as an array of `Buffer` objects, representing the raw byte data for each column.
source: docs/api/sql.md#_snippet_5

language: ts
code:
```
const rows = await sql`SELECT * FROM users`.raw();
console.log(rows); // [[Buffer, Buffer], [Buffer, Buffer], [Buffer, Buffer]]
```

---

title: Executing Multiple Statements with Simple Queries - TypeScript
description: Demonstrates how to execute multiple SQL statements in a single query using `sql``.simple()` in Bun's SQL client. Simple queries cannot use parameters but are useful for executing multiple statements like those found in database migrations or setup scripts. Note that the extended queries (the default) support parameters but only allow one statement.
source: docs/api/sql.md#_snippet_10

language: ts
code:
```
// Multiple statements in one query
await sql`
  SELECT 1;
  SELECT 2;
`.simple();
```

---

title: Generating Uuid V7 As Buffer - Typescript
description: Demonstrates how to generate a UUID v7 as a 16-byte buffer instead of a string using `Bun.randomUUIDv7('buffer')`.  Using a buffer can avoid string conversion overhead.
source: docs/api/utils.md#_snippet_9

language: typescript
code:
```
const buffer = Bun.randomUUIDv7("buffer");
```

---

title: Generating Base64 And Base64Url Uuid V7 - Typescript
description: Shows how to generate UUID v7 strings encoded as base64 and base64url using `Bun.randomUUIDv7()`. This can be used to generate shorter strings compared to the default hexadecimal encoding.
source: docs/api/utils.md#_snippet_10

language: typescript
code:
```
const base64 = Bun.randomUUIDv7("base64");
const base64url = Bun.randomUUIDv7("base64url");
```

---

title: Overriding Editor In Bunfig Toml
description: Shows how to override the default editor used by `Bun.openInEditor()` by specifying the `debug.editor` setting in `bunfig.toml`. This provides a project-specific editor configuration.
source: docs/api/utils.md#_snippet_13

language: toml-diff
code:
```
+ [debug]
+ editor = "code"
```

---

title: Passing a Pointer With Specific Offset - Bun:ffi
description: Illustrates how to directly get a pointer to a `TypedArray` using the `ptr` function from `bun:ffi`, allowing for passing a pointer to a specific byte offset. The `encode_png` function is called with the pointer, width, and height, enabling more precise control over memory access.
source: docs/api/ffi.md#_snippet_6

language: typescript
code:
```
import { dlopen, FFIType, ptr } from "bun:ffi";

const {
  symbols: { encode_png },
} = dlopen(myLibraryPath, {
  encode_png: {
    // FFIType's can be specified as strings too
    args: ["ptr", "u32", "u32"],
    returns: FFIType.ptr,
  },
});

const pixels = new Uint8ClampedArray(128 * 128 * 4);
pixels.fill(254);

// this returns a number! not a BigInt!
const myPtr = ptr(pixels);

const out = encode_png(
  myPtr,

  // dimensions:
  128,
  128,
);
```

---

title: Configuring Object Inspection Depth - JavaScript
description: Demonstrates how to configure the depth of nested objects displayed in `console.log()` using the `--console-depth` CLI flag and the `console.depth` setting in `bunfig.toml`. The CLI flag overrides the configuration file setting, allowing for flexible control over object inspection.
source: docs/api/console.md#_snippet_0

language: js
code:
```
const nested = { a: { b: { c: { d: "deep" } } } };
console.log(nested);
// Default (depth 2): { a: { b: [Object] } }
// With depth 4: { a: { b: { c: { d: 'deep' } } } }
```

---

title: Buffering Data with ArrayBufferSink
description: Demonstrates how to use `ArrayBufferSink` for buffering data when writing to a TCP socket in Bun.  This improves performance by reducing the number of individual `socket.write` calls, which is especially important as Bun's TCP sockets currently do not buffer data automatically. It illustrates the use of `flush` and `subarray` for handling backpressure.
source: docs/api/tcp.md#_snippet_9

language: typescript
code:
```
import { ArrayBufferSink } from "bun";

const sink = new ArrayBufferSink();
sink.start({ stream: true, highWaterMark: 1024 });

sink.write("h");
sink.write("e");
sink.write("l");
sink.write("l");
sink.write("o");

queueMicrotask(() => {
  const data = sink.flush();
  const wrote = socket.write(data);
  if (wrote < data.byteLength) {
    // put it back in the sink if the socket is full
    sink.write(data.subarray(wrote));
  }
});
```

---

title: Specifying Linked Libraries with `cc`
description: Illustrates how to specify linked libraries for C code compiled with `bun:ffi`'s `cc` function. The `library` array in the `cc` configuration allows linking external C libraries like `sqlite3` to the compiled code.
source: docs/api/cc.md#_snippet_3

language: typescript
code:
```
type Library = string[];

cc({
  source: "hello.c",
  library: ["sqlite3"],
});
```

---

title: Defining Preprocessor Definitions with `cc`
description: Illustrates how to define preprocessor definitions for the TinyCC compiler using `bun:ffi`'s `cc` function. The `define` property accepts a record of key-value pairs that are passed as preprocessor definitions during compilation.
source: docs/api/cc.md#_snippet_7

language: typescript
code:
```
type Defines = Record<string, string>;

cc({
  source: "hello.c",
  define: {
    "NDEBUG": "1",
  },
});
```

---

title: Handling Out-Of-Range Bigint Errors
description: Illustrates how `bun:sqlite` throws an error when `safeIntegers` is `true` and a `bigint` value in a bound parameter exceeds 64 bits. This ensures that data integrity is maintained by preventing out-of-range values from being inserted into the database.
source: docs/api/sqlite.md#_snippet_8

language: typescript
code:
```
import { Database } from "bun:sqlite";

const db = new Database(":memory:", { safeIntegers: true });
db.run("CREATE TABLE test (id INTEGER PRIMARY KEY, value INTEGER)");

const query = db.query("INSERT INTO test (value) VALUES ($value)");

try {
  query.run({ $value: BigInt(Number.MAX_SAFE_INTEGER) ** 2n });
} catch (e) {
  console.log(e.message); // => BigInt value '81129638414606663681390495662081' is out of range
}
```

---

title: Nesting Transactions - With Savepoints
description: Demonstrates how nested transactions are supported using savepoints.  The inner transaction is handled as a savepoint within the outer transaction, providing granular control over transaction management.
source: docs/api/sqlite.md#_snippet_12

language: typescript
code:
```
// setup
import { Database } from "bun:sqlite";
const db = Database.open(":memory:");
db.run(
  "CREATE TABLE expenses (id INTEGER PRIMARY KEY AUTOINCREMENT, note TEXT, dollars INTEGER);",
);
db.run(
  "CREATE TABLE cats (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT UNIQUE, age INTEGER)",
);
const insertExpense = db.prepare(
  "INSERT INTO expenses (note, dollars) VALUES (?, ?)",
);
const insert = db.prepare("INSERT INTO cats (name, age) VALUES ($name, $age)");
const insertCats = db.transaction(cats => {
  for (const cat of cats) insert.run(cat);
});

const adopt = db.transaction(cats => {
  insertExpense.run("adoption fees", 20);
  insertCats(cats); // nested transaction
});

adopt([
  { $name: "Joey", $age: 2 },
  { $name: "Sally", $age: 4 },
  { $name: "Junior", $age: 1 },
]);
```

---

title: Enabling Strict Mode for Parameter Binding
description: Explains how to enable strict mode in `bun:sqlite` using the `strict: true` option when creating a `Database` instance. Strict mode enforces the use of parameter prefixes (`$`, `:`, `@`) and throws an error if a parameter is missing during query execution. The example demonstrates the behavior with and without strict mode enabled, highlighting the importance of correct parameter naming.
source: docs/api/sqlite.md#_snippet_5

language: ts
code:
```
import { Database } from "bun:sqlite";

const strict = new Database(
  ":memory:",
  { strict: true }
);

// throws error because of the typo:
const query = strict
  .query("SELECT $message;")
  .all({ message: "Hello world" });

const notStrict = new Database(
  ":memory:"
);
// does not throw error:
notStrict
  .query("SELECT $message;")
  .all({ message: "Hello world" });
```

---

title: Binding Values Without Prefixes (Strict Mode)
description: Explains how to bind values to named parameters without the `$`, `:`, or `@` prefixes when `strict: true` is set in the `Database` constructor. The snippet demonstrates this usage, highlighting the importance of the `strict` option.
source: docs/api/sqlite.md#_snippet_14

language: ts
code:
```
import { Database } from "bun:sqlite";

const db = new Database(":memory:", {
  // bind values without prefixes
  strict: true,
});

const query = db.query(`select $message;`);

// strict: true
query.all({ message: "Hello world" });

// strict: false
// query.all({ $message: "Hello world" });
```

---

title: Declaring Self in Worker Thread - TypeScript
description: Shows how to declare `self` to avoid TypeScript errors in worker threads. This is needed because the `self` global is specific to the worker environment and not known to the TypeScript compiler by default.
source: docs/api/workers.md#_snippet_2

language: ts
code:
```
declare var self: Worker;
```

---

title: Unreferencing a Worker
description: Illustrates how to stop a running worker from keeping the main process alive using `worker.unref()`. This decouples the lifetime of the worker from the main process.
source: docs/api/workers.md#_snippet_12

language: ts
code:
```
const worker = new Worker(new URL("worker.ts", import.meta.url).href);
worker.unref();
```

---

title: Referencing a Worker
description: Demonstrates how to keep the process alive until the `Worker` terminates by calling `worker.ref()`. A ref'd worker is the default behavior.
source: docs/api/workers.md#_snippet_13

language: ts
code:
```
const worker = new Worker(new URL("worker.ts", import.meta.url).href);
worker.unref();
// later...
worker.ref();
```

---

title: Creating a Worker with Ref Option
description: Demonstrates how to create a Worker and set `ref` option to false. A worker with `ref` set to false will allow the process to exit without waiting for the worker to finish.
source: docs/api/workers.md#_snippet_14

language: ts
code:
```
const worker = new Worker(new URL("worker.ts", import.meta.url).href, {
  ref: false,
});
```

---

title: Ignoring Scripts During Installation - CLI
description: Demonstrates how to use the `--ignore-scripts` flag with the `bun install` command. This flag disables the execution of lifecycle scripts for all packages during the installation process, providing a way to mitigate potential security risks or avoid unwanted script execution.
source: docs/install/lifecycle.md#_snippet_2

language: bash
code:
```
$ bun install --ignore-scripts
```

---

title: Configuring Install Cache Behavior - TOML
description: Demonstrates how to configure Bun's install cache behavior using a `bunfig.toml` file. It illustrates settings such as the cache directory (`dir`), disabling the global cache (`disable`), and disabling manifest resolution (`disableManifest`). These settings control how Bun manages and uses its package cache.
source: docs/install/cache.md#_snippet_0

language: toml
code:
```
[install.cache]
# the directory to use for the cache
dir = "~/.bun/install/cache"

# when true, don't load from the global cache.
# Bun may still write to node_modules/.cache
disable = false

# when true, always resolve the latest versions from the registry
disableManifest = false
```

---

title: Running with Preserve Symlinks - Bash
description: Demonstrates how to run a Node.js script with the `--preserve-symlinks` flag after installing dependencies with the `symlink` backend.  This is necessary for Node.js to resolve dependencies correctly when using symlinks for `node_modules`. Bun's runtime doesn't have an equivalent flag.
source: docs/install/cache.md#_snippet_2

language: bash
code:
```
$ node --preserve-symlinks ./foo.js
```

---

title: Creating a Thread-Safe Callback With JSCallback
description: Shows how to enable thread-safe callbacks using the optional `threadsafe` parameter in the `JSCallback` constructor. This feature is needed if you pass a callback function into a different thread from its instantiation context and currently works best when run from another thread that is running JavaScript code, such as a `Worker`.
source: docs/api/ffi.md#_snippet_10

language: typescript
code:
```
const searchIterator = new JSCallback(
  (ptr, length) => /hello/.test(new CString(ptr, length)),
  {
    returns: "bool",
    args: ["ptr", "usize"],
    threadsafe: true, // Optional. Defaults to `false`
  },
);
```

---

title: Configuring Yarn Lockfile Generation in bunfigtoml
description: Shows how to configure `bun` to generate a Yarn lockfile alongside the `bun.lock` file. This is done by setting the `install.lockfile.print` property to `yarn` in the `bunfig.toml` configuration file.
source: docs/install/lockfile.md#_snippet_3

language: toml
code:
```
[install.lockfile]
# whether to save a non-Bun lockfile alongside bun.lock
# only "yarn" is supported
print = "yarn"
```

---

title: Enabling Verbose Logging for Debugging Installs
description: Illustrates how to enable verbose logging during the installation process to understand the steps taken by the isolated install strategy.  This provides detailed information about store entry creation, symlink operations, peer dependency resolution, and deduplication decisions, aiding in troubleshooting and debugging.  The `--verbose` flag provides insights into the installation process.
source: docs/install/isolated.md#_snippet_4

language: bash
code:
```
$ bun install --linker isolated --verbose
```

---

title: Fetching a URL with a Timeout
description: Demonstrates how to set a timeout for a `fetch` request using `AbortSignal.timeout` in Bun. This prevents requests from running indefinitely, improving the robustness of applications.
source: docs/api/fetch.md#_snippet_5

language: typescript
code:
```
const response = await fetch("http://example.com", {
  signal: AbortSignal.timeout(1000),
});
```

---

title: Canceling a Request Using AbortController
description: Illustrates how to cancel an ongoing `fetch` request using an `AbortController` in Bun. This is useful for scenarios where a request is no longer needed or is taking too long to complete.
source: docs/api/fetch.md#_snippet_6

language: typescript
code:
```
const controller = new AbortController();

const response = await fetch("http://example.com", {
  signal: controller.signal,
});

controller.abort();
```

---

title: Aborting a Subprocess Using AbortSignal
description: Demonstrates how to abort a subprocess using an `AbortSignal`. An `AbortController` is used to create a signal, which is then passed to `Bun.spawn`. Calling `controller.abort()` terminates the process.
source: docs/api/spawn.md#_snippet_9

language: typescript
code:
```
const controller = new AbortController();
const { signal } = controller;

const proc = Bun.spawn({
  cmd: ["sleep", "100"],
  signal,
});

// Later, to abort the process:
controller.abort();
```

---

title: Setting a Timeout for a Subprocess
description: Shows how to set a timeout for a subprocess, causing it to terminate automatically after a specified duration. By default, timed-out processes are killed with `SIGTERM` signal. Additionally, illustrates setting a custom `killSignal`.
source: docs/api/spawn.md#_snippet_10

language: typescript
code:
```
// Kill the process after 5 seconds
const proc = Bun.spawn({
  cmd: ["sleep", "10"],
  timeout: 5000, // 5 seconds in milliseconds
});

await proc.exited; // Will resolve after 5 seconds
```

language: typescript
code:
```
// Kill the process with SIGKILL after 5 seconds
const proc = Bun.spawn({
  cmd: ["sleep", "10"],
  timeout: 5000,
  killSignal: "SIGKILL", // Can be string name or signal number
});
```

---

title: Limiting Output with maxBuffer
description: Shows how to use `maxBuffer` to limit the number of bytes of output before a process is killed. This is only available with `Bun.spawnSync`.
source: docs/api/spawn.md#_snippet_11

language: typescript
code:
```
// KIll 'yes' after it emits over 100 bytes of output
const result = Bun.spawnSync({
  cmd: ["yes"], // or ["bun", "exec", "yes"] on windows
  maxBuffer: 100,
});
// process exits
```

---

title: Reloading Static Routes in Bun Serve
description: Demonstrates how to update static routes in a `Bun.serve` instance without restarting the server using `server.reload()`. This example updates the time every second and shows how the old routes are freed from memory after in-flight requests are finished.
source: docs/api/http.md#_snippet_6

language: typescript
code:
```
const server = Bun.serve({
  static: {
    "/api/time": new Response(new Date().toISOString()),
  },

  fetch(req) {
    return new Response("404!");
  },
});

// Update the time every second.
setInterval(() => {
  server.reload({
    static: {
      "/api/time": new Response(new Date().toISOString()),
    },

    fetch(req) {
      return new Response("404!");
    },
  });
}, 1000);
```

---

title: Implementing Hot Route Reloading with Bun Serve
description: Shows how to update routes in a running `Bun.serve` instance without restarting the server by using `server.reload()`.  This allows for deploying new routes without any downtime.
source: docs/api/http.md#_snippet_11

language: typescript
code:
```
const server = Bun.serve({
  routes: {
    "/api/version": () => Response.json({ version: "1.0.0" }),
  },
});

// Deploy new routes without downtime
server.reload({
  routes: {
    "/api/version": () => Response.json({ version: "2.0.0" }),
  },
});
```

---

title: Importing Html for Full-Stack App
description: Demonstrates how Bun supports importing HTML files directly into server code, enabling full-stack applications. It highlights development with hot module replacement (HMR) and production with optimized asset serving through pre-built manifest object.
source: docs/api/http.md#_snippet_13

language: typescript
code:
```
import myReactSinglePageApp from "./index.html";

Bun.serve({
  routes: {
    "/": myReactSinglePageApp,
  },
});
```

---

title: Configuring Installation Behavior Using bunfigtoml
description: Demonstrates how to configure the default behavior of `bun install` using a `bunfig.toml` file.  The configuration allows specifying whether to install optional, dev, or peer dependencies, and whether to enable production mode or frozen lockfiles.
source: docs/install/index.md#_snippet_5

language: toml
code:
```
[install]

# whether to install optionalDependencies
optional = true

# whether to install devDependencies
dev = true

# whether to install peerDependencies
peer = true

# equivalent to `--production` flag
production = false

# equivalent to `--save-text-lockfile` flag
saveTextLockfile = false

# equivalent to `--frozen-lockfile` flag
frozenLockfile = false

# equivalent to `--dry-run` flag
dryRun = false

# equivalent to `--concurrent-scripts` flag
concurrentScripts = 16 # (cpu count or GOMAXPROCS) x2

# installation strategy: "hoisted" or "isolated"
# default: "hoisted"
linker = "hoisted"
```

---

title: Specifying Git Dependencies in packagejson
description: Illustrates how to define dependencies in `package.json` that point directly to Git repositories. Bun supports various protocols, including `github`, `git`, `git+ssh`, and `git+https`, allowing you to install packages directly from Git.
source: docs/install/index.md#_snippet_13

language: json
code:
```
{
  "dependencies": {
    "dayjs": "git+https://github.com/iamkun/dayjs.git",
    "lodash": "git+ssh://github.com/lodash/lodash.git#4.17.21",
    "moment": "git@github.com:moment/moment.git",
    "zod": "github:colinhacks/zod"
  }
}
```

---

title: Creating a Plugin to Lowercase HTML Tags - TypeScript
description: Demonstrates the creation of a custom Bun plugin that converts all HTML tags to lowercase. It uses `HTMLRewriter` to transform the HTML content during the build process. The `onLoad` hook is used to process `.html` files, rewriting the content and setting the loader to 'html', which allows Bun's bundler to scan the transformed HTML for assets.
source: docs/bundler/html.md#_snippet_8

language: ts
code:
```
await Bun.build({
  entrypoints: ["./index.html"],
  outdir: "./dist",
  minify: true,

  plugins: [
    {
      // A plugin that makes every HTML tag lowercase
      name: "lowercase-html-plugin",
      setup({ onLoad }) {
        const rewriter = new HTMLRewriter().on("*", {
          element(element) {
            element.tagName = element.tagName.toLowerCase();
          },
          text(element) {
            element.replace(element.text.toLowerCase());
          },
        });

        onLoad({ filter: /\.html$/ }, async args => {
          const html = await Bun.file(args.path).text();

          return {
            // Bun's bundler will scan the HTML for <script> tags, <link rel="stylesheet"> tags, and other assets
            // and bundle them automatically
            contents: rewriter.transform(html),
            loader: "html",
          };
        });
      },
    },
  ],
});
```

---

title: Selecting a Random Port
description: Demonstrates how to configure `Bun.serve` to listen on a random available port by setting the `port` option to `0`. It also shows how to access the selected port using the `server.port` and `server.url` properties after the server has started. This is useful for dynamic port allocation, especially in testing environments.
source: docs/api/http.md#_snippet_6

language: typescript
code:
```
const server = Bun.serve({
  port: 0, // random port
  fetch(req) {
    return new Response("404!");
  },
});

// server.port is the randomly selected port
console.log(server.port);
```

language: typescript
code:
```
console.log(server.port); // 3000
console.log(server.url); // http://localhost:3000
```

---

title: Listening on a Unix Domain Socket
description: Illustrates how to configure `Bun.serve` to listen on a Unix domain socket using the `unix` option. It shows how to specify the path to the socket file. This is useful for inter-process communication and can offer performance benefits compared to TCP sockets in some scenarios.
source: docs/api/http.md#_snippet_7

language: typescript
code:
```
Bun.serve({
  unix: "/tmp/my-socket.sock", // path to socket
  fetch(req) {
    return new Response(`404!`);
  },
});
```

---

title: Avoiding Invalid HMR Usage-ts
description: Demonstrates invalid patterns of using the `import.meta.hot` API, which involve assigning `import.meta.hot` or `import.meta` to variables or passing it to functions. It highlights that the full phrase `import.meta.hot.<API>` must be called directly for Bun to properly handle HMR in production.
source: docs/bundler/hmr.md#_snippet_2

language: ts
code:
```
// INVALID: Assigning `hot` to a variable
const hot = import.meta.hot;
hot.accept();

// INVALID: Assigning `import.meta` to a variable
const meta = import.meta;
meta.hot.accept();
console.log(meta.hot.data);

// INVALID: Passing to a function
doSomething(import.meta.hot.dispose);

// OK: The full phrase "import.meta.hot.<API>" must be called directly:
import.meta.hot.accept();

// OK: `data` can be passed to functions:
doSomething(import.meta.hot.data);
```

---

title: Tracking and Reporting Unused Exports Using defer() - Typescript
description: Illustrates how to use the `defer()` function within the `onLoad` callback to ensure all modules are loaded before processing. This plugin tracks imports in TypeScript files and then generates a `stats.json` file containing import statistics after all files have been processed. This is useful for identifying unused exports and optimizing the bundle.
source: docs/bundler/plugins.md#_snippet_6

language: ts
code:
```
import { plugin } from "bun";

plugin({
  name: "track imports",
  setup(build) {
    const transpiler = new Bun.Transpiler();

    let trackedImports: Record<string, number> = {};

    // Each module that goes through this onLoad callback
    // will record its imports in `trackedImports`
    build.onLoad({ filter: /\.ts/ }, async ({ path }) => {
      const contents = await Bun.file(path).arrayBuffer();

      const imports = transpiler.scanImports(contents);

      for (const i of imports) {
        trackedImports[i.path] = (trackedImports[i.path] || 0) + 1;
      }

      return undefined;
    });

    build.onLoad({ filter: /stats\.json/ }, async ({ defer }) => {
      // Wait for all files to be loaded, ensuring
      // that every file goes through the above `onLoad()` function
      // and their imports tracked
      await defer();

      // Emit JSON containing the stats of each import
      return {
        contents: `export default ${JSON.stringify(trackedImports)}`,
        loader: "json",
      };
    });
  },
});
```

---

title: Configuring Idle Timeout - Bun Serve
description: Demonstrates setting the `idleTimeout` option in `Bun.serve`. This option specifies the maximum number of seconds a connection can be idle before the server closes it.
source: docs/api/http.md#_snippet_0

language: typescript
code:
```
Bun.serve({
  // 10 seconds:
  idleTimeout: 10,

  fetch(req) {
    return new Response("Bun!");
  },
});
```

---

title: Controlling Process Lifecycle with Ref and Unref
description: Illustrates how to control the Bun process lifecycle using `server.ref()` and `server.unref()`. `server.unref()` prevents the server from keeping the process alive if it's the only thing running, while `server.ref()` restores the default behavior.
source: docs/api/http.md#_snippet_5

language: typescript
code:
```
// Don't keep process alive if server is the only thing running
server.unref();

// Restore default behavior - keep process alive
server.ref();
```

---

title: Removing Function Calls from a Bun Bundle
description: Demonstrates how to remove function calls from a bundle using the `drop` option in `Bun.build`. This is useful for removing `console.log` statements or `debugger` statements from production builds.
source: docs/bundler/index.md#_snippet_5

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  drop: ["console", "debugger", "anyIdentifier.or.propertyAccess"],
})
```

language: CLI
code:
```
$ bun build ./index.tsx --outdir ./out --drop=console --drop=debugger --drop=anyIdentifier.or.propertyAccess
```

---

title: Configuring Project Root with Bun Build
description: Demonstrates how to configure the root directory of the project using the `root` option in `Bun.build`. By default, the first common ancestor of all entrypoint files is used as the root, but this can be overridden to control the output file structure.
source: docs/bundler/index.md#_snippet_9

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./pages/a.tsx', './pages/b.tsx'],
  outdir: './out',
  root: '.',
})
```

language: bash
code:
```
n/a
```

---

title: Acting as the Bun CLI
description: Explains how to use the `BUN_BE_BUN=1` environment variable to make a standalone executable act as the `bun` CLI itself. This enables the executable to utilize Bun's CLI features like installing packages or bundling dependencies.
source: docs/bundler/executables.md#_snippet_4

language: sh
code:
```
$ cat such-bun.js
console.log("you shouldn't see this");

$ bun build --compile ./such-bun.js
```

language: sh
code:
```
$ ./such-bun install
you shouldn't see this

# With the env var, the executable acts like the `bun` CLI
$ BUN_BE_BUN=1 ./such-bun install
bun install v1.2.16-canary.1 (1d1db811)
Checked 63 installs across 64 packages (no changes) [5.00ms]
```

---

title: Declaring Internal Types
description: Illustrates how to declare internal types within the `bun` module using the `__internal` namespace.  These types are not intended for public use but can be used internally within Bun's API.
source: packages/bun-types/authoring.md#_snippet_4

language: typescript
code:
```
declare module "bun" {
  namespace __internal {
    interface MyInternalType {
      // ...
    }
  }
}
```

---

title: Implementing Custom Bundler Plugins in Bun
description: Illustrates how to use custom bundler plugins in Bun by referencing their implementation files in the `bunfig.toml` file.  This allows extending Bun's build process with custom logic and transformations.
source: docs/bundler/fullstack.md#_snippet_10

language: toml
code:
```
[serve.static]
plugins = ["./my-plugin-implementation.ts"]
```

---

title: Installing WebKit Dependencies with Scoop - PowerShell
description: Demonstrates using Scoop to install the dependencies required for building WebKit locally. This includes `make`, `cygwin`, and `python`, which are necessary for compiling WebKit components.
source: docs/project/building-windows.md#_snippet_4

language: ps1
code:
```
> scoop install make cygwin python
```

---

title: Configuring Typescript to Recognize Yaml Imports
description: Illustrates how to configure TypeScript to recognize `.yaml` imports by adding `bun-plugin-yaml` to the `types` array in your `tsconfig.json`. This prevents TypeScript from showing import errors for `.yaml` files.
source: packages/bun-plugin-yaml/README.md#_snippet_4

language: json-diff
code:
```
{
    "compilerOptions": {
      "types": [
        // other packages, e.g. "bun-types",
+       "bun-plugin-yaml"
      ]
    }
  }
```

---

title: Profiling Memory - Bun Inspector
description: Illustrates how to use the Heap domain to track memory usage, listen for garbage collection events, and obtain heap snapshots for memory leak analysis.  It enables heap tracking, listens for garbage collection events, and retrieves a heap snapshot.
source: packages/bun-inspector-protocol/README.md#_snippet_7

language: typescript
code:
```
// Start heap tracking
await inspector.send("Heap.enable");
await inspector.send("Heap.startTracking");

// Listen for GC events
inspector.on("Heap.garbageCollected", ({ collection }) => {
  console.log(
    `GC completed: ${collection.type} (${collection.endTime - collection.startTime}ms)`,
  );
});

// ... perform operations to analyze ...

// Get heap snapshot
const { snapshotData } = await inspector.send("Heap.stopTracking");
// Process snapshotData to find memory leaks
```

---

title: Profiling Scripts - Bun Inspector
description: Demonstrates how to use the ScriptProfiler domain to profile script execution, track performance, and collect stack traces. It starts script profiling, listens for profiling updates, and processes the collected stack traces upon completion.
source: packages/bun-inspector-protocol/README.md#_snippet_8

language: typescript
code:
```
// Start script profiling with sampling
await inspector.send("ScriptProfiler.startTracking", { includeSamples: true });

// Listen for profiling updates
inspector.on("ScriptProfiler.trackingUpdate", event => {
  console.log("Profiling event:", event);
});

// Stop profiling to get complete data
inspector.on("ScriptProfiler.trackingComplete", data => {
  if (data.samples) {
    // Process stack traces
    console.log(`Collected ${data.samples.stackTraces.length} stack traces`);
  }
});

await inspector.send("ScriptProfiler.stopTracking");
```

---

title: Using onGC Function
description: Illustrates how to import and use the `onGC` function from the `common/gc` module.  This allows installing a garbage collection listener to execute a callback (in this case, logging 'collected' to the console) when garbage collection occurs.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_4

language: js
code:
```
require('../common');
const { onGC } = require('../common/gc');

onGC({}, { ongc() { console.log('collected'); } });
```

---

title: Using CI - Buildkite Status
description: Illustrates how to use the `bun ci` command to get the status of a pull request in Buildkite. This is important for tracking CI status and ensuring the changes are passing tests.
source: AGENTS.md#_snippet_8

language: bash
code:
```
bun ci
```

---

title: Using Legacy Web Platform Tests Harness
description: Describes the legacy port of the Web Platform Tests harness available as `WPT.harness`. It indicates that its usage should be avoided in new code as it's being migrated to the original WPT harness.
source: test/napi/node-napi-tests/test/common/README.md#_snippet_13

language: javascript
code:
```
### `harness`

A legacy port of [\[Web Platform Tests\]][Web Platform Tests] harness.

See the source code for definitions. Please avoid using it in new
code - the current usage of this port in tests is being migrated to
the original WPT harness, see [\[the WPT tests README\]][].
```

---

title: Setting Bun Install Path (Zsh)
description: Demonstrates how to add the Bun installation directory to the `PATH` environment variable in the `.zshrc` file. This ensures that the `bun` command can be run from any directory.
source: docs/installation.md#_snippet_8

language: bash
code:
```
# add to ~/.zshrc
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"
```

---

title: Setting Bun Install Path (Bash)
description: Demonstrates how to add the Bun installation directory to the `PATH` environment variable in the `.bashrc` file. This ensures that the `bun` command can be run from any directory.
source: docs/installation.md#_snippet_9

language: bash
code:
```
# add to ~/.bashrc
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"
```

---

title: Setting Bun Install Path (Fish)
description: Illustrates how to add the Bun installation directory to the `PATH` environment variable in the `config.fish` file for the Fish shell. This ensures that the `bun` command is accessible from any directory within the Fish shell.
source: docs/installation.md#_snippet_10

language: sh
code:
```
# add to ~/.config/fish/config.fish
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"
```

---

title: Setting Bun Install Path (Powershell)
description: Demonstrates setting the Bun install path in PowerShell to ensure the `bun` command is recognized. It uses `SetEnvironmentVariable` to modify the user's `Path` environment variable.
source: docs/installation.md#_snippet_11

language: pwsh
code:
```
[System.Environment]::SetEnvironmentVariable(
    "Path",
    [System.Environment]::GetEnvironmentVariable("Path", "User") + ";$env:USERPROFILE\.bun\bin",
    [System.EnvironmentVariableTarget]::User
)
```

---

title: Preloading Svelte Plugin - bunfig.toml
description: Demonstrates how to configure Bun to preload the Svelte plugin (`svelte-loader.js`) defined earlier. This configuration in `bunfig.toml` ensures that Svelte components are correctly compiled before tests are executed.
source: docs/guides/test/svelte-test.md#_snippet_2

language: toml
code:
```
[test]
# Tell Bun to load this plugin before your tests run
preload = ["./svelte-loader.js"]

# This also works:
# test.preload = ["./svelte-loader.js"]
```

---

title: Configuring Executable Entitlements - XML
description: Defines an `entitlements.plist` file that grants the JavaScript engine necessary permissions. This configuration allows the JIT compiler and other features to function correctly within the signed executable, avoiding runtime restrictions.
source: docs/guides/runtime/codesign-macos-executable.md#_snippet_2

language: xml
code:
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.security.cs.allow-jit</key>
    <true/>
    <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
    <true/>
    <key>com.apple.security.cs.disable-executable-page-protection</key>
    <true/>
    <key>com.apple.security.cs.allow-dyld-environment-variables</key>
    <true/>
    <key>com.apple.security.cs.disable-library-validation</key>
    <true/>
</dict>
</plist>
```

---

title: Configuring Global Git to Diff Lockb Files
description: Configures the global Git settings to use `bun` as the text converter for diffing `.lockb` files and specifies that `.lockb` files should be treated as binary.  This enables Git to produce human-readable diffs for binary lockfiles across all repositories by utilizing the `bun` command for conversion before comparison.
source: docs/guides/install/git-diff-bun-lockfile.md#_snippet_2

language: sh
code:
```
$ git config --global diff.lockb.textconv bun
$ git config --global diff.lockb.binary true
```

---

title: Decoding base64 Encoded Password - Javascript
description: Demonstrates how to decode a base64-encoded password using the `atob()` function in a browser console. This can be useful for inspecting or verifying the decoded value of a base64-encoded password.
source: docs/guides/install/azure-artifacts.md#_snippet_3

language: js
code:
```
atob("<base64-encoded password>");
```

---

title: Getting Bun Revision
description: Illustrates how to obtain the exact git commit hash of the `oven-sh/bun` repository used to build the current Bun binary via `Bun.revision`. This can be used for debugging and tracing the exact source code version being executed.
source: docs/guides/util/version.md#_snippet_1

language: typescript
code:
```
Bun.revision; // => "49231b2cb9aa48497ab966fc0bb6b742dacc4994"
```

---

title: Using Shell Commands for Dynamic Values - Shell
description: Demonstrates generating build-time constants from shell commands using `git` and `date`. The `BUILD_VERSION`, `BUILD_TIME`, and `GIT_COMMIT` constants are dynamically generated using shell commands and injected into the build process.
source: docs/guides/runtime/build-time-constants.md#_snippet_9

language: sh
code:
```
# Use git to get current commit and timestamp
$ bun build --compile \
  --define BUILD_VERSION='"$(git describe --tags --always)"' \
  --define BUILD_TIME='"$(date -u +%Y-%m-%dT%H:%M:%SZ)"' \
  --define GIT_COMMIT='"$(git rev-parse HEAD)"' \
  src/cli.ts --outfile mycli
```

---

title: Exploring the Generated Migration Files
description: Shows the directory structure created by `drizzle-kit generate`, containing the SQL migration file and metadata. This structure is crucial for Drizzle to track and apply database schema changes.
source: docs/guides/ecosystem/drizzle.md#_snippet_6

language: txt
code:
```
drizzle
â”œâ”€â”€ 0000_ordinary_beyonder.sql
â””â”€â”€ meta
    â”œâ”€â”€ 0000_snapshot.json
    â””â”€â”€ _journal.json
```

---

title: Granting Port Access for Bun (Bash)
description: Demonstrates how to grant a non-root user the capability to bind to privileged ports (80 or 443) using `setcap`. This allows a Bun application to listen on these ports without running as root, improving security.
source: docs/guides/ecosystem/systemd.md#_snippet_2

language: bash
code:
```
$ sudo setcap CAP_NET_BIND_SERVICE=+eip ~/.bun/bin/bun
```

---

title: Configuring React Dependency in package.json
description: Illustrates how a `package.json` file defines a dependency with a semver range. This configuration impacts how `bun update` and `bun update --latest` handle updates.
source: docs/cli/update.md#_snippet_3

language: json
code:
```
{
  "dependencies": {
    "react": "^17.0.2"
  }
}
```

---

title: Controlling Console Output Depth - Using --console-depth
description: Illustrates how to control the depth of object inspection in console output using the `--console-depth` flag with `bun run`. This allows users to customize how deeply nested objects are displayed in `console.log()` output.
source: docs/cli/run.md#_snippet_4

language: bash
code:
```
$ bun --console-depth 5 run index.tsx
```

language: javascript
code:
```
const nested = { a: { b: { c: { d: "deep" } } } };
console.log(nested);
// With --console-depth 2 (default): { a: { b: [Object] } }
// With --console-depth 4: { a: { b: { c: { d: 'deep' } } } }
```

---

title: Reducing Memory Usage with the --smol Flag
description: Explains how to reduce memory usage in memory-constrained environments by using the `--smol` flag with `bun run`. This flag causes the garbage collector to run more frequently, reducing memory footprint at the cost of performance.
source: docs/cli/run.md#_snippet_5

language: bash
code:
```
$ bun --smol run index.tsx
```

---

title: Specifying One-Time Password for Publishing
description: Demonstrates how to provide a one-time password for publishing with 2FA enabled, using either the `--auth-type` or `--otp` flags. The `--auth-type` flag specifies the preferred method (web or legacy), while the `--otp` flag directly provides the password.
source: docs/cli/publish.md#_snippet_4

language: sh
code:
```
$ bun publish --auth-type legacy
...
This operation requires a one-time password.
Enter OTP: 123456
...
```

language: sh
code:
```
$ bun publish --otp 123456
```

---

title: Using the Bun Runtime with the --bun Flag
description: Explains how to force execution with Bun's runtime, even if the executable indicates otherwise. The `--bun` flag must occur before the executable name.
source: docs/cli/bunx.md#_snippet_5

language: bash
code:
```
$ bunx --bun my-cli
```

language: bash
code:
```
$ bunx my-cli --bun # bad
```

---

title: Defining Local Templates
description: Describes how to define custom local templates for `bun create`. These templates should reside in `$HOME/.bun-create/<name>` or `<project root>/.bun-create/<name>`. It is customisable via the `BUN_CREATE_DIR` environment variable.
source: docs/cli/bun-create.md#_snippet_5

language: bash
code:
```
$ cd $HOME/.bun-create
$ mkdir foo
$ cd foo
```

language: json
code:
```
{
  "name": "foo"
}
```

---

title: Configuring Global Installation Behavior in Bun
description: Shows how to configure the global installation directory and binary directory for packages installed with `bun add --global`.  These settings are configured within the `bunfig.toml` configuration file.
source: docs/cli/add.md#_snippet_7

language: toml
code:
```
[install]
# where `bun add --global` installs packages
globalDir = "~/.bun/install/global"

# where globally-installed package bins are linked
globalBinDir = "~/.bun/bin"
```

---

title: Forcing Copyfile Backend with Bun Install (Bash)
description: Shows how to force the `copyfile` backend for `bun install`. This backend uses `fcopyfile()` on macOS and `copy_file_range()` on Linux, acting as a fallback mechanism when other backends fail, although it's generally the slowest option.
source: docs/cli/bun-install.md#_snippet_4

language: bash
code:
```
$ rm -rf node_modules
$ bun install --backend copyfile
```

---

title: Setting Test Timeouts
description: Illustrates how to set a per-test timeout in milliseconds using the `--timeout` flag. If a test exceeds the specified timeout, it will be marked as failed.
source: docs/cli/test.md#_snippet_6

language: bash
code:
```
# default value is 5000
$ bun test --timeout 20
```

---

title: Bailing Out After Failures
description: Demonstrates how to use the `--bail` flag to abort the test run after a specified number of test failures. This helps reduce CPU usage in CI environments by terminating the test run early.
source: docs/cli/test.md#_snippet_8

language: sh
code:
```
# bail after 1 failure
$ bun test --bail

# bail after 10 failure
$ bun test --bail=10
```

---

title: Preloading Setup Files
description: Demonstrates using the `--preload` flag to preload a setup file, such as `setup.ts`, before running tests. This allows you to define lifecycle hooks or perform setup tasks that apply to all tests.
source: docs/cli/test.md#_snippet_10

language: ts
code:
```
$ bun test --preload ./setup.ts
```

---

title: Updating Snapshots
description: Explains how to update snapshots using the `--update-snapshots` flag with `bun test`. This replaces existing snapshots with the current output, allowing you to accept intentional changes.
source: docs/cli/test.md#_snippet_14

language: sh
code:
```
$ bun test --update-snapshots
```

---

title: Configuring JUnit Reporter Output Path - TOML
description: Demonstrates how to configure the output path for the JUnit XML report within the `bunfig.toml` file. This is done using the `test.reporter.junit` option, allowing you to specify the desired file path for the generated report. This configuration complements the `--reporter=junit` and `--reporter-outfile` CLI flags.
source: docs/test/configuration.md#_snippet_1

language: toml
code:
```
[test.reporter]
junit = "path/to/junit.xml"  # Output path for JUnit XML report
```

---

title: Enabling Smol Memory-Saving Mode - TOML
description: Shows how to enable the `--smol` memory-saving mode for the test runner directly in the `bunfig.toml` file. Setting `smol = true` in the `[test]` section activates this mode, reducing memory usage during test execution, equivalent to using the `--smol` flag on the command line.
source: docs/test/configuration.md#_snippet_2

language: toml
code:
```
[test]
smol = true  # Reduce memory usage during test runs
```

---

title: Skipping Test Files in Coverage Reports - TOML
description: Explains how to exclude test files from coverage reports by setting `coverageSkipTestFiles = true` in the `[test]` section of `bunfig.toml`. This prevents files matching test patterns (e.g., `*.test.ts`) from being included in the coverage report, focusing the report on source code.
source: docs/test/configuration.md#_snippet_3

language: toml
code:
```
[test]
coverageSkipTestFiles = true  # Exclude test files from coverage reports
```

---

title: Setting Specific Coverage Thresholds - TOML
description: Illustrates how to set specific coverage thresholds for different coverage metrics using the object form of `coverageThreshold` in `bunfig.toml`. This allows fine-grained control, enabling you to specify distinct thresholds for `lines`, `functions`, and `statements`. If coverage falls below any of these thresholds, the test run will fail due to `fail_on_low_coverage`.
source: docs/test/configuration.md#_snippet_4

language: toml
code:
```
[test]
# Set specific thresholds for different coverage metrics
coverageThreshold = { lines = 0.9, functions = 0.8, statements = 0.85 }
```

---

title: Enabling Experimental Decorators - tsconfigjson
description: Demonstrates how to enable experimental decorators in a TypeScript project by adding the `experimentalDecorators` option to the `compilerOptions` section of the `tsconfig.json` file. This configuration allows the TypeScript compiler to process and utilize decorator syntax in the code.
source: docs/runtime/typescript.md#_snippet_3

language: jsonc
code:
```
{
  "compilerOptions": {
    // ... rest of your config
    "experimentalDecorators": true,
  },
}
```

---

title: Enabling emitDecoratorMetadata - tsconfigjson
description: Demonstrates how to enable the `emitDecoratorMetadata` option in `tsconfig.json`, which is necessary for emitting design-time type metadata for decorated declarations.  Enabling both `experimentalDecorators` and `emitDecoratorMetadata` allows the program to reflect type information at runtime, useful for dependency injection and similar patterns.
source: docs/runtime/typescript.md#_snippet_5

language: jsonc
code:
```
{
  "compilerOptions": {
    // ... rest of your config
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
  },
}
```

---

title: Defining Workspaces - JSON
description: Illustrates how to define workspaces in `package.json` to manage dependencies across multiple packages in a monorepo.  The `workspaces` field specifies an array of glob patterns that identify the directories containing the workspace packages.
source: docs/cli/install.md#_snippet_4

language: json
code:
```
{
  "name": "my-app",
  "version": "1.0.0",
  "workspaces": ["packages/*"],
  "dependencies": {
    "preact": "^10.5.13"
  }
}
```

---

title: Understanding CommonJS Interop - Low-Level Details
description: Illustrates how Bun's JavaScript runtime natively supports CommonJS by wrapping transpiled modules in a function that provides `module`, `exports`, and `require`. This ensures compatibility with existing CommonJS modules.
source: docs/runtime/modules.md#_snippet_3

language: javascript
code:
```
(function (module, exports, require) {
  // transpiled module
})(module, exports, require);
```

---

title: Configuring Workspace Package Linking in Bunfigtoml
description: Illustrates how to configure workspace packages linking using the `install.linkWorkspacePackages` option in `bunfig.toml`. Setting `linkWorkspacePackages` to `true` links workspace packages from the monorepo root to their respective `node_modules` directories.
source: docs/runtime/bunfig.md#_snippet_1

language: toml
code:
```
[install]
linkWorkspacePackages = true
```

---

title: Configuring Cache Behavior in Bunfigtoml
description: Demonstrates configuring cache behavior in `bunfig.toml` using the `install.cache` section. It showcases settings for specifying the cache directory, disabling the global cache, and disabling manifest resolution.
source: docs/runtime/bunfig.md#_snippet_4

language: toml
code:
```
[install.cache]

# the directory to use for the cache
dir = "~/.bun/install/cache"

# when true, don't load from the global cache.
# Bun may still write to node_modules/.cache
disable = false

# when true, always resolve the latest versions from the registry
disableManifest = false
```

---

title: Configuring Lockfile Saving in Bunfigtoml
description: Demonstrates configuring the lockfile saving behavior using the `install.lockfile` section within the `bunfig.toml` configuration file. Setting `save` to `true` ensures a lockfile is generated on `bun install`.
source: docs/runtime/bunfig.md#_snippet_5

language: toml
code:
```
[install.lockfile]
save = true
```

---

title: Configuring Non-Bun Lockfile Printing in Bunfigtoml
description: Illustrates how to configure the printing of a non-Bun lockfile alongside `bun.lock` by setting the `print` option within the `install.lockfile` section of `bunfig.toml`. This example shows how to configure `bun install` to also generate a `yarn.lock` file.
source: docs/runtime/bunfig.md#_snippet_6

language: toml
code:
```
[install.lockfile]
print = "yarn"
```

---

title: Configuring System Shell For Run in Bunfigtoml
description: Demonstrates how to force `bun run` to use the system shell by setting `shell = "system"` in the `[run]` section of `bunfig.toml`. This will cause `bun run` to execute scripts using the system shell instead of Bun's shell.
source: docs/runtime/bunfig.md#_snippet_7

language: toml
code:
```
[run]
# default outside of Windows
shell = "system"
```

---

title: Configuring Bun Shell For Run in Bunfigtoml
description: Demonstrates how to force `bun run` to use Bun's shell by setting `shell = "bun"` in the `[run]` section of `bunfig.toml`. This will cause `bun run` to execute scripts using the Bun's shell.
source: docs/runtime/bunfig.md#_snippet_8

language: toml
code:
```
[run]
# default on Windows
shell = "bun"
```

---

title: Disabling the Runtime Transpiler Cache
description: Demonstrates how to disable the runtime transpiler cache by setting the `BUN_RUNTIME_TRANSPILER_CACHE_PATH` environment variable to an empty string or "0". This prevents Bun from caching transpiled output, useful in environments like Docker with ephemeral file systems.
source: docs/runtime/env.md#_snippet_9

language: sh
code:
```
BUN_RUNTIME_TRANSPILER_CACHE_PATH=0 bun run dev
```

---

title: Falling Back to Module and Main - JSON
description: Demonstrates the fallback mechanism when the `exports` field is not defined in `package.json`.  Bun will then look for `module` (ESM imports only) then `main` to determine the package's entrypoint.  This ensures compatibility with older packages that do not utilize the `exports` field.
source: docs/runtime/modules.md#_snippet_9

language: json
code:
```
{
  "name": "foo",
  "module": "./index.js",
  "main": "./index.js"
}
```

---

title: Marking Tests as Todo with Test.todo in Bun:test
description: Shows how to mark a test as a todo using `test.todo` in `bun:test`.  Todo tests are not executed, indicating planned tests that are not yet implemented. It imports `expect` and `test` from `bun:test`.
source: docs/test/writing.md#_snippet_6

language: ts
code:
```
import { expect, test } from "bun:test";

test.todo("fix this", () => {
  myTestFunction();
});
```

---

title: Skipping Tests Conditionally with Test.skipIf in Bun:test
description: Demonstrates how to conditionally skip a test based on a truthy condition using `test.skipIf()` in `bun:test`. It is useful for skipping tests on specific architectures or operating systems.  The example checks if the operating system is MacOS and if it is, then it skips the test.
source: docs/test/writing.md#_snippet_9

language: ts
code:
```
const macOS = process.arch === "darwin";

test.skipIf(macOS)("runs on non-macOS", () => {
  // runs if *not* macOS
});
```

---

title: Reading Build Config in a Plugin
description: Demonstrates how a plugin can read the build configuration using `build.config`. Shows how to log the current value of `sourcemap` and modify the `minify` option to enable minification.
source: docs/runtime/plugins.md#_snippet_9

language: ts
code:
```
await Bun.build({
  entrypoints: ["./app.ts"],
  outdir: "./dist",
  sourcemap: "external",
  plugins: [
    {
      name: "demo",
      setup(build) {
        console.log(build.config.sourcemap); // "external"

        build.config.minify = true; // enable minification

        // `plugins` is readonly
        console.log(`Number of plugins: ${build.config.plugins.length}`);
      },
    },
  ],
});
```

---

title: Configuring JSX with Pragmas
description: Demonstrates how to configure JSX compilation options on a per-file basis using pragmas. Pragmas are special comments that override the `jsxFactory`, `jsxFragmentFactory`, and `jsxImportSource` compiler options for a specific file.
source: docs/runtime/jsx.md#_snippet_7

language: ts
code:
```
// @jsx h
```

language: jsonc
code:
```
{
  "jsxFactory": "h",
}
```

language: ts
code:
```
// @jsxFrag MyFragment
```

language: jsonc
code:
```
{
  "jsxFragmentFactory": "MyFragment",
}
```

language: ts
code:
```
// @jsxImportSource preact
```

language: jsonc
code:
```
{
  "jsxImportSource": "preact",
}
```

---

title: Configuring DNS Cache TTL - Shell
description: Illustrates how to configure the Time-To-Live (TTL) for DNS cache entries in Bun by setting the `$BUN_CONFIG_DNS_TIME_TO_LIVE_SECONDS` environment variable.  This allows customizing the duration for which DNS entries are cached, overriding the default of 30 seconds.
source: docs/api/dns.md#_snippet_4

language: sh
code:
```
BUN_CONFIG_DNS_TIME_TO_LIVE_SECONDS=5 bun run my-script.ts
```

---

title: Compressing Individual Messages
description: Demonstrates how to enable compression for individual messages using the `.send()` method by passing a boolean as the second argument. This offers more fine-grained control over when compression is applied.
source: docs/api/websockets.md#_snippet_9

language: typescript
code:
```
ws.send("Hello world", true);
```

---

title: Setting Idle Timeout for WebSocket
description: Demonstrates how to configure the idle timeout for WebSocket connections using the `idleTimeout` parameter in `Bun.serve`.  This example sets the timeout to 60 seconds.
source: docs/api/websockets.md#_snippet_10

language: typescript
code:
```
Bun.serve({
  fetch(req, server) {}, // upgrade logic
  websocket: {
    idleTimeout: 60, // 60 seconds

    // ...
  },
});
```

---

title: Setting Max Payload Length
description: Demonstrates how to configure the maximum payload length for WebSocket messages using the `maxPayloadLength` parameter in `Bun.serve`. This example sets the maximum payload length to 1 MB.
source: docs/api/websockets.md#_snippet_11

language: typescript
code:
```
Bun.serve({
  fetch(req, server) {}, // upgrade logic
  websocket: {
    maxPayloadLength: 1024 * 1024, // 1 MB

    // ...
  },
});
```

---

title: Defining Cookie Attributes
description: Shows the attributes available for the `Cookie` class. These attributes control the cookie's behavior, such as its expiration date, domain, path, and security settings.  Using these properties, you can set different types of cookies.
source: docs/api/cookie.md#_snippet_3

language: ts
code:
```
interface CookieInit {
  name?: string;
  value?: string;
  domain?: string;
  /** Defaults to '/'. To allow the browser to set the path, use an empty string. */
  path?: string;
  expires?: number | Date | string;
  secure?: boolean;
  /** Defaults to `lax`. */
  sameSite?: CookieSameSite;
  httpOnly?: boolean;
  partitioned?: boolean;
  maxAge?: number;
}

class Cookie {
  readonly name: string;
  value: string;
  domain?: string;
  path: string;
  expires?: Date;
  secure: boolean;
  sameSite: CookieSameSite;
  partitioned: boolean;
  maxAge?: number;
  httpOnly: boolean;
}
```

---

title: Handling Range Errors with DataView
description: Demonstrates the `RangeError` that occurs when attempting to write data beyond the bounds of the `ArrayBuffer` using `DataView`.  It attempts to write a `Float64` (8 bytes) into a buffer that only has 4 bytes available, resulting in the error.
source: docs/api/binary-data.md#_snippet_4

language: typescript
code:
```
dv.setFloat64(0, 3.1415);
// ^ RangeError: Out of bounds access
```

---

title: Enabling Smol Mode - TOML
description: Demonstrates how to enable `smol` mode in `bunfig.toml`. Enabling this setting reduces memory usage, which can be beneficial for resource-constrained environments.  However, it comes with a performance cost, so it's important to evaluate whether the memory savings outweigh the performance impact.
source: docs/runtime/bunfig.md#_snippet_2

language: toml
code:
```
# Reduce memory usage at the cost of performance
smol = true
```

---

title: Setting Log Level - TOML
description: Illustrates how to set the `logLevel` in `bunfig.toml`. This configures the verbosity of Bun's logging output, allowing you to filter messages based on severity. Supported levels include `debug`, `warn`, and `error`, enabling you to control the amount of detail reported during runtime.
source: docs/runtime/bunfig.md#_snippet_3

language: toml
code:
```
logLevel = "debug" # "debug" | "warn" | "error"
```

---

title: Disabling Telemetry - TOML
description: Demonstrates how to disable telemetry in `bunfig.toml`.  Setting `telemetry = false` prevents Bun from recording bundle timings and feature usage analytics. This is equivalent to setting the `DO_NOT_TRACK` environment variable.
source: docs/runtime/bunfig.md#_snippet_6

language: toml
code:
```
telemetry = false
```

---

title: Setting Console Depth - TOML
description: Demonstrates how to set the default depth for `console.log()` object inspection using the `console.depth` setting in `bunfig.toml`.  This controls how deeply nested objects are displayed in console output. A higher depth shows more nested properties.
source: docs/runtime/bunfig.md#_snippet_7

language: toml
code:
```
[console]
depth = 3
```

---

title: Enabling Smol Mode for Tests - TOML
description: Illustrates how to enable `smol` mode specifically for tests using the `test.smol` setting in `bunfig.toml`. This can reduce memory usage during test execution, which is helpful when running many tests or when resources are limited.
source: docs/runtime/bunfig.md#_snippet_10

language: toml
code:
```
[test]
smol = true
```

---

title: Skipping Test Files in Coverage - TOML
description: Demonstrates configuring whether to skip test files when computing coverage statistics in `bunfig.toml` using the `test.coverageSkipTestFiles` setting. By default, test files are included in coverage calculations; this setting allows you to exclude them.
source: docs/runtime/bunfig.md#_snippet_14

language: toml
code:
```
[test]
coverageSkipTestFiles = false
```

---

title: Ignoring Paths for Coverage - TOML
description: Demonstrates how to exclude specific files or file patterns from coverage reports in `bunfig.toml` using the `test.coveragePathIgnorePatterns` setting. This setting accepts glob patterns to exclude files from coverage calculations.
source: docs/runtime/bunfig.md#_snippet_15

language: toml
code:
```
[test]
# Single pattern
coveragePathIgnorePatterns = "**/*.spec.ts"

# Multiple patterns
coveragePathIgnorePatterns = [
  "**/*.spec.ts",
  "**/*.test.ts",
  "src/utils/**",
  "*.config.js"
]
```

---

title: Installing Optional Dependencies - TOML
description: Demonstrates how to configure whether to install optional dependencies using the `install.optional` setting in `bunfig.toml`. Setting it to `false` will skip installing optional dependencies. The default is `true`.
source: docs/runtime/bunfig.md#_snippet_18

language: toml
code:
```
[install]
optional = true
```

---

title: Installing Development Dependencies - TOML
description: Demonstrates how to configure whether to install development dependencies using the `install.dev` setting in `bunfig.toml`.  Setting it to `false` will skip installing development dependencies. The default is `true`.
source: docs/runtime/bunfig.md#_snippet_19

language: toml
code:
```
[install]
dev = true
```

---

title: Installing Peer Dependencies - TOML
description: Demonstrates how to configure whether to install peer dependencies using the `install.peer` setting in `bunfig.toml`. Setting it to `false` will skip installing peer dependencies. The default is `true`.
source: docs/runtime/bunfig.md#_snippet_20

language: toml
code:
```
[install]
peer = true
```

---

title: Setting Production Mode - TOML
description: Demonstrates how to configure `bun install` to run in production mode using the `install.production` setting in `bunfig.toml`.  In production mode, development dependencies are not installed.  The default is `false`.
source: docs/runtime/bunfig.md#_snippet_21

language: toml
code:
```
[install]
production = false
```

---

title: Setting Exact Versioning - TOML
description: Demonstrates configuring whether to use exact versions in `package.json` using the `install.exact` setting in `bunfig.toml`. The default behavior uses caret ranges. When `exact` is set to `true`, exact versions are saved to `package.json`.
source: docs/runtime/bunfig.md#_snippet_22

language: toml
code:
```
[install]
exact = false
```

---

title: Saving Text Lockfile - TOML
description: Demonstrates how to configure whether to save a text-based lockfile (bun.lock) or a binary lockfile (bun.lockb) using the `install.saveTextLockfile` setting in `bunfig.toml`. The default is `true`, saving a text-based lockfile.
source: docs/runtime/bunfig.md#_snippet_23

language: toml
code:
```
[install]
saveTextLockfile = false
```

---

title: Configuring Auto Install - TOML
description: Demonstrates how to configure Bun's package auto-install behavior using the `install.auto` setting in `bunfig.toml`. This can be set to `auto`, `force`, `disable`, or `fallback` to control whether and when Bun automatically installs missing dependencies.
source: docs/runtime/bunfig.md#_snippet_24

language: toml
code:
```
[install]
auto = "auto"
```

---

title: Freezing Lockfile Updates - TOML
description: Demonstrates configuring whether `bun install` will update `bun.lock` using the `install.frozenLockfile` setting in `bunfig.toml`. When set to `true`, `bun install` will not modify the lockfile and will error if the `package.json` and lockfile are out of sync.
source: docs/runtime/bunfig.md#_snippet_25

language: toml
code:
```
[install]
frozenLockfile = false
```

---

title: Dry Running Installation - TOML
description: Demonstrates how to configure `bun install` to run in dry-run mode using the `install.dryRun` setting in `bunfig.toml`. When set to `true`, `bun install` will not actually install dependencies but will instead simulate the installation process.
source: docs/runtime/bunfig.md#_snippet_26

language: toml
code:
```
[install]
dryRun = false
```

---

title: Setting Global Install Directory - TOML
description: Illustrates how to configure the directory where Bun puts globally installed packages using the `install.globalDir` setting in `bunfig.toml`.  The corresponding environment variable is `BUN_INSTALL_GLOBAL_DIR`.
source: docs/runtime/bunfig.md#_snippet_27

language: toml
code:
```
[install]
# where `bun install --global` installs packages
globalDir = "~/.bun/install/global"
```

---

title: Setting Global Binary Directory - TOML
description: Illustrates how to configure the directory where Bun installs globally installed binaries and CLIs using the `install.globalBinDir` setting in `bunfig.toml`. The corresponding environment variable is `BUN_INSTALL_BIN`.
source: docs/runtime/bunfig.md#_snippet_28

language: toml
code:
```
# where globally-installed package bins are linked
globalBinDir = "~/.bun/bin"
```

---

title: Configuring Default Error Handling - JavaScript
description: Shows how to configure the default error handling behavior for all shell commands executed with Bun Shell using `$.nothrow()` and `$.throws()`. This allows for globally setting whether non-zero exit codes should throw errors or not.
source: docs/runtime/shell.md#_snippet_7

language: js
code:
```
import { $ } from "bun";
// shell promises will not throw, meaning you will have to
// check for `exitCode` manually on every shell command.
$.nothrow(); // equivalent to $.throws(false)

// default behavior, non-zero exit codes will throw an error
$.throws(true);

// alias for $.nothrow()
$.throws(false);

await $`something-that-may-fail`; // No exception thrown
```

---

title: Implementing Dynamic Passwords for Authentication - TypeScript
description: Demonstrates how to use a function to dynamically resolve the database password at connection time. The `password` option accepts either a synchronous or asynchronous function, allowing authentication with access tokens or databases with rotating passwords. Shows the basic structure of such a function using `SQL`.
source: docs/api/sql.md#_snippet_2

language: typescript
code:
```
import { SQL } from "bun";

const sql = new SQL(url, {
  // Other connection config
  ...
  // Password function for the database user
  password: async () => await signer.getAuthToken(),
});
```

---

title: Configuring SSL Modes - TypeScript
description: Demonstrates how to configure SSL/TLS modes using the `ssl` option in the `SQL` constructor. Shows usage of different SSL modes, including `disable`, `prefer`, `require`, `verify-ca`, and `verify-full`. Explains the purpose of each mode and how they control the security of the connection.
source: docs/api/sql.md#_snippet_7

language: typescript
code:
```
const sql = new SQL({
  hostname: "localhost",
  username: "user",
  password: "password",
  ssl: "disable", // | "prefer" | "require" | "verify-ca" | "verify-full"
});
```

---

title: Configuring SSL Modes with Connection Strings - TypeScript
description: Illustrates how to specify SSL modes in connection strings using the `sslmode` parameter. This allows configuring SSL/TLS without directly passing options to the `SQL` constructor. Demonstrates using `prefer` and `verify-full` SSL modes in connection strings.
source: docs/api/sql.md#_snippet_8

language: typescript
code:
```
// Using prefer mode
const sql = new SQL("postgres://user:password@localhost/mydb?sslmode=prefer");

// Using verify-full mode
const sql = new SQL(
  "postgres://user:password@localhost/mydb?sslmode=verify-full",
);
```

---

title: Configuring Connection Pooling - TypeScript
description: Demonstrates how to configure connection pooling using options such as `max`, `idleTimeout`, `maxLifetime`, and `connectionTimeout` in the `SQL` constructor. Connection pooling helps to reduce the overhead of establishing and closing connections for each query, improving performance and managing concurrent connections. Shows an example pool configuration.
source: docs/api/sql.md#_snippet_9

language: typescript
code:
```
const db = new SQL({
  // Pool configuration
  max: 20, // Maximum 20 concurrent connections
  idleTimeout: 30, // Close idle connections after 30s
  maxLifetime: 3600, // Max connection lifetime 1 hour
  connectionTimeout: 10, // Connection timeout 10s
});
```

---

title: Converting a CookieMap to JSON
description: Illustrates how to convert a `Bun.CookieMap` to a JSON serializable object using the `toJSON` method. This is useful for storing or transmitting cookie data.
source: docs/api/cookie.md#_snippet_6

language: typescript
code:
```
const json = cookies.toJSON();
```

---

title: Getting the Cookie Map Size
description: Demonstrates how to retrieve the number of cookies stored in a `Bun.CookieMap` using the `size` property.  This is useful for monitoring and managing cookie storage.
source: docs/api/cookie.md#_snippet_9

language: typescript
code:
```
console.log(cookies.size); // Number of cookies
```

---

title: Reading Promise Result
description: Demonstrates reading a promise's result without `await` or `.then` using `Bun.peek()`, but only if the promise has already fulfilled or rejected. This is useful for optimizing performance-sensitive code by reducing microticks.
source: docs/api/utils.md#_snippet_11

language: typescript
code:
```
import { peek } from "bun";

const promise = Promise.resolve("hi");

// no await!
const result = peek(promise);
console.log(result); // "hi"
```

---

title: Showing Undefined Values Strict Check
description: Demonstrates how strict mode in `Bun.deepEquals()` treats undefined values.  It highlights cases where objects are considered unequal when comparing undefined values.
source: docs/api/utils.md#_snippet_17

language: typescript
code:
```
// undefined values
Bun.deepEquals({}, { a: undefined }, true); // false

// undefined in arrays
Bun.deepEquals(["asdf"], ["asdf", undefined], true); // false

// sparse arrays
Bun.deepEquals([, 1], [undefined, 1], true); // false

// object literals vs instances w/ same properties
class Foo {
  a = 1;
}
Bun.deepEquals(new Foo(), { a: 1 }, true); // false
```

---

title: Defining Memory Deallocation Context - Bun:ffi
description: Illustrates how to define a deallocation context using `toArrayBuffer` from `bun:ffi`. This allows tracking when a `TypedArray` is no longer in use from C or FFI. The function specified in `jsTypedArrayBytesDeallocator` is called when the garbage collector frees the underlying `ArrayBuffer` JavaScript object.
source: docs/api/ffi.md#_snippet_4

language: typescript
code:
```
import { toArrayBuffer } from "bun:ffi";

// with a deallocatorContext:
toArrayBuffer(
  bytes,
  byteOffset,

  byteLength,

  // this is an optional pointer to a callback
  deallocatorContext,

  // this is a pointer to a function
  jsTypedArrayBytesDeallocator,
);

// without a deallocatorContext:
toArrayBuffer(
  bytes,
  byteOffset,

  byteLength,

  // this is a pointer to a function
  jsTypedArrayBytesDeallocator,
);
```

---

title: Passing Compiler Flags with `cc`
description: Demonstrates how to pass compiler flags to TinyCC using `bun:ffi`'s `cc` function. The `flags` property accepts a string or array of strings representing flags like `-I` for include directories and `-D` for preprocessor definitions.
source: docs/api/cc.md#_snippet_6

language: typescript
code:
```
type Flags = string | string[];
```

---

title: Freeing Statement Resources - Using Finalize
description: Illustrates how to use `.finalize()` to explicitly destroy a `Statement` and free associated resources. While garbage collection typically handles this, explicit finalization can be useful in performance-critical applications to immediately release resources held by the statement.
source: docs/api/sqlite.md#_snippet_3

language: typescript
code:
```
const query = db.query("SELECT title, year FROM movies");
const movies = query.all();
query.finalize();
```

---

title: Serializing and Deserializing a Database
description: Explains how to serialize a SQLite database to a `Uint8Array` and then deserialize it back into a new database instance using `.serialize()` and `.deserialize()`. This is useful for backing up, restoring, or transferring databases.  Internally, it uses `sqlite3_serialize`.
source: docs/api/sqlite.md#_snippet_9

language: ts
code:
```
const olddb = new Database("mydb.sqlite");
const contents = olddb.serialize(); // => Uint8Array
const newdb = Database.deserialize(contents);
```

---

title: Preloading Modules in a Worker
description: Demonstrates preloading modules before a worker starts using the `preload` option. This ensures that specific code, like OpenTelemetry or Sentry, is loaded before the worker application begins execution.
source: docs/api/workers.md#_snippet_3

language: js
code:
```
const worker = new Worker("./worker.ts", {
  preload: ["./load-sentry.js"],
});
```

---

title: Preloading a Single Module in a Worker
description: Illustrates preloading a single module before a worker starts using the `preload` option with a string. This ensures that specific code, like OpenTelemetry or Sentry, is loaded before the worker application begins execution.
source: docs/api/workers.md#_snippet_4

language: js
code:
```
const worker = new Worker("./worker.ts", {
  preload: "./load-sentry.js",
});
```

---

title: Using Command Pipelining - Bun
description: Illustrates how the Redis client automatically pipelines commands for improved performance, and how to disable this feature by setting the `enableAutoPipelining` option to `false`. This provides control over pipelining behavior to optimize performance as needed.
source: docs/api/redis.md#_snippet_7

language: ts
code:
```
// Commands are automatically pipelined by default
const [infoResult, listResult] = await Promise.all([
  redis.get("user:1:name"),
  redis.get("user:2:email"),
]);
```

language: ts
code:
```
const client = new RedisClient("redis://localhost:6379", {
  enableAutoPipelining: false,
});
```

---

title: Registering Connection Events - Bun
description: Demonstrates how to register handlers for connection events, such as `onconnect` and `onclose`, to monitor and respond to changes in the Redis connection status. This provides insights into connection behavior and enables custom handling of connection events.
source: docs/api/redis.md#_snippet_9

language: ts
code:
```
const client = new RedisClient();

// Called when successfully connected to Redis server
client.onconnect = () => {
  console.log("Connected to Redis server");
};

// Called when disconnected from Redis server
client.onclose = error => {
  console.error("Disconnected from Redis server:", error);
};

// Manually connect/disconnect
await client.connect();
client.close();
```

---

title: Monitoring Connection Status - Bun
description: Shows how to check the connection status and amount of data buffered using the `connected` and `bufferedAmount` properties of the Redis client.  This allows for monitoring the state of the connection and identifying potential issues.
source: docs/api/redis.md#_snippet_10

language: ts
code:
```
// Check if connected
console.log(client.connected); // boolean indicating connection status

// Check amount of data buffered (in bytes)
console.log(client.bufferedAmount);
```

---

title: Configuring Connection Options - Bun
description: Illustrates how to configure various connection options when creating a Redis client, such as connection timeout, idle timeout, auto-reconnect behavior, TLS settings, and more.  This shows how to customize the client to fit different environmental and performance requirements.
source: docs/api/redis.md#_snippet_11

language: ts
code:
```
const client = new RedisClient("redis://localhost:6379", {
  // Connection timeout in milliseconds (default: 10000)
  connectionTimeout: 5000,

  // Idle timeout in milliseconds (default: 0 = no timeout)
  idleTimeout: 30000,

  // Whether to automatically reconnect on disconnection (default: true)
  autoReconnect: true,

  // Maximum number of reconnection attempts (default: 10)
  maxRetries: 10,

  // Whether to queue commands when disconnected (default: true)
  enableOfflineQueue: true,

  // Whether to automatically pipeline commands (default: true)
  enableAutoPipelining: true,

  // TLS options (default: false)
  tls: true
  // Alternatively, provide custom TLS config:
  // tls: {
  //   rejectUnauthorized: true,
  //   ca: "path/to/ca.pem",
  //   cert: "path/to/cert.pem",
  //   key: "path/to/key.pem",
  // }
});
```

---

title: Specifying Install Backend Strategy - Bash
description: Illustrates how to specify the installation backend strategy using the `--backend` flag with `bun install`.  This allows users to control how Bun copies files into the `node_modules` directory, impacting performance and disk space usage. The example shows using `symlink` as the backend.
source: docs/install/cache.md#_snippet_1

language: bash
code:
```
$ bun install --backend symlink
```

---

title: Performing Asynchronous Operations in Element Handlers - TS
description: Illustrates how asynchronous operations can be performed within element handlers in `HTMLRewriter`. The code snippet uses `Bun.sleep` to simulate an asynchronous task, demonstrating that the transformation will block until the promise resolves.
source: docs/api/html-rewriter.md#_snippet_3

language: ts
code:
```
rewriter.on("div", {
  async element(element) {
    await Bun.sleep(1000);
    element.setInnerContent("<span>replace</span>", { html: true });
  },
});
```

---

title: Handling Errors in HTMLRewriter Operations - TS
description: Illustrates how to handle errors that may occur during `HTMLRewriter` operations using a `try...catch` block. The example catches potential errors such as invalid selector syntax, invalid HTML content, stream errors, memory allocation failures, invalid input types, and body already used errors.
source: docs/api/html-rewriter.md#_snippet_9

language: ts
code:
```
try {
  const result = rewriter.transform(input);
  // Process result
} catch (error) {
  console.error("HTMLRewriter error:", error);
}
```

---

title: Fetching a URL with a Unix Domain Socket
description: Demonstrates how to fetch a URL using a Unix domain socket with Bun's `fetch` API. This configuration allows for inter-process communication using file system paths, improving network efficiency in certain cases.
source: docs/api/fetch.md#_snippet_7

language: typescript
code:
```
const response = await fetch("https://hostname/a/path", {
  unix: "/var/run/path/to/unix.sock",
  method: "POST",
  body: JSON.stringify({ message: "Hello from Bun!" }),
  headers: {
    "Content-Type": "application/json",
  },
});
```

---

title: Configuring TLS with Client Certificates
description: Illustrates how to configure TLS with client certificates using Bun's `fetch` API. This adds a layer of security by requiring the client to authenticate with a certificate.
source: docs/api/fetch.md#_snippet_8

language: typescript
code:
```
await fetch("https://example.com", {
  tls: {
    key: Bun.file("/path/to/key.pem"),
    cert: Bun.file("/path/to/cert.pem"),
    // ca: [Bun.file("/path/to/ca.pem")],
  },
});
```

---

title: Getting Process Resource Usage
description: Illustrates how to retrieve information about a process's resource usage after it has exited. The example shows how to access the maximum memory used and CPU time (user and system).
source: docs/api/spawn.md#_snippet_8

language: typescript
code:
```
const proc = Bun.spawn(["bun", "--version"]);
await proc.exited;

const usage = proc.resourceUsage();
console.log(`Max memory used: ${usage.maxRSS} bytes`);
console.log(`CPU time (user): ${usage.cpuTime.user} Âµs`);
console.log(`CPU time (system): ${usage.cpuTime.system} Âµs`);
```

---

title: Buffering Responses in Memory for Static Routes
description: Illustrates buffering a response in memory before serving it as a static route in `Bun.serve`.  This is necessary to support `ReadableStream` or `AsyncIterator` response bodies, which are not directly supported.
source: docs/api/http.md#_snippet_7

language: typescript
code:
```
const time = await fetch("https://api.example.com/v1/data");
// Buffer the response in memory first.
const blob = await time.blob();

const server = Bun.serve({
  static: {
    "/api/data": new Response(blob),
  },

  fetch(req) {
    return new Response("404!");
  },
});
```

---

title: Generating Lockfile Without Installing Packages
description: Demonstrates the usage of the `--lockfile-only` flag with `bun install` to generate or update the `bun.lock` file without actually installing any packages. This is helpful when you only want to update the lockfile based on changes in `package.json` without modifying the installed dependencies.
source: docs/install/index.md#_snippet_4

language: bash
code:
```
$ bun install --lockfile-only
```

---

title: Adding the Tailwind Plugin - Bash and TOML
description: Shows the steps to integrate Tailwind CSS using the `bun-plugin-tailwind` plugin. First, the plugin is installed using `bun install`. Then, the plugin is added to the `bunfig.toml` configuration file. This enables Tailwind CSS to be used within the project.
source: docs/bundler/html.md#_snippet_5

language: bash
code:
```
# Or any npm client
$ bun install --dev bun-plugin-tailwind
```

language: toml
code:
```
[serve.static]
plugins = ["bun-plugin-tailwind"]
```

---

title: Referencing Tailwind CSS - HTML, CSS, and TypeScript
description: Demonstrates three ways to reference Tailwind CSS after installing the `bun-plugin-tailwind` plugin: via a `<link>` tag in HTML, an `@import` statement in CSS, or an `import` statement in JavaScript/TypeScript.  Only one of these methods is necessary to incorporate Tailwind CSS into your project.
source: docs/bundler/html.md#_snippet_6

language: html
code:
```
<!-- Reference TailwindCSS in your HTML -->
<link rel="stylesheet" href="tailwindcss" />
```

language: css
code:
```
/* Import TailwindCSS in your CSS */
@import "tailwindcss";
```

language: ts
code:
```
/* Import TailwindCSS in your JavaScript */
import "tailwindcss";
```

---

title: Configuring Port and Hostname
description: Illustrates how to configure the port and hostname for the Bun server using the `port` and `hostname` options in `Bun.serve`. It shows how to explicitly set the port and hostname, and how to allow Bun to select a random available port by setting `port` to `0`.
source: docs/api/http.md#_snippet_5

language: typescript
code:
```
Bun.serve({
  port: 8080, // defaults to $BUN_PORT, $PORT, $NODE_PORT otherwise 3000
  hostname: "mydomain.com", // defaults to "0.0.0.0"
  fetch(req) {
    return new Response("404!");
  },
});
```

---

title: Using an Abstract Namespace Socket
description: Demonstrates how to use an abstract namespace socket in Bun by prefixing the `unix` path with a null byte. Abstract namespace sockets are not bound to the filesystem and are automatically removed when the last reference is closed, providing a cleaner alternative to traditional Unix domain sockets.
source: docs/api/http.md#_snippet_8

language: typescript
code:
```
Bun.serve({
  unix: "\0my-abstract-socket", // abstract namespace socket
  fetch(req) {
    return new Response(`404!`);
  },
});
```

---

title: Stopping the Server
description: Illustrates how to stop a Bun server using the `server.stop()` method. After calling `Bun.serve`, the returned `Server` object can be used to control the server's lifecycle, including stopping it when no longer needed.
source: docs/api/http.md#_snippet_11

language: typescript
code:
```
const server = Bun.serve({
  fetch() {
    return new Response("Bun!");
  },
});

server.stop();
```

---

title: Delaying Build Completion with Asynchronous onStart - Typescript
description: Illustrates delaying the completion of the bundle process using asynchronous `onStart` callbacks. The example shows how Bun waits for all `onStart()` callbacks, including asynchronous ones, to complete before proceeding with the build. This ensures that necessary setup tasks are finished before bundling begins.
source: docs/bundler/plugins.md#_snippet_3

language: ts
code:
```
const result = await Bun.build({
  entrypoints: ["./app.ts"],
  outdir: "./dist",
  sourcemap: "external",
  plugins: [
    {
      name: "Sleep for 10 seconds",
      setup(build) {
        build.onStart(async () => {
          await Bunlog.sleep(10_000);
        });
      },
    },
    {
      name: "Log bundle time to a file",
      setup(build) {
        build.onStart(async () => {
          const now = Date.now();
          await Bun.$`echo ${now} > bundle-time.txt`;
        });
      },
    },
  ],
});
```

---

title: Configuring Advanced WebSocket Handler Options
description: Illustrates configuring advanced WebSocket options within the `websocket` handler. These options include settings for maximum payload length, backpressure limits, compression, ping frames, and message handling.
source: docs/api/http.md#_snippet_15

language: typescript
code:
```
Bun.serve({
  websocket: {
    // Maximum message size (in bytes)
    maxPayloadLength: 64 * 1024,

    // Backpressure limit before messages are dropped
    backpressureLimit: 1024 * 1024,

    // Close connection if backpressure limit is hit
    closeOnBackpressureLimit: true,

    // Handler called when backpressure is relieved
    drain(ws) {
      console.log("Backpressure relieved");
    },

    // Enable per-message deflate compression
    perMessageDeflate: {
      compress: true,
      decompress: true,
    },

    // Send ping frames to keep connection alive
    sendPings: true,

    // Handlers for ping/pong frames
    ping(ws, data) {
      console.log("Received ping");
    },
    pong(ws, data) {
      console.log("Received pong");
    },

    // Whether server receives its own published messages
    publishToSelf: false,
  },
});
```

---

title: Generating Bytecode with Bun Build
description: Illustrates how to generate bytecode for JavaScript/TypeScript entrypoints using the `bytecode` option in `Bun.build`.  This can improve startup times for large applications when using the CommonJS format and targeting the Bun runtime.
source: docs/bundler/index.md#_snippet_6

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ["./index.tsx"],
  outdir: "./out",
  bytecode: true,
})
```

language: CLI
code:
```
$ bun build ./index.tsx --outdir ./out --bytecode
```

---

title: Configuring Plugins
description: Illustrates how to configure plugins during bundling using the JavaScript API. Plugins can extend the bundler's functionality, such as transforming code or handling custom file types. No CLI example is available for plugins.
source: docs/bundler/index.md#_snippet_5

language: JavaScript
code:
```
await Bun.build({
  entrypoints: ['./index.tsx'],
  outdir: './out',
  plugins: [/* ... */],
})
```

---

title: Disabling Environment Variable Injection
description: Demonstrates how to disable environment variable injection entirely using `env: "disable"`.  With injection disabled, `process.env.FOO` references will remain as is in the bundled output.
source: docs/bundler/index.md#_snippet_8

language: typescript
code:
```
console.log(process.env.FOO);
console.log(process.env.ACME_PUBLIC_URL);
console.log(process.env.BAZ);
```

---

title: Customizing Extension Settings with Settings JSON
description: Illustrates how to customize the Bun extension's behavior using the `settings.json` file in Visual Studio Code. This configuration allows users to specify the Bun runtime path, enable debugging in the terminal, define test file patterns, and set a custom testing script.
source: packages/bun-vscode/README.md#_snippet_1

language: jsonc
code:
```
{
  // The path to the `bun` executable.
  "bun.runtime": "/path/to/bun",

  // If support for Bun should be added to the default "JavaScript Debug Terminal".
  "bun.debugTerminal.enabled": true,

  // If the debugger should stop on the first line of the program.
  "bun.debugTerminal.stopOnEntry": false,

  // Glob pattern to find test files. Defaults to the value shown below.
  "bun.test.filePattern": "**/*{.test.,.spec.,_test_,_spec_}{js,ts,tsx,jsx,mts,cts,cjs,mjs}",

  // The custom script to call for testing instead of `bun test`
  "bun.test.customScript": "bun test",
}
```

---

title: Embedding Directories with Bun Build
description: Demonstrates embedding a directory with `bun build --compile` using shell globs. Shows how to reference the files within the code using import statements with the `type: "file"` attribute and serving it via a `Response` object.
source: docs/bundler/executables.md#_snippet_6

language: typescript
code:
```
import icon from "./public/assets/icon.png" with { type: "file" };
import { file } from "bun";

export default {
  fetch(req) {
    // Embedded files can be streamed from Response objects
    return new Response(file(icon));
  },
};
```

---

title: Specifying Entitlements for Code Signing on macOS
description: Illustrates the recommended `entitlements.plist` file including JIT permissions for macOS code signing. It enables JIT, unsigned executable memory, disables executable page protection and library validation.
source: docs/bundler/executables.md#_snippet_8

language: xml
code:
```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.security.cs.allow-jit</key>
    <true/>
    <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
    <true/>
    <key>com.apple.security.cs.disable-executable-page-protection</key>
    <true/>
    <key>com.apple.security.cs.allow-dyld-environment-variables</key>
    <true/>
    <key>com.apple.security.cs.disable-library-validation</key>
    <true/>
</dict>
</plist>
```

---

title: Specifying Bun Binary Path
description: Demonstrates how to specify a custom path to the Bun binary when running scripts. This is useful when you want to use a specific version of Bun instead of the default one in your system's PATH.  Alternatively, you can edit the `.env` file to set the `BUN` environment variable.
source: bench/README.md#_snippet_1

language: bash
code:
```
# to use custom version of bun/deno/node binary
BUN=path/to/bun bun run ffi
# or edit .env file
```

---

title: Customizing Integer Attributes with Bindgen - Typescript
description: Illustrates customizing integer type attributes using `enforceRange`, `clamp`, and `default`. These attributes allow you to specify range restrictions, clamping behavior, and default values for integer arguments, improving data validation and function behavior.
source: docs/project/bindgen.md#_snippet_6

language: typescript
code:
```
import { t, fn } from "bindgen";

export const add = fn({
  args: {
    global: t.globalObject,
    // enforce in i32 range
    a: t.i32.enforceRange(),
    // clamp to u16 range
    b: t.u16,
    // enforce in arbitrary range, with a default if not provided
    c: t.i32.enforceRange(0, 1000).default(5),
    // clamp to arbitrary range, or null
    d: t.u16.clamp(0, 10).optional,
  },
  ret: t.i32,
});
```

---

title: Validating Number Inputs with Bindgen - Typescript
description: Demonstrates how to use validator functions like `validateNumber`, `validateInt32`, and `validateInteger` to ensure that function arguments meet specific numerical criteria. This enables Node.js-compatible input validation with matching error messages.
source: docs/project/bindgen.md#_snippet_7

language: typescript
code:
```
import { t, fn } from "bindgen";

export const add = fn({
  args: {
    global: t.globalObject,
    // throw if not given a number
    a: t.f64.validateNumber(),
    // valid in i32 range
    a: t.i32.validateInt32(),
    // f64 within safe integer range
    b: t.f64.validateInteger(),
    // f64 in given range
    c: t.f64.validateNumber(-10000, 10000),
  },
  ret: t.i32,
});
```

---

title: Marking Tests as Todo Conditionally with Test.todoIf in Bun:test
description: Illustrates marking a test as TODO based on a condition using `test.todoIf()` in `bun:test`.  This is helpful to mark tests that are planned but not yet implemented for a specific target. The example checks if the operating system is MacOS and marks the test as todo if it is.
source: docs/test/writing.md#_snippet_10

language: ts
code:
```
const macOS = process.arch === "darwin";

// TODO: we've only implemented this for Linux so far.
test.todoIf(macOS)("runs on posix", () => {
  // runs if *not* macOS
});
```

---

title: Truncating Large Integers - With SafeIntegers False
description: Shows how `bun:sqlite` truncates integers beyond 53 bits when `safeIntegers` is `false`. This can lead to unexpected behavior or data loss if not carefully considered, so it is essential to be aware of this when working with large integer values.
source: docs/api/sqlite.md#_snippet_9

language: typescript
code:
```
import { Database } from "bun:sqlite";

const db = new Database(":memory:", { safeIntegers: false });
const query = db.query(
  `SELECT ${BigInt(Number.MAX_SAFE_INTEGER) + 102n} as max_int`,
);
const result = query.get();
console.log(result.max_int); // => 9007199254741092
```

---

title: Upgrading Bun to Canary Build
description: Illustrates how to upgrade to the latest canary build of Bun using `bun upgrade --canary`. Canary builds are bleeding-edge releases, useful for testing new features and bug fixes but potentially unstable.
source: docs/installation.md#_snippet_13

language: sh
code:
```
$ bun upgrade --canary
```

---

title: Decoding base64 Encoded Password - Bash
description: Illustrates how to decode a base64-encoded password using the `base64` command line tool. It's important to note that using this command may save the password in your terminal history, which is generally not recommended for security reasons.
source: docs/guides/install/azure-artifacts.md#_snippet_4

language: bash
code:
```
echo "base64-encoded-password" | base64 --decode
```

---

title: Ignoring Sourcemaps in Coverage Analysis - TOML
description: Illustrates how to disable sourcemap usage for coverage analysis by setting `coverageIgnoreSourcemaps = true` in the `[test]` section of `bunfig.toml`.  When enabled, Bun's transpilation sourcemaps are skipped which may lead to confusing results because Bun may move code around and change variable names during transpilation.  Use `// @bun` comment in source files to opt out of the transpilation process for better results.
source: docs/test/configuration.md#_snippet_6

language: toml
code:
```
[test]
coverageIgnoreSourcemaps = true  # Don't use sourcemaps for coverage analysis
```

---

title: Ignoring Sourcemaps in Coverage - Configuration
description: Illustrates how to disable the use of sourcemaps in code coverage calculations using the `coverageIgnoreSourcemaps` option in `bunfig.toml`. This is generally not recommended, but it can be useful in advanced scenarios where source map integration is undesirable.
source: docs/test/coverage.md#_snippet_4

language: toml
code:
```
[test]
coverageIgnoreSourcemaps = true   # default false
```

---

title: Using Failing Tests to Track Known Bugs in Bun:test
description: Demonstrates using `test.failing()` to track known bugs and get notified when they start passing in `bun:test`. This function inverts the test result; a failing test will pass and a passing test will fail.
source: docs/test/writing.md#_snippet_11

language: ts
code:
```
// This will pass because the test is failing as expected
test.failing("math is broken", () => {
  expect(0.1 + 0.2).toBe(0.3); // fails due to floating point precision
});

// This will fail with a message that the test is now passing
test.failing("fixed bug", () => {
  expect(1 + 1).toBe(2); // passes, but we expected it to fail
});
```

---

title: Managing Distributed Transactions - TypeScript
description: Demonstrates how to begin, commit, and rollback distributed transactions using `sql.beginDistributed`, `sql.commitDistributed`, and `sql.rollbackDistributed`. Distributed transactions are persisted beyond their original session, and the system automatically rolls back all changes if any exceptions occur during the distributed transaction.
source: docs/api/sql.md#_snippet_6

language: typescript
code:
```
// Begin a distributed transaction
await sql.beginDistributed("tx1", async tx => {
  await tx`INSERT INTO users (name) VALUES (${'Alice'})`;
});

// Later, commit or rollback
await sql.commitDistributed("tx1");
// or
await sql.rollbackDistributed("tx1");
```

---

title: Using Smol Mode With Worker
description: Demonstrates how to enable `smol` mode for a worker to reduce memory usage.  This is done by passing `smol: true` in the options object when constructing the `Worker`.
source: docs/api/workers.md#_snippet_15

language: js
code:
```
const worker = new Worker("./i-am-smol.ts", {
  smol: true,
});
```

---

title: Enabling Verbose Debug Logging
description: Shows how to enable verbose debug logging for `fetch` requests in Bun. This prints detailed request and response headers to the console, aiding in debugging network issues.
source: docs/api/fetch.md#_snippet_10

language: typescript
code:
```
const response = await fetch("http://example.com", {
  verbose: true,
});
```

---

title: Pulling Docker Images
description: Demonstrates pulling different Docker images for Bun. It is useful in environments where specific operating systems are required.
source: docs/installation.md#_snippet_16

language: bash
code:
```
$ docker pull oven/bun:debian
$ docker pull oven/bun:slim
$ docker pull oven/bun:distroless
$ docker pull oven/bun:alpine
```

---

title: Executing Unsafe Queries - TypeScript
description: Demonstrates how to execute raw SQL strings using the `sql.unsafe` function in Bun's SQL client. It is important to use this with caution, as it will not escape user input, potentially leading to SQL injection vulnerabilities. Executing multiple commands per query is allowed only if no parameters are used.
source: docs/api/sql.md#_snippet_12

language: ts
code:
```
// Multiple commands without parameters
const result = await sql.unsafe(`
  SELECT ${userColumns} FROM users;
  SELECT ${accountColumns} FROM accounts;
`);

// Using parameters (only one command is allowed)
const result = await sql.unsafe(
  "SELECT " + dangerous + " FROM users WHERE id = $1",
  [id],
);
```

---

title: Disabling TLS Validation
description: Demonstrates how to disable TLS validation using Bun's `fetch` API by setting `rejectUnauthorized` to `false`. This is useful for self-signed certificates, but it disables security checks and should be used with caution.
source: docs/api/fetch.md#_snippet_9

language: typescript
code:
```
await fetch("https://example.com", {
  tls: {
    rejectUnauthorized: false,
  },
});
```

---